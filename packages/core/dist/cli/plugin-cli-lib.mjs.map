{"version":3,"sources":["../../src/cli/plugin-cli-lib.ts"],"names":["default","Command","Option"],"mappings":";;;;;;;;AAAA,SAAS,oBAAoB;AAC7B,SAAS,eAAuB;AAEhC,OAAO,WAAW;AAMlB,SAAoB,WAAXA,gBAAwB;AAIjC,SAAS,WAAAC,UAAS,UAAAC,eAAc;AAIhC,IAAM,QAAQ,MAAM,iBAAiB;AAS9B,SAAS,oBAAoB,MAExB;AACV,MAAI;AACJ,MAAI;AACJ,MAAI;AAIJ,UAAQ,GAAG,WAAW,CAAC,YAAiB;AACtC,UAAM,oCAAoC,OAAO;AACjD,UAAM,CAAC,aAAa,OAAO,IAAI;AAC/B,QAAI,gBAAgB,QAAQ;AAC1B,kBAAY,QAAQ;AACpB,eAAS,QAAQ;AACjB,4BAAsB,QAAQ;AAE9B,cAAQ,QAAQ;AAAA,IAClB;AAAA,EACF,CAAC;AACD,UAAQ,GAAG,QAAQ,MAAM;AACvB,UAAM,sBAAsB;AAAA,EAC9B,CAAC;AAGD,UAAQ,GAAG,WAAW,MAAM;AAC1B,UAAM,uBAAuB;AAC7B,YAAQ,KAAK,CAAC;AAAA,EAChB,CAAC;AACD,UAAQ,GAAG,UAAU,MAAM;AACzB,UAAM,sBAAsB;AAC5B,YAAQ,KAAK,CAAC;AAAA,EAChB,CAAC;AAED,QAAM,UAAU,sBAAsB;AAItC,QAAM,WAAW,IAAI,MAAM,EAAE,MAAO,MAAM,IAAI;AAC9C,QAAM,cAAc,SAAS,CAAC,EAAE,QAAQ,mBAAmB,EAAE,EAAE,QAAQ,eAAe,EAAE;AACxF,QAAM,kBAAkB,GAAG,WAAW;AACtC,QAAM,iBAAiB,aAAa,iBAAiB,OAAO;AAC5D,QAAM,cAAgC,KAAK,MAAM,cAAc;AAC/D,QAAM,cAAc,YAAY;AAEhC,QAAM,UAAU,IAAI,QAAQ,gCAAgC,EACzD,YAAY,GAAG,WAAW,MAAM,EAChC,KAAK,iBAAiB,OAAO,aAAa,kBAAkB;AAE3D,UAAM,QAAQ;AAId,IAAC,cAAsB,mBAAmB;AAAA,MACxC;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF,CAAC;AACH,OAAK,SAAS,QAAQ,CAAC,MAAM,QAAQ,WAAW,CAAC,CAAC;AAClD,SAAO;AACT;AA7DgB;AAgET,SAAS,2BAA2B,aAe/B;AACV,QAAM,iBAAiB,IAAI,QAAQ,YAAY,IAAI,EAChD,QAAQ,YAAY,OAAO,EAC3B,YAAY,YAAY,WAAW;AACtC,MAAI,YAAY,OAAO,QAAQ;AAC7B,mBAAe,MAAM,YAAY,KAAK;AAAA,EACxC;AACA,MAAI,aAAa,SAAS,QAAQ;AAChC,gBAAY,QAAQ,QAAQ,CAAC,MAAM,eAAe,UAAU,CAAC,CAAC;AAAA,EAChE;AAEA,iBAAe,OAAO,OAAO,MAAM,gBAAgB;AACjD,UAAM,YAAa,YAAoB;AAEvC,UAAM,YAAY,QAAQ,WAAW,MAAM,WAAW;AAAA,EACxD,CAAC;AACD,SAAO;AACT;AAhCgB","sourcesContent":["import { readFileSync } from 'node:fs';\nimport { Command, Option } from 'commander';\nimport { createDeferredPromise } from '@dmno/ts-lib';\nimport Debug from 'debug';\nimport kleur from 'kleur';\n\nimport { SerializedDmnoPlugin, SerializedWorkspace } from '../config-loader/serialization-types';\n\n// re-export kleur so the child cli does not have to declare dependency\nexport { default as kleur } from 'kleur';\n\n// this helps with some weird TS issues even though the child cli will not use directly\n// see https://github.com/microsoft/TypeScript/issues/42873\nexport { Command, Option } from 'commander';\n\n\n\nconst debug = Debug('dmno:plugin-cli');\n\n\ntype PluginCliDmnoCtx = {\n  workspace: SerializedWorkspace,\n  plugin: SerializedDmnoPlugin,\n  selectedServiceName?: string,\n};\n\nexport function createDmnoPluginCli(opts: {\n  commands: Array<Command>,\n}): Command {\n  let workspace: SerializedWorkspace;\n  let plugin: SerializedDmnoPlugin;\n  let selectedServiceName: string | undefined;\n\n  // do some process initialization to handle clean shutdowns\n  // and IPC with the parent CLI\n  process.on('message', (message: any) => {\n    debug('received message from parent cli', message);\n    const [messageType, payload] = message;\n    if (messageType === 'init') {\n      workspace = payload.workspace;\n      plugin = payload.plugin;\n      selectedServiceName = payload.selectedServiceName;\n\n      isReady.resolve();\n    }\n  });\n  process.on('exit', () => {\n    debug('child cli is exiting');\n  });\n\n  // TODO: handle other signals\n  process.on('SIGTERM', () => {\n    debug('child process SIGTERM');\n    process.exit(1);\n  });\n  process.on('SIGINT', () => {\n    debug('child process SIGINT');\n    process.exit(1);\n  });\n\n  const isReady = createDeferredPromise();\n\n  // reading name from package.json file\n  // TODO: maybe we can inject the plugin name somehow during the build process?\n  const errStack = new Error().stack!.split('\\n');\n  const packagePath = errStack[2].replace(/.* at file:\\/\\//, '').replace(/\\/dist\\/.*$/, '');\n  const packageJsonPath = `${packagePath}/package.json`;\n  const packageJsonStr = readFileSync(packageJsonPath, 'utf-8');\n  const packageJson: { name: string } = JSON.parse(packageJsonStr);\n  const packageName = packageJson.name;\n\n  const program = new Command('dmno plugin -p [pluginName] --')\n    .description(`${packageName} cli`)\n    .hook('preSubcommand', async (thisCommand, actionCommand) => {\n      // wait for our \"init\" message to come over the fork IPC\n      await isReady.promise;\n\n      // attach workspace/plugin info onto the command\n      // TODO: we could use AsyncLocalStorage for this, but this seems fine since it is contained to this file\n      (actionCommand as any).dmnoPluginCliCtx = {\n        workspace,\n        plugin,\n        selectedServiceName,\n      } satisfies PluginCliDmnoCtx;\n    });\n  opts.commands.forEach((c) => program.addCommand(c));\n  return program;\n}\n\n\nexport function createDmnoPluginCliCommand(commandSpec: {\n  name: string,\n  alias?: string,\n  summary: string,\n  description: string,\n  examples?: Array<{\n    command: string,\n    description: string,\n  }>,\n  options?: Array<Option>,\n  handler: (\n    ctx: PluginCliDmnoCtx,\n    opts: any,\n    command: any,\n  ) => Promise<void>,\n}): Command {\n  const commandProgram = new Command(commandSpec.name)\n    .summary(commandSpec.summary)\n    .description(commandSpec.description);\n  if (commandSpec.alias?.length) {\n    commandProgram.alias(commandSpec.alias);\n  }\n  if (commandSpec?.options?.length) {\n    commandSpec.options.forEach((o) => commandProgram.addOption(o));\n  }\n\n  commandProgram.action(async (opts, thisCommand) => {\n    const pluginCtx = (thisCommand as any).dmnoPluginCliCtx as PluginCliDmnoCtx;\n\n    await commandSpec.handler(pluginCtx, opts, thisCommand);\n  });\n  return commandProgram;\n}\n"]}