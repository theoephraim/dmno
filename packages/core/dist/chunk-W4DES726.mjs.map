{"version":3,"sources":["../../ts-lib/src/defer-promise.ts","../../ts-lib/src/promise-delay.ts","../../../node_modules/.pnpm/is-promise@4.0.0/node_modules/is-promise/index.mjs","../../ts-lib/src/try-catch.ts"],"names":[],"mappings":";;;;;AAEO,SAAS,wBAAqC;AAEnD,MAAI,UAA+B,6BAAM;AAAA,EAAC,GAAP;AACnC,MAAI,SAAqC,6BAAM;AAAA,EAAC,GAAP;AACzC,QAAM,UAAU,IAAI,QAAQ,CAAC,UAAU,YAAY;AACjD,cAAU;AACV,aAAS;AAAA,EACX,CAAC;AAED,SAAO,EAAE,SAAS,SAAS,OAAO;AACpC;AAVgB;;;ACFhB,eAAsB,aAAa,WAAmB;AACpD,SAAO,IAAI,QAAQ,CAAC,YAAY;AAC9B,eAAW,SAAS,SAAS;AAAA,EAC/B,CAAC;AACH;AAJsB;;;ACAP,SAAR,UAA2B,KAAK;AACrC,SAAO,CAAC,CAAC,QAAQ,OAAO,QAAQ,YAAY,OAAO,QAAQ,eAAe,OAAO,IAAI,SAAS;AAChG;AAFwB;;;ACMxB,eAAsB,SACpB,OACA,SAGgB;AAChB,MAAI;AACF,WAAO,MAAM,MAAM;AAAA,EACrB,SAAS,KAAK;AACZ,QAAI,cAAc,QAAQ,GAAY;AACtC,QAAI,UAAU,WAAW,GAAG;AAC1B,oBAAc,MAAM;AAAA,IACtB;AACA,WAAO;AAAA,EACT;AACF;AAfsB","sourcesContent":["// useful when you need to export a promise before ready to start whatever will initialize it\n// should be used sparingly\nexport function createDeferredPromise<T = unknown>() {\n  // set to noop, but they will be replaced immediately\n  let resolve: (value?: T) => void = () => {};\n  let reject: (reason?: unknown) => void = () => {};\n  const promise = new Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n\n  return { promise, resolve, reject };\n}\n\nexport type DeferredPromise<T = void> = ReturnType<typeof createDeferredPromise<T>>;\n","export async function promiseDelay(delayInMs: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, delayInMs);\n  });\n}\n","export default function isPromise(obj) {\n  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';\n}\n","import isPromise from 'is-promise';\n\n// see https://www.npmjs.com/package/no-try for inspiration\n// although their focus was not on the typing...\n\n/** try-catch alternative that exposes a typed response rather than having it stuck in the try's scope */\nexport async function tryCatch<T, E>(\n  tryFn: () => T | Promise<T>,\n  catchFn: (err: Error) => E | Promise<E>,\n\n// @ts-ignore\n): Promise<T | E> {\n  try {\n    return await tryFn();\n  } catch (err) {\n    let catchResult = catchFn(err as Error);\n    if (isPromise(catchResult)) {\n      catchResult = await catchResult;\n    }\n    return catchResult;\n  }\n}\n"]}