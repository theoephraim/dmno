{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { dirname } from 'node:path';\nimport { fileURLToPath } from 'url';\nimport { injectDmnoGlobals } from 'dmno/injector';\nimport type { AstroIntegration } from 'astro';\nimport type { ConfigServerClient } from 'dmno';\n\n\nlet enableDynamicPublicClientLoading = false;\nlet astroCommand: 'dev' | 'build' | 'preview' = 'build';\n\n\n// console.log('dmno astro integration file loaded!');\n\n\n// // initialize a dmno config server client, but only once\n// (process as any).dmnoConfigClient ||= new ConfigServerClient();\n// const dmnoConfigClient: ConfigServerClient = (process as any).dmnoConfigClient;\n\nconst __dirname = dirname(fileURLToPath(import.meta.url));\nthrow new Error('UH OH!');\n\n// // Unsure why, but in some cases this whole file reloads, and in others it doesnt\n// // so we may need to reload the config multiple times\n// // TODO: try to clean this logic up a bit?\n// let dmnoService: Awaited<ReturnType<typeof dmnoConfigClient.getServiceConfig>>;\nlet configItemKeysAccessed: Record<string, boolean> = {};\nlet dmnoConfigValid = true;\nlet publicDynamicItemKeys: Array<string> = [];\nlet sensitiveItemKeys: Array<string> = [];\nlet sensitiveValueLookup: Record<string, string> = {};\nlet viteDefineReplacements = {} as Record<string, string>;\n\nasync function reloadDmnoConfig() {\n  if (astroCommand === 'dev') {\n    // dmnoService = await dmnoConfigClient.getServiceConfig();\n    // dmnoConfigValid = ConfigServerClient.checkServiceIsValid(dmnoService);\n    // configItemKeysAccessed = {};\n\n    // injectDmnoGlobals({\n    //   injectedConfig: serializedServiceToInjectedConfig(dmnoService),\n    //   trackingObject: configItemKeysAccessed,\n    // });\n  } else {\n    const { staticReplacements } = injectDmnoGlobals();\n    viteDefineReplacements = staticReplacements || {};\n  }\n\n  publicDynamicItemKeys = (globalThis as any)._DMNO_PUBLIC_DYNAMIC_KEYS;\n  sensitiveItemKeys = (globalThis as any)._DMNO_SENSITIVE_KEYS;\n  sensitiveValueLookup = {};\n  for (const itemKey of sensitiveItemKeys) {\n    const val = (globalThis as any).DMNO_CONFIG[itemKey];\n    if (val) sensitiveValueLookup[itemKey] = val.toString();\n  }\n}\n\n// // we do want to run this right away so the globals get injected into the astro.config file\n// await reloadDmnoConfig();\n\n\n\nlet dmnoHasTriggeredReload = false;\n\ntype DmnoAstroIntegrationOptions = {\n  // TODO: figure out options - loading dynamic public config?\n};\n\nfunction dmnoAstroIntegration(dmnoIntegrationOpts?: DmnoAstroIntegrationOptions): AstroIntegration {\n  // console.log('dmno astro integration initialized');\n\n  return {\n    name: 'dmno-astro-integration',\n    hooks: {\n      'astro:config:setup': async (opts) => {\n        // this handles the case where astro's vite server reloaded but this file did not get reloaded\n        if (dmnoHasTriggeredReload) {\n          await reloadDmnoConfig();\n          dmnoHasTriggeredReload = false;\n        }\n        const {\n          isRestart, logger, addDevToolbarApp, updateConfig,\n          injectScript, addMiddleware, injectRoute,\n        } = opts;\n\n        astroCommand = opts.command;\n\n        if (opts.command === 'build' && !dmnoConfigValid) {\n          throw new Error('DMNO config is not valid');\n        }\n\n        if (opts.config.output === 'static') {\n          enableDynamicPublicClientLoading = false;\n        } else {\n          enableDynamicPublicClientLoading = publicDynamicItemKeys.length > 0;\n        }\n\n\n        updateConfig({\n          vite: {\n            plugins: [{\n              name: 'astro-vite-plugin',\n              async config(config, env) {\n                // console.log('vite plugin config!');\n\n                // console.log('STATIC REPLACEMENTS', staticConfigReplacements);\n\n                // inject rollup rewrites via config.define\n                config.define = {\n                  ...config.define,\n                  ...viteDefineReplacements,\n                };\n              },\n\n              // async configureServer(server) {\n              //   // console.log('astro vite plugin configure server');\n              //   if (!isRestart) {\n              //     dmnoConfigClient.eventBus.on('reload', () => {\n              //       opts.logger.info('ðŸ’« dmno config updated - restarting astro server');\n              //       // eslint-disable-next-line @typescript-eslint/no-floating-promises\n              //       server.restart();\n              //       dmnoHasTriggeredReload = true;\n              //     });\n              //   }\n              // },\n\n              // leak detection in _built_ files\n              transform(src, id) {\n                // TODO: can probably add some rules to skip leak detection on files coming from external deps\n\n                // console.log('vite plugin transform - ', id);\n\n                // skip detection if backend file\n                if (id === 'astro:scripts/page-ssr.js') return src;\n\n                for (const itemKey in sensitiveValueLookup) {\n                  if (src.includes(sensitiveValueLookup[itemKey])) {\n                    // console.log(src);\n                    // TODO: better error details to help user find the problem\n                    throw new Error(`ðŸš¨ DETECTED LEAKED CONFIG ITEM \"${itemKey}\" in file - ${id}`);\n                  }\n                }\n\n                return src;\n              },\n            }],\n          },\n        });\n\n        // inject script into CLIENT context\n        injectScript('page', [\n          // client side DMNO_PUBLIC_CONFIG proxy object\n          // TODO: ideally we can throw a better error if we know its a dynamic item and we aren't loading dynamic stuff\n          `\n            window._DMNO_PUBLIC_STATIC_CONFIG = window.DMNO_PUBLIC_CONFIG || {};\n            window.DMNO_PUBLIC_CONFIG = new Proxy({}, {\n              get(o, key) {\n                if (key in window._DMNO_PUBLIC_STATIC_CONFIG) {\n                  return window._DMNO_PUBLIC_STATIC_CONFIG[key];\n                }\n          `,\n\n          // if dynamic public config is enabled, we'll fetch it on-demand\n          // this is fine because we only hit this block if the rewrite failed\n          // (or wasnt found in the static vars during dev)\n          enableDynamicPublicClientLoading ? `\n                if (!window._DMNO_PUBLIC_DYNAMIC_CONFIG) {\n                  const request = new XMLHttpRequest();\n                  request.open(\"GET\", \"/public-dynamic-config.json\", false); // false means sync/blocking!\n                  request.send(null);\n\n                  if (request.status !== 200) {\n                    throw new Error('Failed to load public dynamic DMNO config');\n                  }\n                  window._DMNO_PUBLIC_DYNAMIC_CONFIG = JSON.parse(request.responseText);\n                  \n                  console.log('loaded public dynamic config', window._DMNO_PUBLIC_DYNAMIC_CONFIG);\n                }\n                \n                if (key in window._DMNO_PUBLIC_DYNAMIC_CONFIG) {\n                  return window._DMNO_PUBLIC_DYNAMIC_CONFIG[key];\n                }\n          ` : `\n                if (${JSON.stringify(publicDynamicItemKeys)}.includes(key)) {\n                  throw new Error(\\`âŒ Unable to access dynamic config item \\\\\\`\\${key}\\\\\\` in Astro \"static\" output mode\\`);\n                }\n          `,\n\n          // in dev mode, we'll give a more detailed error message, letting the user know if they tried to access a sensitive or non-existant item\n          astroCommand === 'dev' ? `\n                if (${JSON.stringify(sensitiveItemKeys)}.includes(key)) {\n                  throw new Error(\\`âŒ \\\\\\`DMNO_PUBLIC_CONFIG.\\${key}\\\\\\` not found - it is sensitive and must be accessed via DMNO_CONFIG on the server only\\`);\n                } else {\n                  throw new Error(\\`âŒ \\\\\\`DMNO_PUBLIC_CONFIG.\\${key}\\\\\\` not found - it does not exist in your config schema\\`);  \n                }\n          ` : ` \n                throw new Error(\\`âŒ \\\\\\`DMNO_PUBLIC_CONFIG.\\${key}\\\\\\` not found - it may be sensitive or it may not exist at all\\`);\n          `,\n          `\n              }\n            });\n          `,\n\n          // DMNO_CONFIG proxy object just to give a helpful error message\n          // TODO: we could make this a warning instead? because it does get replaced during the build and doesn't actually harm anything\n          `\n            window.DMNO_CONFIG = new Proxy({}, {\n              get(o, key) {\n                throw new Error(\\`âŒ You cannot access DMNO_CONFIG on the client, try DMNO_PUBLIC_CONFIG.\\${key} instead \\`);\n              }\n            });\n          `,\n        ].join('\\n'));\n\n\n        if (enableDynamicPublicClientLoading) {\n          injectRoute({\n            pattern: 'public-dynamic-config.json',\n            // Use relative path syntax for a local route.\n            entrypoint: `${__dirname}/fetch-public-dynamic-config.json.mjs`,\n          });\n        }\n\n        // add leak detection middleware!\n        addMiddleware({\n          entrypoint: `${__dirname}/astro-middleware.mjs`,\n          order: 'post', // not positive on this?\n        });\n\n        // enable the toolbar (currently does nothing...)\n        addDevToolbarApp(`${__dirname}/dev-toolbar-app.mjs`);\n      },\n      'astro:build:done': async (opts) => {\n        // if we didn't actually pre-render any pages, we can move one\n        // (this would be the case in output=server mode with no `prerender` pages\n        if (!opts.pages.length) return;\n\n        // otherwise, we want to check which config was used during prerendering\n        // so if any were expected to be dyanmic (ie loaded at boot time) we can throw/warn\n\n        // // TODO: currently we're just showing a warning, may want to throw? have more settings?\n        // const dynamicKeysUsedDuringPrerender = Object.keys(configItemKeysAccessed)\n        //   .filter((k) => dmnoService.config[k].isDynamic);\n        // if (dynamicKeysUsedDuringPrerender.length) {\n        //   opts.logger.warn('Dynamic config items were accessed during pre-render:');\n        //   dynamicKeysUsedDuringPrerender.forEach((k) => {\n        //     opts.logger.warn(`- ${k}`);\n        //   });\n        //   opts.logger.warn('> Change service\\'s default behavior by adjusting `settings.dynamicConfig`');\n        //   opts.logger.warn('> Or adjust individual items to `{ \"dynamic\": \"false\" }` to make them static');\n        //   opts.logger.warn('> See https://dmno.dev/docs/guides/dynamic-config/ for more info');\n        // }\n      },\n    },\n  };\n}\n\n\nexport default dmnoAstroIntegration;\n"]}