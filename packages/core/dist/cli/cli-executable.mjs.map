{"version":3,"sources":["../../src/cli/lib/init-process.ts","../../src/cli/cli-executable.ts","../../src/cli/lib/dmno-command.ts","../../src/cli/lib/cli-schema-generation.ts","../../src/cli/lib/help-customizations.ts","../../src/cli/lib/cli-ctx.ts","../../src/config-loader/config-loader.ts","../../src/config-loader/vite-server.ts","../../src/config-loader/find-services.ts","../../src/config-engine/type-generation.ts","../../src/cli/lib/cli-error.ts","../../src/cli/lib/watch-mode-helpers.ts","../../src/cli/commands/resolve.command.ts","../../src/cli/lib/selection-helpers.ts","../../src/cli/lib/string-utils.ts","../../src/cli/lib/cache-helpers.ts","../../src/cli/lib/check-errors-helpers.ts","../../src/cli/commands/run.command.ts","../../src/cli/commands/dev.command.ts","../../src/config-loader/config-server.ts","../../src/cli/lib/loaders.ts","../../src/cli/commands/plugin.command.ts","../../src/cli/commands/init.command.ts","../../src/cli/lib/init-helpers.ts","../../src/cli/lib/config-file-updater.ts","../../src/cli/lib/diff-utils.ts","../../src/cli/lib/schema-scaffold.ts","../../src/lib/constants.ts","../../src/cli/commands/clear-cache.command.ts","../../src/cli/commands/printenv.command.ts"],"names":["Debug","program","_","path","fs","debug","kleur","gradient","debugTimer","str","TERMINAL_COLS","input","confirm","execSync","outdent","fdir"],"mappings":"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","sourcesContent":["import kleur from 'kleur';\n\nprocess.on('uncaughtException', (err) => {\n  console.log(kleur.red(`UNCAUGHT EXCEPTION: ${err.message}`));\n  console.log(kleur.red(`UNCAUGHT EXCEPTION: ${err.stack}`));\n  // eslint-disable-next-line no-restricted-syntax\n  process.exit(1);\n});\n","#!/usr/bin/env node\n// hashbang needed to get npm generated \".bin/dmno\" to work with esm imports\n\n/* eslint-disable import/first */\n// import first - we add global exception handler here\nconst startBoot = new Date().getTime();\n\nimport './lib/init-process';\n\nimport _ from 'lodash-es';\nimport kleur from 'kleur';\nimport Debug from 'debug';\nimport { DmnoCommand } from './lib/dmno-command';\n\nimport { addDocsCommand } from './lib/cli-schema-generation';\nimport { customizeHelp } from './lib/help-customizations';\nimport { getCliRunCtx, initCliRunCtx } from './lib/cli-ctx';\nimport { CliExitError } from './lib/cli-error';\nimport { WATCHING_FILES_MESSAGE } from './lib/watch-mode-helpers';\n\n\nimport { ResolveCommand } from './commands/resolve.command';\nimport { RunCommand } from './commands/run.command';\nimport { DevCommand } from './commands/dev.command';\nimport { PluginCommand } from './commands/plugin.command';\nimport { InitCommand } from './commands/init.command';\nimport { ClearCacheCommand } from './commands/clear-cache.command';\nimport { PrintEnvCommand } from './commands/printenv.command';\n\n\n\n\nconst debug = Debug('dmno:cli');\n\nconst program = new DmnoCommand('dmno')\n  .description('dmnno cli - https://dmno.dev')\n  .version('0.0.1');\n\nprogram.addCommand(ResolveCommand);\nprogram.addCommand(RunCommand);\nprogram.addCommand(DevCommand);\nprogram.addCommand(InitCommand);\nprogram.addCommand(ClearCacheCommand);\nprogram.addCommand(PluginCommand);\nprogram.addCommand(PrintEnvCommand);\n\n\n\n// have to pass through the root program for this one so we can access all the subcommands\naddDocsCommand(program);\n\ncustomizeHelp(program);\n\ninitCliRunCtx();\ndebug(`finish loading - begin parse ${+new Date() - startBoot}ms`);\ntry {\n  await program.parseAsync();\n} catch (err) {\n  // if we are on our first run and we hit an error, our watch-mode post-hook never fires\n  // so we must recreate that logic... can clean this up if it gets more complicated\n  if (err instanceof CliExitError) {\n    console.error(err.getFormattedOutput());\n\n    const ctx = getCliRunCtx();\n    if (ctx.watchEnabled && !err.forceExit) {\n      console.log(WATCHING_FILES_MESSAGE);\n    } else {\n      process.exit(1);\n    }\n  } else {\n    throw err;\n  }\n}\n","import { Command } from 'commander';\nimport _ from 'lodash-es';\n\ninterface CliCommandExample {\n  command: string;\n  description: string;\n}\n\n\n// extend command class to add an example method which adds examples to the help output\n/**\n * Extend built in commander.js Command class to add more functionality\n * - structured usage examples which can feed into docs and help\n * - wrapped action handler, which injects common functionality\n */\nexport class DmnoCommand extends Command {\n  /** array of usage examples */\n  examples: Array<CliCommandExample> = [];\n\n  /** attach a usage example - feeds into auto-generated docs */\n  example(command: string, description: string = '') {\n    this.examples.push({ command, description });\n    return this;\n  }\n}\n","import _ from 'lodash-es';\nimport { DmnoCommand } from './dmno-command';\n\n// this adds a hidden command which spits out a json schema of the entire cli\nexport function addDocsCommand(program: DmnoCommand) {\n  program\n    .command('get-cli-schema', { hidden: true })\n    .action(() => {\n      const commandsToDocument = program.commands.filter((c) => !(c as any)._hidden);\n      const commandsSchema = commandsToDocument.map((subCmd) => ({\n        command: subCmd.name(),\n        aliases: subCmd.aliases(),\n        description: subCmd.description(),\n        more: _.omit(subCmd, 'parent'),\n        ...subCmd instanceof DmnoCommand && {\n          examples: subCmd.examples,\n        },\n      }));\n      console.log(JSON.stringify(commandsSchema, null, 2));\n      process.exit();\n    });\n}\n","import { Argument, Command } from 'commander';\n\n// override help formatting ////////////////////////////////////////////////////////\nfunction humanReadableArgName(arg: Argument) {\n  const nameOutput = arg.name() + (arg.variadic === true ? '...' : '');\n  return arg.required ? `<${nameOutput}>` : `[${nameOutput}]`;\n}\nexport function customizeHelp(program: Command) {\n  program.configureHelp({\n    // see https://github.com/tj/commander.js/blob/master/lib/help.js#L136\n    subcommandTerm(cmd) {\n      const args = cmd.registeredArguments.map((arg) => humanReadableArgName(arg)).join(' ');\n      const cmdUsage = (cmd as any)._name\n        + ((cmd as any)._aliases[0] ? `|${(cmd as any)._aliases[0]}` : '')\n        + (cmd.options.length ? ' [options]' : '') // simplistic check for non-help option\n        + (args ? ` ${args}` : '');\n      return cmdUsage.replace('<external command>', '-- ...');\n    },\n  });\n}\n\n\n","import { AsyncLocalStorage } from 'node:async_hooks';\nimport { ConfigLoader } from '../../config-loader/config-loader';\nimport { DmnoService, DmnoWorkspace } from '../../config-engine/config-engine';\nimport { DmnoPlugin } from '../../config-engine/plugins';\n\nexport type CliRunCtx = {\n  configLoader: ConfigLoader;\n  workspace?: DmnoWorkspace;\n  selectedService?: DmnoService,\n  autoSelectedService?: boolean,\n  selectedPlugin?: DmnoPlugin,\n\n  /** true if watch mode is enabled */\n  watchEnabled?: boolean,\n  isWatchModeRestart?: boolean,\n  /**\n   * true if the command is meant to output strict formatted output (like JSON)\n   * used in combination with logging helper to silence additional output\n   * */\n  expectingOutput?: boolean,\n\n\n  // helpers - have to manually add types to avoid circular problems\n  /** log that swallows if command is expecting strictly formatted output (like JSON) */\n  log: typeof console.log;\n  /** log that always runs, meant to be called by anything that spits out strict formatted output */\n  logOutput: typeof console.log;\n};\n\nconst ctxHelpers = {\n  log(this: CliRunCtx, ...strs: Array<string>) {\n    if (!this.expectingOutput) {\n      console.log(...strs);\n    }\n  },\n  logOutput(this: CliRunCtx, ...strs: Array<string>) {\n    console.log(...strs);\n  },\n};\n\nexport const cliRunContext = new AsyncLocalStorage<CliRunCtx>();\n\nexport function initCliRunCtx() {\n  cliRunContext.enterWith({\n    // not sure about this...\n    // configLoader: new ConfigLoaderProcess(),\n    configLoader: new ConfigLoader(),\n    ...ctxHelpers,\n  });\n}\n\n\nexport function getCliRunCtx() {\n  const ctx = cliRunContext.getStore();\n  if (!ctx) throw new Error('unable to find cli run context in ALS');\n  return ctx;\n}\n","import crypto from 'crypto';\nimport fs from 'node:fs';\nimport kleur from 'kleur';\nimport _ from 'lodash-es';\n\nimport Debug from 'debug';\n\nimport { DeferredPromise, createDeferredPromise } from '@dmno/ts-lib';\nimport { HmrContext } from 'vite';\nimport { ViteNodeRunner } from 'vite-node/client';\nimport { ConfigLoaderRequestMap } from './ipc-requests';\nimport { createDebugTimer } from '../cli/lib/debug-timer';\nimport { setupViteServer } from './vite-server';\nimport { ScannedWorkspaceInfo, WorkspacePackagesListing, findDmnoServices } from './find-services';\nimport {\n  DmnoService, DmnoWorkspace, DmnoServiceConfig, CacheMode,\n} from '../config-engine/config-engine';\nimport { beginServiceLoadPlugins, beginWorkspaceLoadPlugins, finishServiceLoadPlugins } from '../config-engine/plugins';\nimport { ConfigLoadError } from '../config-engine/errors';\nimport { generateServiceTypes } from '../config-engine/type-generation';\n\nconst debugTimer = createDebugTimer('dmno:config-loader');\n\nconst debug = Debug('dmno');\n\nexport class ConfigLoader {\n  startAt: Date;\n  readyAt: Date | undefined;\n\n  // private isReadyDeferred: DeferredPromise = createDeferredPromise();\n  // get isReady() { return this.isReadyDeferred.promise; }\n  isReady: Promise<void>;\n\n  constructor() {\n    this.isReady = this.finishInit();\n    this.startAt = new Date();\n  }\n\n  private cacheMode: CacheMode = true;\n  setCacheMode(cacheMode: typeof this.cacheMode) {\n    if (this.dmnoWorkspace) this.dmnoWorkspace.setCacheMode(cacheMode);\n    this.cacheMode = cacheMode;\n  }\n\n\n  viteRunner?: ViteNodeRunner;\n\n  workspaceInfo!: ScannedWorkspaceInfo;\n  get workspacePackagesData() {\n    return this.workspaceInfo.workspacePackages;\n  }\n  get workspaceDmnoPackagesData() {\n    return this.workspaceInfo.workspacePackages.filter((p) => !!p.dmnoFolder);\n  }\n  get workspaceRootPath() {\n    return this.workspaceInfo.workspacePackages[0].path; // first should always be root (and is also marked)\n  }\n\n  private async finishInit() {\n    // console.time('find-services');\n    this.workspaceInfo = await findDmnoServices();\n    const dmnoServicePackages = this.workspaceInfo.workspacePackages.filter((p) => p.dmnoFolder);\n\n    // during init there may be no services at all\n    if (!dmnoServicePackages.length) return;\n\n    // console.timeEnd('find-services');\n\n    // TODO: we may want to do this on demand\n    // so it does not slow down `dmno init` or other commands that don't need it\n    const { viteRunner } = await setupViteServer(this.workspaceRootPath, (ctx) => this.viteHotReloadHandler(ctx));\n    this.viteRunner = viteRunner;\n  }\n\n  onReload?: () => void | Promise<void>;\n\n  private async viteHotReloadHandler(ctx: HmrContext) {\n    if (this.devMode) {\n      await this.reload();\n      if (this.onReload) await this.onReload();\n    }\n  }\n\n  devMode = false;\n  schemaLoaded = false;\n  dmnoWorkspace?: DmnoWorkspace;\n\n  async getWorkspace() {\n    if (this.dmnoWorkspace) return this.dmnoWorkspace;\n    await this.reload();\n    return this.dmnoWorkspace!;\n  }\n\n  async reload() {\n    // make sure everything is initialized\n    await this.isReady;\n\n    if (!this.viteRunner) throw new Error('vite server not ready yet');\n\n    // TODO: if not first load, clean up previous workspace? or reuse it somehow?\n    this.dmnoWorkspace = new DmnoWorkspace();\n    this.dmnoWorkspace.setCacheMode(this.cacheMode);\n    beginWorkspaceLoadPlugins(this.dmnoWorkspace);\n\n    // TODO: we may want to set up an initial sort of the services so at least root is first?\n    for (const w of this.workspacePackagesData) {\n      if (!w.dmnoFolder) continue;\n      // not sure yet about naming the root file differently?\n      // especially in the 1 service context, it may feel odd\n      // const configFilePath = `${w.path}/.dmno/${isRoot ? 'workspace-' : ''}config.mts`;\n      const configFilePath = `${w.path}/.dmno/config.mts`;\n\n\n      const serviceInitOpts = {\n        isRoot: w.isRoot,\n        packageName: w.name,\n        path: w.path,\n        workspace: this.dmnoWorkspace,\n      };\n\n      let service: DmnoService;\n      try {\n        beginServiceLoadPlugins();\n\n        // node-vite runs the file and returns the loaded module\n\n\n        // when dealing with hot reloads in dev mode, the files that are in the cache are not retriggered\n        // so we need to be aware that no side-effects would be re-triggered...\n        // for example the plugin loading trick of using a singleton to capture those plugins breaks :(\n        // the naive solution is to just clear the config files from the cache, but we may want to do something smarter\n        // we probably want to clear all user authored files (in the .dmno folder) rather than just the config files\n\n        // CLEAR EACH CONFIG FILE FROM THE CACHE SO WE RELOAD THEM ALL\n        this.viteRunner.moduleCache.deleteByModuleId(configFilePath);\n\n        const importedConfig = await this.viteRunner.executeFile(configFilePath);\n\n        if (w.isRoot && !importedConfig.default._isDmnoWorkspaceConfig) {\n          throw new Error('Workspace root .dmno/config.mts must `export default defineDmnoWorkspace(...)`');\n        }\n        if (!w.isRoot && !importedConfig.default._isDmnoServiceConfig) {\n          throw new Error('Non-root .dmno/config.mts must `export default defineDmnoService(...)`');\n        }\n\n        service = new DmnoService({\n          ...serviceInitOpts,\n          // NOTE - could actually be a DmnoServiceConfig or DmnoWorkspaceConfig\n          rawConfig: importedConfig.default as DmnoServiceConfig,\n        });\n\n        finishServiceLoadPlugins(service);\n      } catch (err) {\n        debug('found error when loading config');\n        service = new DmnoService({\n          ...serviceInitOpts,\n          rawConfig: new ConfigLoadError(err as Error),\n        });\n      }\n      this.dmnoWorkspace.addService(service);\n      debug('init service', service);\n    }\n\n    this.dmnoWorkspace.initServicesDag();\n    this.dmnoWorkspace.processConfig();\n\n    // TODO: currently this reloads EVERYTHING always. We need to be smarter about it\n    await this.regenerateAllTypeFiles();\n    await this.dmnoWorkspace.resolveConfig();\n\n    // if (this.devMode) {\n    //   await this.regenerateAllTypeFiles();\n    //   await this.dmnoWorkspace.resolveConfig();\n    // }\n    this.schemaLoaded = true;\n  }\n\n  private async regenerateAllTypeFiles() {\n    if (!this.dmnoWorkspace) return;\n    for (const service of this.dmnoWorkspace.allServices) {\n      await generateServiceTypes(service, true);\n    }\n  }\n}\n\n","import { HmrContext, Plugin, createServer } from 'vite';\nimport { ViteNodeRunner } from 'vite-node/client';\nimport { ViteNodeServer } from 'vite-node/server';\nimport { installSourcemapsSupport } from 'vite-node/source-map';\n\nexport async function setupViteServer(\n  workspaceRootPath: string,\n  hotReloadHandler: (ctx: HmrContext) => Promise<void>,\n) {\n  const customPlugin: Plugin = {\n    name: 'dmno-config-loader-plugin',\n\n    // THIS IS IMPORTANT - it forces our dmno code to be \"externalized\" rather than bundled\n    // otherwise we end up not loading the same code here in this file as within the config files\n    // meaning we have 2 copies of classes and `instanceof` stops working\n    enforce: 'pre', // Run before the builtin 'vite:resolve' of Vite\n    async resolveId(source, importer, options) {\n      // console.log(kleur.bgCyan('PLUGIN RESOLVE!'), source, importer, options);\n\n      if (source === 'dmno') {\n        // const resolution = await this.resolve(source, importer, options);\n        // console.log('resolution', resolution);\n        // if (!resolution) return;\n\n        return {\n          // pointing at dist/index is hard-coded...\n          // we could extract the main entry point from the resolution instead?\n          id: '/node_modules/dmno/dist/index.mjs',\n          // I believe this path is appended to our \"root\" which is our workpace root\n        };\n      }\n    },\n\n    transform(code, id, options) {\n      // fairly naive way of doing this... but for now we are replacing `DMNO_CONFIG.SOME_KEY` with `ctx.get('SOME_KEY')`\n      // TODO: we probably should limit which files this applies in\n      // TODO: this also assumes the user is only calling this within a resolver that has a `(ctx) => ` call signature...\n      return code.replaceAll(/DMNO_CONFIG\\.([\\w\\d.]+)/g, 'ctx.get(\\'$1\\')');\n    },\n\n    async handleHotUpdate(ctx) {\n      // ignore updates to the generated type files\n      if (ctx.file.includes('/.dmno/.typegen/')) return;\n\n      // TODO: not too sure about this, but we shouldn't be reloading the config when the user's app code is updated\n      // ignore files outside of the .dmno folder(s)?\n      if (!ctx.file.includes('/.dmno/')) return;\n\n      // console.log('hot reload in vite plugin', ctx);\n\n      // clear updated modules out of the cache\n      ctx.modules.forEach((m) => {\n        if (m.id) viteRunner.moduleCache.deleteByModuleId(m.id);\n      });\n\n      await hotReloadHandler(ctx);\n    },\n  };\n\n\n  // create vite server\n  const server = await createServer({\n    root: workspaceRootPath,\n    appType: 'custom',\n    clearScreen: false,\n    logLevel: 'warn',\n    plugins: [\n      customPlugin,\n    ],\n\n    // if the folder we are running in has its own vite.config file, it will try to use it\n    // passing false here tells it to skip that process\n    configFile: false,\n    build: {\n    // target: 'esnext',\n    // rollupOptions: {\n    //   external: 'dmno',\n    // },\n    //     // external: [...builtinModules, ...builtinModules.map((m) => `node:${m}`)],\n    //   },\n    // ssr: true,\n    },\n\n  });\n  // console.log(server.config);\n\n  // this is need to initialize the plugins\n  await server.pluginContainer.buildStart({});\n\n  // create vite-node server\n  const node = new ViteNodeServer(server, {\n  // debug: {\n  //   dumpModules: true,\n  // },\n  });\n\n\n  // fixes stacktraces in Errors\n  installSourcemapsSupport({\n    getSourceMap: (source) => node.getSourceMap(source),\n  });\n\n  // create vite-node runner\n  const viteRunner = new ViteNodeRunner({\n    debug: true,\n    root: server.config.root,\n    base: server.config.base,\n    // when having the server and runner in a different context,\n    // you will need to handle the communication between them\n    // and pass to this function\n    async fetchModule(id) {\n    // console.log('fetch module', id);\n      return node.fetchModule(id);\n    },\n    async resolveId(id, importer) {\n    // console.log('resolve id', id, importer);\n      return node.resolveId(id, importer);\n    },\n  });\n\n  return { viteRunner };\n}\n","import fs from 'node:fs';\nimport path from 'node:path';\nimport kleur from 'kleur';\nimport _ from 'lodash-es';\nimport readYamlFile from 'read-yaml-file';\nimport { fdir } from 'fdir';\nimport { tryCatch } from '@dmno/ts-lib';\nimport Debug from 'debug';\nimport { asyncMapValues } from '../lib/async-utils';\nimport { PackageManager, detectPackageManager } from '../lib/detect-package-manager';\n\nconst debug = Debug('dmno:find-services');\n\nexport async function readJsonFile(path: string) {\n  return JSON.parse(await fs.promises.readFile(path, 'utf8'));\n}\n\n\nexport type WorkspacePackagesListing = {\n  name: string,\n  version?: string,\n  path: string,\n  relativePath: string,\n  isRoot: boolean,\n  dmnoFolder: boolean,\n};\nexport type ScannedWorkspaceInfo = {\n  isMonorepo: boolean,\n  packageManager: PackageManager,\n  workspacePackages: Array<WorkspacePackagesListing>,\n  autoSelectedPackage?: WorkspacePackagesListing;\n};\n\nexport async function pathExists(p: string) {\n  try {\n    await fs.promises.access(p);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n\nexport async function findDmnoServices(includeUnitialized = true): Promise<ScannedWorkspaceInfo> {\n  const startAt = new Date();\n\n  const { packageManager, rootWorkspacePath: rootServicePath } = await detectPackageManager();\n\n  let packagePatterns: Array<string> | undefined;\n  let isMonorepo = false;\n\n  debug('looking for workspace globs');\n  if (packageManager === 'pnpm') {\n    // if no pnpm-workspace.yaml exists, it's not a monorepo\n    const pnpmWorkspaceYamlPath = `${rootServicePath}/pnpm-workspace.yaml`;\n    if (await pathExists(pnpmWorkspaceYamlPath)) {\n      const pnpmWorkspacesYaml = await readYamlFile(`${rootServicePath}/pnpm-workspace.yaml`);\n      isMonorepo = true;\n      packagePatterns = (pnpmWorkspacesYaml as any).packages;\n      debug('looked in pnpm-workspace.yaml for \"packages\" field');\n    } else {\n      debug('no pnpm-workspace.yaml found');\n    }\n  } else if (packageManager === 'yarn' || packageManager === 'npm' || packageManager === 'bun') {\n    const rootPackageJson = await readJsonFile(`${rootServicePath}/package.json`);\n    if (rootPackageJson.workspaces) {\n      isMonorepo = true;\n      packagePatterns = rootPackageJson.workspaces;\n    }\n    debug('looked in package.json for \"workspaces\" field');\n  } else if (packageManager === 'moon') {\n    const moonWorkspacesYaml = await readYamlFile(`${rootServicePath}/.moon/workspace.yml`);\n    isMonorepo = true;\n    packagePatterns = (moonWorkspacesYaml as any).projects;\n    debug('looked in .moon/workspace.yml for \"projects\" field');\n  }\n\n  // console.log('Package manager = ', packageManager);\n  // console.log('workspace root = ', rootServicePath);\n  // console.log('is monorepo?', isMonorepo);\n  // console.log('packages globs', packagesGlobs);\n\n\n  let packagePaths = [rootServicePath];\n  if (isMonorepo && packagePatterns?.length) {\n    const fullPackagePatterns = packagePatterns.map((gi) => path.resolve(`${rootServicePath}/${gi}`));\n    const packageGlobs = fullPackagePatterns.filter((s) => s.includes('*'));\n    const packageDirs = fullPackagePatterns.filter((s) => !s.includes('*'));\n    const expandedPathsFromGlobs = await (\n      // tried a few different libs here (tiny-glob being the other main contender) and this is WAY faster especially with some tuning :)\n      new fdir() // eslint-disable-line new-cap\n        .withBasePath()\n        .onlyDirs()\n        .glob(...packageGlobs)\n        .exclude((dirName, _dirPath) => {\n          // this helps speed things up since it stops recursing into these directories\n          return (\n            dirName === 'node_modules'\n            // could add more... doesn't seem to make a big difference\n            // || dirName === '.dmno'\n            // || dirName === 'src'\n            // || dirName === 'dist'\n            // || dirName === '.next'\n          );\n        })\n        .crawl(rootServicePath)\n        .withPromise()\n    );\n    packagePaths.push(...packageDirs);\n    packagePaths.push(...expandedPathsFromGlobs);\n    packagePaths = packagePaths.map((p) => p.replace(/\\/$/, '')); // remove trailing slash\n    packagePaths = _.uniq(packagePaths);\n  }\n\n  const workspacePackages = _.compact(await Promise.all(packagePaths.map(async (packagePath) => {\n    const packageJson = await tryCatch(\n      async () => await readJsonFile(`${packagePath}/package.json`),\n      (err) => {\n        // missing package.json, so we'll skip this one\n        // currently this is true for a folder containing other packages\n        // but eventually for polyglot support we may need some other logic here\n        if ((err as any).code === 'ENOENT') {\n          return undefined;\n        }\n        throw err;\n      },\n    );\n    if (!packageJson) return;\n\n    const dmnoFolderExists = await pathExists(`${packagePath}/.dmno`);\n\n    return {\n      isRoot: packagePath === rootServicePath,\n      path: packagePath,\n      relativePath: packagePath.substring(rootServicePath.length + 1),\n      name: packageJson?.name || packagePath.split('/').pop(),\n      dmnoFolder: dmnoFolderExists,\n    };\n  })));\n\n  const packageFromPwd = workspacePackages.find((p) => p.path === process.env.PWD);\n  // note - this doesn't play nice if you have duplicate package names in your monorepo...\n  // this shouldnt really be an issue, but it's noteable\n  const packageManagerCurrentPackageName = process.env.npm_package_name || process.env.PNPM_PACKAGE_NAME;\n  const packageFromCurrentPackageName = workspacePackages.find((p) => p.name === packageManagerCurrentPackageName);\n\n  debug(`completed scanning in ${+new Date() - +startAt}ms`);\n\n  return {\n    isMonorepo,\n    packageManager,\n    workspacePackages: includeUnitialized ? workspacePackages : _.filter(workspacePackages, (p) => p.dmnoFolder),\n    autoSelectedPackage: packageFromPwd || packageFromCurrentPackageName,\n  };\n}\n","import fs from 'node:fs';\nimport _ from 'lodash-es';\nimport { optimize } from 'svgo';\nimport {\n  DmnoConfigItemBase, DmnoService,\n} from './config-engine';\nimport { DmnoBaseTypes } from './base-types';\n\n\nconst AUTOGENERATED_FILE_BANNER = `\n//                      \n//  THIS IS AN AUTOGENERATED FILE - DO NOT EDIT DIRECTLY \n//                      \n\n`;\n\nexport async function generateServiceTypes(service: DmnoService, writeToFile = false) {\n  if (!service.isValid) return;\n  // TODO: this could switch between different type gen methods\n  const dtsSrc = await generateTypescriptTypes(service);\n\n  if (writeToFile) {\n    const typeGenFolderPath = `${service.path}/.dmno/.typegen`;\n    await fs.promises.mkdir(typeGenFolderPath, { recursive: true });\n\n    // write schema.ts which has the config schema turned into TS in it\n    await fs.promises.writeFile(`${typeGenFolderPath}/schema.ts`, dtsSrc, 'utf-8');\n\n    // write global file which defines a DMNO_CONFIG global\n    // this used in our config.mts files and in front-end apps where we inject rollup rewrites\n    await fs.promises.writeFile(`${typeGenFolderPath}/global.d.ts`, `${AUTOGENERATED_FILE_BANNER}\nimport { DmnoGeneratedConfigSchema } from './schema';\n\ndeclare global {\n  /** ${service.serviceName} config global obj */\n  const DMNO_CONFIG: DmnoGeneratedConfigSchema;\n}\n`, 'utf-8');\n\n    // write global file which defines a DMNO_CONFIG global\n    // this used in our config.mts files and in front-end apps where we inject rollup rewrites\n    await fs.promises.writeFile(`${typeGenFolderPath}/global-public.d.ts`, `${AUTOGENERATED_FILE_BANNER}\nimport { DmnoGeneratedPublicConfigSchema } from './schema';\n\ndeclare global {\n  /** ${service.serviceName} config global obj - public (non-sensitive) items only */\n  const DMNO_PUBLIC_CONFIG: DmnoGeneratedPublicConfigSchema;\n}\n`, 'utf-8');\n  }\n}\n\nconst ICON_SIZE = 20;\n\nasync function fetchIconSvg(\n  iconifyName: string,\n  color = '808080', // neutral gray that should appear on black or white bg\n  iconCacheFolder = '/tmp/dmno-icon-cache', // TODO: maybe move icon cache to root dmno folder?\n) {\n  // some notes about icons\n  // - using a URL that points to an svg doesn't work (but png/jpg do work)\n  // - but embedding data url with an svg works fine\n  // - we are fetching them on demand and caching them\n  // - and then applying a color if one is set or falling back to a neutral gray that should show up on either black or white\n\n  fs.mkdirSync(iconCacheFolder, { recursive: true });\n\n  const iconPath = `${iconCacheFolder}/${iconifyName}-${ICON_SIZE}.svg`;\n\n  let svgSrc: string;\n  if (fs.existsSync(iconPath)) {\n    const svgFileBuffer = await fs.promises.readFile(iconPath, 'utf-8');\n    svgSrc = svgFileBuffer.toString();\n  } else {\n    const iconSvg = await fetch(`https://api.iconify.design/${iconifyName.replace(':', '/')}.svg?height=${ICON_SIZE}`);\n    svgSrc = await iconSvg.text();\n\n    // run it through svgo to try to shrink it down a little\n    const optimizedSvgResult = optimize(svgSrc, {\n      multipass: true,\n    });\n\n    await fs.promises.writeFile(iconPath, optimizedSvgResult.data, 'utf-8');\n  }\n\n  const hexColor = color.startsWith('#') ? color : `#${color}`;\n\n  const colorizedSvg = svgSrc.replaceAll('currentColor', hexColor);\n\n  return colorizedSvg;\n}\n\nexport async function generateTypescriptTypes(service: DmnoService) {\n  const tsSrc = [\n    AUTOGENERATED_FILE_BANNER,\n    'export type DmnoGeneratedConfigSchema = {',\n  ];\n  const publicKeys: Array<string> = [];\n  for (const itemKey in service.config) {\n    const configItem = service.config[itemKey];\n    if (!configItem.type.getDefItem('sensitive')) publicKeys.push(itemKey);\n    tsSrc.push(...await getTsDefinitionForItem(configItem, 1));\n  }\n  tsSrc.push('}');\n  tsSrc.push('\\n');\n\n  const publicKeysForPick = _.map(publicKeys, JSON.stringify).join(' | ');\n  tsSrc.push(`export type DmnoGeneratedPublicConfigSchema = Pick<DmnoGeneratedConfigSchema, ${publicKeysForPick || 'never'}>`);\n\n  return tsSrc.join('\\n');\n}\nexport async function getPublicConfigKeys(service: DmnoService) {\n  const nonSecretItems = _.pickBy(service.config, (item, itemKey) => {\n    return !item.type.getDefItem('sensitive');\n  });\n  return _.keys(nonSecretItems);\n}\n\n\n// const dmnoLogoSvg = encodeURIComponent('<svg height=\"12\" viewBox=\"0 0 12 12\" width=\"12\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"m10 6c0 2.20914-1.79086 4-4 4-.00098 0-.00196 0-.00294 0h-3.99706v-8h4c2.20914 0 4 1.79086 4 4z\" fill=\"#808080\"/></svg>');\n\nasync function getTsDefinitionForItem(item: DmnoConfigItemBase, indentLevel = 0) {\n  const i = _.times(indentLevel, () => '  ').join('');\n  const itemSrc = [];\n\n  // TODO - we are assuming here that the config has been fully resolved\n  // meaning if we had settings varying based on values (ex: something is required only for prod) then this wouldn't work\n  // so we'll need to add a concept of fully resolving the config and triggering that first\n  // also begs the question of what the types look like when the schema can vary like that...\n\n  // TODO: also will need to figure out how we deal with null values\n  // since we might need something like `key: string | null` rather than `key?: string`\n\n  const jsDocLines = [];\n  const itemType = item.type;\n  let iconMd = '';\n\n  const iconCachePath = `${item.parentService?.workspace.rootService.path}/.dmno/.icon-cache`;\n\n  if (itemType.getDefItem('ui')?.icon) {\n    const iconSvg = await fetchIconSvg(itemType.getDefItem('ui')?.icon!, itemType.getDefItem('ui')?.color, iconCachePath);\n\n    if (iconSvg) {\n      iconMd = `![icon](data:image/svg+xml;utf-8,${encodeURIComponent(iconSvg)}) `;\n    }\n  }\n\n\n\n  const label = itemType.getDefItem('summary') || item.key;\n\n\n  jsDocLines.push(`**${label}**${itemType.getDefItem('sensitive') ? '  _sensitive_' : ''}`);\n\n  if (itemType.getDefItem('description')) {\n    jsDocLines.push(itemType.getDefItem('description'));\n  }\n  if (itemType.getDefItem('typeDescription')) {\n    jsDocLines.push(`_${itemType.getDefItem('typeDescription')}_`);\n  }\n\n\n  if (iconMd) {\n    jsDocLines.push(iconMd);\n  }\n\n  if (itemType.getDefItem('externalDocs')) {\n    const externalDocs = itemType.getDefItem('externalDocs')!;\n    // see https://jsdoc.app/tags-see for format info\n    const docsLink = _.compact([externalDocs.url, externalDocs.description]).join(' | ');\n    jsDocLines.push(` {@link ${docsLink}}`);\n  }\n\n\n\n  // experimenting with a dmno branded stamp w/ link? probably too much, but it's fun!\n  if (jsDocLines.length > 1) {\n    // any text is turned blue\n    // jsDocLines.push('{: style=\"text-align: right\" }[](https://dmno.dev)');\n\n    // \"generated by DMNO\"\n    // jsDocLines.push('[![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGkAAAAKCAYAAAC34nDOAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAIdSURBVHgB7VbRccIwDBW9/pcNmk7QbNB0AtiAMEFhAsIEdIPQCUo3gAkIG2SEdIJWL3k+1BSSEOBa7nh3Psfyk2RLsh2RK/49OnKFRFH0tUO80DbWufRQHrmedrE2X1v3GN6N/CG4wKbcQFu/Yi6S0wK+1g3W+IvH77W2QIrAH8W7NQpdkjG51HFCma/90hjNrIxyVEHmso+gaZfQVi4np1uyFWs/1T41umVevgbaqoRdB+wbm165ghsCvlHlzwfyZrIN+tG8/CQxYFBAAh6ZIMgizr9TGeNQGzb9yjnogRsyOYBPe+AGJtDgx2YhmV2ZzoXUQRGMKJ6Q60k1nsiJ6c+uZybt4bfg9U/JuzGCFavXZRZBQhC9kvJCG3h3HAeyDbhzilO0kSKpC7WbyTbQuX0Ugnaf8GmqfEBdVyzgPmjvfFZhRd6GfuZSFEi+N2mP7hl5WROeO0nYXI/3+tQYQMCW2sYVxjJyYCOyciSHLeR4LtULS2lradbRCkz8vRSFs5D2+JDzIZEGfl2SXNawqReO5/iW4vrp1xibkOfs4ET0zOOXcozT6Rl/uFZjJhF4ox349XkCExbPQKrxSN49TymwoZ1U2gH+R3I+DGV30f7wm/+C8+5O+eBiMrEPfN0mXdAZ1IM4kNfJdnH2+SjpheznNXrlX2t3iwyj+l9wa6dzCI/fnhRvZn+f344hhsK3hRV50eBbFLgfnEvGN9JtQ/5aYWvBAAAAAElFTkSuQmCC)](https://dmno.dev)');\n    // little \"D\"\n    // jsDocLines.push(`[![](data:image/svg+xml;utf-8,${dmnoLogoSvg})](https://dmno.dev)`);\n  }\n\n\n\n  // more ideas\n  // - we have an `exampleValue` property we could include\n  // - there's also a `@example` jsdoc directive which is meant to show a code example\n  // - could add info about the original source of an item if it has been picked?\n  // - could include text about type settings / validations\n\n\n  if (jsDocLines.length === 1) {\n    itemSrc.push(`/** ${jsDocLines[0]} */`);\n  } else if (jsDocLines.length > 1) {\n    itemSrc.push(...[\n      '/**',\n      ..._.flatMap(jsDocLines, (line) => [` * ${line}`, ' *']),\n      ' */',\n    ]);\n  }\n\n  // TODO: logic should probably be within the Item class(es) and we still need to figure out how to identify these types...\n  const baseType = itemType.primitiveTypeFactory;\n  let itemTsType = 'string';\n  if (baseType === DmnoBaseTypes.string) {\n    itemTsType = 'string';\n  } else if (baseType === DmnoBaseTypes.number) {\n    itemTsType = 'number';\n  } else if (baseType === DmnoBaseTypes.boolean) {\n    itemTsType = 'boolean';\n  } else if (baseType === DmnoBaseTypes.enum) {\n    // enums have several different formats we need to handle\n    const rawEnumOptions = itemType.primitiveType.typeInstanceOptions;\n    let enumOptions = [] as Array<any>;\n    if (_.isArray(rawEnumOptions)) {\n      // extended definition case\n      // ex [{ value: 'a', description: 'about a' }, ...]\n      if (_.isObject(rawEnumOptions[0]) && 'value' in rawEnumOptions[0]) {\n        enumOptions = _.map(rawEnumOptions, (o) => o.value);\n\n      // array of values case\n      // ex: ['a', 'b', 'c']\n      } else {\n        enumOptions = rawEnumOptions;\n      }\n\n    // key/val { a: 'about a', b: 'b description' } case\n    } else if (_.isObject(rawEnumOptions)) {\n      enumOptions = _.keys(rawEnumOptions);\n    }\n\n    itemTsType = _.map(enumOptions, JSON.stringify).join(' | ');\n  } else if (baseType === DmnoBaseTypes.object) {\n    // TODO: recursive nested stuff...\n    itemTsType = '{}';\n  }\n\n\n  itemSrc.push(`readonly ${item.key}${itemType.getDefItem('required') ? '' : '?'}: ${itemTsType};`);\n  itemSrc.push('');\n  return _.map(itemSrc, (line) => `${i}${line}`);\n}\n\n\n","import kleur from 'kleur';\nimport _ from 'lodash-es';\nimport { joinAndCompact } from './formatting';\n\nexport class CliExitError extends Error {\n  constructor(\n    message: string,\n    private more?: {\n      details?: string | Array<string>,\n      suggestion?: string | Array<string>,\n      /** always triggers a full exit, even in watch mode - useful if problem is irrecoverable */\n      forceExit?: boolean,\n    },\n  ) {\n    super(message);\n  }\n\n  get forceExit() { return !!this.more?.forceExit; }\n\n  getFormattedOutput() {\n    let msg = `\\n ${kleur.red(this.message)} \\n`;\n\n    if (this.more?.details) {\n      msg += joinAndCompact(_.castArray(this.more?.details), '\\n');\n    }\n\n    if (this.more?.suggestion) {\n      msg += joinAndCompact(_.castArray(this.more?.suggestion), '\\n');\n    }\n\n    msg += '\\n';\n    return msg;\n  }\n}\n","import { Command } from 'commander';\nimport kleur from 'kleur';\nimport { CliRunCtx, getCliRunCtx } from './cli-ctx';\nimport { CliExitError } from './cli-error';\n\n\nexport const WATCHING_FILES_MESSAGE = [\n  '',\n  kleur.gray(' watching your config files for changes... (CTRL+C to exit)'),\n].join('\\n');\n\nlet isRerunInProgress = false;\nlet enqueueRerun = false;\n\n\nasync function rerunCliAction(ctx: CliRunCtx, thisCommand: Command) {\n  console.log(kleur.blue().italic('reloading due to config change'));\n\n  ctx.workspace = await ctx.configLoader.getWorkspace();\n\n  // going to try to re-execute the command's action handler\n  // probably a bad idea... but let's try it?\n  // as long as we follow similar patterns for any watch-enabled commands, we may be fine\n\n  // we track that this is a re-run, so actions and hooks can alter their behaviour if necessary\n  ctx.isWatchModeRestart = true;\n\n  // we'll re-run our lifecycle hooks, which means they must be aware of how to handle being run multiple times\n  // usually this means just skipping unless something specific is going on\n\n  // rerun pre-hooks\n  for (const preHook of (thisCommand as any)._lifeCycleHooks.preAction) {\n    // if the hook exited we stop the rest\n    await preHook(thisCommand);\n  }\n  // re-run the action handler\n  await (thisCommand as any)._actionHandler(thisCommand.processedArgs);\n\n  // rerun post-hooks\n  for (const postHook of (thisCommand as any)._lifeCycleHooks.postAction) {\n    await postHook(thisCommand.processedArgs);\n  }\n\n\n\n  // isRerunInProgress = false;\n  // if (enqueueRerun) {\n  //   enqueueRerun = false;\n  //   await rerunCliAction(ctx, thisCommand);\n  // }\n}\n\n\nexport function addWatchMode(program: Command) {\n  program\n    .option('-w,--watch', 'watch for config changes and re-run')\n    .hook('preAction', async (thisCommand, actionCommand) => {\n      const ctx = getCliRunCtx();\n      if (ctx.isWatchModeRestart) return;\n\n      ctx.watchEnabled = thisCommand.opts().watch;\n      if (!ctx.watchEnabled) return;\n\n      // enable dev-mode and attach reload handler that re-runs the command's action\n      ctx.configLoader.devMode = true;\n      ctx.configLoader.onReload = async () => {\n        try {\n          await rerunCliAction(ctx, thisCommand);\n        } catch (err) {\n          if (err instanceof CliExitError) {\n            // in watch mode, we just log but do not actually exit\n            console.error(err.getFormattedOutput());\n\n            // unless error is marked as forcing an actual exit\n            if (err.forceExit) process.exit(1);\n          } else {\n            throw err;\n          }\n        } finally {\n          // print \"watching your files...\"\n          console.log(WATCHING_FILES_MESSAGE);\n        }\n      };\n    })\n    .hook('postAction', async (thisCommand, actionCommand) => {\n      const ctx = getCliRunCtx();\n\n      // we skip this logic entirely if this is a re-run\n      if (ctx.isWatchModeRestart) return;\n\n      // if the command supports watch mode but it is not enabled, we'll exit when the action is complete\n      if (!thisCommand.opts().watch) {\n        process.exit(0);\n\n      // otherwise we let the user know we are now waiting for changes to restart\n      } else {\n        console.log(WATCHING_FILES_MESSAGE);\n      }\n    });\n}\n\n\n\n","import kleur from 'kleur';\nimport _ from 'lodash-es';\nimport { tryCatch } from '@dmno/ts-lib';\nimport { outdent } from 'outdent';\nimport boxen from 'boxen';\nimport { DmnoCommand } from '../lib/dmno-command';\n\nimport {\n  formatError, formattedValue, getItemSummary, joinAndCompact,\n} from '../lib/formatting';\nimport { addServiceSelection } from '../lib/selection-helpers';\nimport { getCliRunCtx } from '../lib/cli-ctx';\nimport { addCacheFlags } from '../lib/cache-helpers';\nimport { addWatchMode } from '../lib/watch-mode-helpers';\nimport { CliExitError } from '../lib/cli-error';\nimport { checkForConfigErrors, checkForSchemaErrors } from '../lib/check-errors-helpers';\n\nconst program = new DmnoCommand('resolve')\n  .summary('Loads config schema and resolves config values')\n  .description('Loads the resolved config for a service')\n  .option('-f,--format <format>', 'format to output resolved config (ex. json)')\n  .option('--public', 'only loads public (non-sensitive) values')\n  .option('--show-all', 'shows all items, even when config is failing')\n  .example('dmno resolve', 'Loads the resolved config for the root service')\n  .example('dmno resolve --service service1', 'Loads the resolved config for service1')\n  .example('dmno resolve --service service1 --format json', 'Loads the resolved config for service1 in JSON format');\n\naddWatchMode(program); // must be first\naddServiceSelection(program);\naddCacheFlags(program);\n\n\nprogram.action(async (opts: {\n  // these args should be handled already by the helpers\n  // service?: string,\n  // watch?: boolean,\n  // skipCache?: boolean,\n  // clearCache?: boolean,\n\n  format?: string,\n  public?: boolean,\n  showAll?: boolean,\n}, thisCommand) => {\n  const ctx = getCliRunCtx();\n\n  if (opts.format) ctx.expectingOutput = true;\n\n  if (!ctx.selectedService) return; // error message already handled\n\n  ctx.log(`\\nResolving config for service ${kleur.magenta(ctx.selectedService.serviceName)}\\n`);\n\n  const workspace = ctx.workspace!;\n  const service = ctx.selectedService;\n  checkForSchemaErrors(workspace);\n  await service.resolveConfig();\n  checkForConfigErrors(service, { showAll: opts?.showAll });\n\n  // console.log(service.config);\n  if (opts.format === 'json') {\n    let exposedConfig = service.config;\n    if (opts.public) {\n      exposedConfig = _.pickBy(exposedConfig, (c) => !c.type.getDefItem('sensitive'));\n    }\n    const valuesOnly = _.mapValues(exposedConfig, (val) => val.resolvedValue);\n\n    console.log(JSON.stringify(valuesOnly));\n  } else if (opts.format === 'json-full') {\n    // TODO: this includes sensitive info when using --public option\n    console.dir(service.toJSON(), { depth: null });\n  } else if (opts.format === 'json-injected') {\n    console.log(JSON.stringify(service.getInjectedEnvJSON()));\n  } else {\n    _.each(service.config, (item) => {\n      console.log(getItemSummary(item.toJSON()));\n    });\n  }\n});\n\nexport const ResolveCommand = program;\n","import { Command } from 'commander';\nimport _ from 'lodash-es';\nimport kleur from 'kleur';\nimport { select } from '@inquirer/prompts';\nimport { SerializedDmnoPlugin, SerializedService } from '../../config-loader/serialization-types';\nimport { fallingDmnoLoader } from './loaders';\nimport { getCliRunCtx } from './cli-ctx';\nimport { DmnoService, DmnoWorkspace } from '../../config-engine/config-engine';\nimport { DmnoPlugin } from '../../config-engine/plugins';\nimport { getMaxLength } from './string-utils';\nimport { joinAndCompact } from './formatting';\nimport { CliExitError } from './cli-error';\n\n\nfunction getServiceLabel(s: DmnoService, padNameEnd: number) {\n  return joinAndCompact([\n    `- ${s.serviceName.padEnd(padNameEnd)}`,\n    kleur.gray(s.packageName),\n    s.configLoadError && kleur.red('  schema load error'),\n  ], ' ');\n}\n\nexport function addServiceSelection(program: Command, opts?: {\n  disableAutoSelect?: boolean,\n  disableMenuSelect?: boolean,\n  allowNoSelection?: boolean\n}) {\n  return program\n    .option('-s, --service [service]', 'which service to load')\n    .hook('preAction', async (thisCommand, actionCommand) => {\n      const ctx = getCliRunCtx();\n\n      const workspace = await ctx.configLoader.getWorkspace();\n      ctx.workspace = workspace;\n\n      const namesMaxLen = getMaxLength(_.map(workspace.allServices, (s) => s.serviceName));\n\n      // // first display loading errors (which would likely cascade into schema errors)\n      // if (_.some(_.values(workspace.allServices), (s) => s.configLoadError)) {\n      //   console.log(`\\n    ${kleur.bold().underline('We were unable to load all of your config')}    \\n`);\n      //   console.log(kleur.gray('The following services are failing to load:\\n'));\n\n      //   // NOTE - we dont use a table here because word wrapping within the table\n      //   // breaks clicking/linking into your code\n\n      //   _.each(workspace.allServices, (service) => {\n      //     if (!service.configLoadError) return;\n      //     console.log(kleur.bold().red(` Service ${kleur.underline(service.serviceName)} failed to load \\n`));\n\n      //     console.log(kleur.bold(service.configLoadError.message), '\\n');\n\n      //     console.log(service.configLoadError.cleanedStack?.join('\\n'), '\\n');\n      //   });\n      //   console.log('bailing from schema load errors');\n      //   return ctx.exit();\n      // }\n\n      // handle re-selecting the same service on a restart, which could be a bit weird if the name(s) have changed\n      // but we try to just select the same one and not worry too much\n      if (ctx.isWatchModeRestart && ctx.selectedService) {\n        ctx.selectedService = ctx.workspace.getService({ serviceName: ctx.selectedService.serviceName })\n      || ctx.workspace.getService({ packageName: ctx.selectedService.packageName });\n        if (ctx.selectedService) return;\n      }\n\n\n      // handle explicit selection via the flag\n      // if the user types just -s with no arg, we'll treat that as saying they want the menu\n      const explicitMenuOptIn = thisCommand.opts().service === true;\n      if (explicitMenuOptIn) {\n        thisCommand.opts().service = undefined;\n      }\n\n      const explicitSelection = thisCommand.opts().service;\n      if (!explicitMenuOptIn && explicitSelection) {\n        ctx.selectedService = _.find(workspace.allServices, (s) => s.serviceName === explicitSelection);\n        if (ctx.selectedService) return;\n\n        throw new CliExitError(`Invalid service selection: ${kleur.bold(explicitSelection)}`, {\n          suggestion: [\n            'Maybe you meant one of:',\n            ..._.map(workspace.allServices, (s) => getServiceLabel(s, namesMaxLen)),\n          ],\n        });\n      }\n\n      // handle auto-selection based on what package manager has passed in as the current package when running scripts via the package manager\n      if (!explicitMenuOptIn && !opts?.disableAutoSelect) {\n        // filled by package manager with package name if running an package.json script\n        const packageName = process.env.npm_package_name || process.env.PNPM_PACKAGE_NAME;\n        if (packageName) {\n        // console.log('auto select package name', packageName);\n          const autoServiceFromPackageManager = _.find(workspace.allServices, (service) => {\n            return service.packageName === packageName;\n          });\n\n          // This fully selects it and moves on\n          // TODO: not totally sure, so we should see how this feels...\n          if (autoServiceFromPackageManager) {\n            ctx.selectedService = autoServiceFromPackageManager;\n            ctx.autoSelectedService = true;\n            return;\n          }\n        }\n      }\n\n      // handle picking from a menu, default selection will be based on CWD\n      // this pre-selects the menu, but does not continue automatically\n      // NOTE - `pnpm --filter=child-package exec dmno` changes the cwd correctly\n      if (explicitMenuOptIn || !opts?.disableMenuSelect) {\n        // order our services by folder depth (descending)\n        // so we can look for whiuch folder the user is in\n        const servicesOrderedByDirDepth = _.orderBy(workspace.allServices, (s) => s.path.split('/').length, ['desc']);\n\n        const cwd = process.cwd();\n        const autoServiceFromCwd = _.find(servicesOrderedByDirDepth, (service) => {\n          return cwd.includes(service.path);\n        });\n\n        const menuSelection = await select({\n          message: 'Please select a service?',\n          choices: _.map(workspace.allServices, (service) => ({\n            name: getServiceLabel(service, namesMaxLen),\n            value: service.serviceName,\n          })),\n          default: autoServiceFromCwd?.serviceName,\n        });\n\n        ctx.selectedService = _.find(workspace.allServices, (s) => s.serviceName === menuSelection);\n        ctx.autoSelectedService = false;\n        return;\n      }\n\n      if (!opts?.allowNoSelection) {\n        throw new CliExitError('You must select a service', {\n          suggestion: 'Try rerunning using -s flag',\n        });\n      }\n    });\n}\n\nfunction getPluginLabel(p: DmnoPlugin, padNameEnd: number) {\n  return [\n    `- ${p.instanceName}`.padEnd(padNameEnd),\n    kleur.gray(`${p.pluginType}`),\n    kleur.gray(`| ${p.initByService?.serviceName}`),\n  ].join(' ');\n}\n\nexport function addPluginSelection(program: Command) {\n  return program\n    .option('-p, --plugin <plugin>', 'which plugin instance to interact with')\n    .hook('preAction', async (thisCommand, actionCommand) => {\n      const ctx = getCliRunCtx();\n\n      const workspace = await ctx.configLoader.getWorkspace();\n      await workspace.resolveConfig();\n\n      const pluginsArray = _.values(workspace.plugins);\n\n      const namesMaxLen = getMaxLength(_.map(pluginsArray, (p) => p.instanceName));\n\n      const explicitSelection = thisCommand.opts().plugin;\n      if (explicitSelection) {\n        ctx.selectedPlugin = workspace.plugins[explicitSelection];\n        if (ctx.selectedPlugin) return;\n\n        throw new CliExitError(`Invalid plugin selection: ${kleur.bold(explicitSelection)}`, {\n          suggestion: [\n            'Maybe you meant one of:',\n            ..._.map(pluginsArray, (p) => getPluginLabel(p, namesMaxLen)),\n          ],\n        });\n      }\n\n      const sortedPluginsArray = _.sortBy(pluginsArray, (p) => (p.cliPath ? 0 : 1));\n      const menuSelection = await select({\n        message: 'Which plugin instance?',\n        choices: _.map(sortedPluginsArray, (plugin) => ({\n          name: getPluginLabel(plugin, namesMaxLen),\n          // description: getPluginDescription(plugin),\n          value: plugin.instanceName,\n          disabled: !plugin.cliPath && '(no cli)',\n        })),\n        // default: autoSelectService?.serviceName,\n      });\n      thisCommand.opts().plugin = menuSelection;\n      ctx.selectedPlugin = workspace.plugins[menuSelection];\n    });\n}\n","export function stringInsert(index: number, str: string, insertStr: string) {\n  if (index > 0) return str.substring(0, index) + insertStr + str.substring(index, str.length);\n  else return insertStr + str;\n}\n\n\n\nexport function getMaxLength(strings: Array<string>, extraBuffer = 4) {\n  let max = 0;\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length > max) max = strings[i].length;\n  }\n  if (max) max += extraBuffer;\n  return max;\n}\n","import { Command } from 'commander';\nimport { getCliRunCtx } from './cli-ctx';\nimport { CliExitError } from './cli-error';\n\nexport function addCacheFlags(program: Command) {\n  return program\n    .option('--skip-cache', 'skips config cache altogether, will not read or write')\n    .option('--clear-cache', 'clears the cache before continuing, will write new values to cache')\n    .hook('preAction', async (thisCommand, actionCommand) => {\n      if (thisCommand.opts().skipCache && thisCommand.opts().clearCache) {\n        throw new CliExitError('Invalid cli flag combo', {\n          details: 'Cannot use --skip-cache + --clear-cache at the same time',\n          forceExit: true,\n        });\n      }\n      const ctx = getCliRunCtx();\n      ctx.configLoader.setCacheMode(\n        (thisCommand.opts().skipCache && 'skip')\n        || (thisCommand.opts().clearCache && 'clear')\n        || true,\n      );\n    });\n}\n","import kleur from 'kleur';\nimport _ from 'lodash-es';\nimport { DmnoService, DmnoWorkspace } from '../../config-engine/config-engine';\nimport { CliExitError } from './cli-error';\nimport {\n  formatError, formattedValue, getItemSummary, joinAndCompact,\n} from './formatting';\n\nexport function checkForSchemaErrors(workspace: DmnoWorkspace) {\n  // first display loading errors (which would likely cascade into schema errors)\n  if (_.some(_.values(workspace.allServices), (s) => s.configLoadError)) {\n    console.log(`\\n    ${kleur.bold().underline('We were unable to load all of your config')}    \\n`);\n    console.log(kleur.gray('The following services are failing to load:\\n'));\n\n    // NOTE - we dont use a table here because word wrapping within the table\n    // breaks clicking/linking into your code\n\n    _.each(workspace.allServices, (service) => {\n      if (!service.configLoadError) return;\n      console.log(kleur.bold().red(` Service ${kleur.underline(service.serviceName)} failed to load \\n`));\n\n      console.log(kleur.bold(service.configLoadError.message), '\\n');\n\n      console.log(service.configLoadError.cleanedStack?.join('\\n'), '\\n');\n    });\n    throw new CliExitError('Unable to load all config files');\n  }\n\n  // now show plugin errors - which would also likely cause further errors\n  if (_.some(_.values(workspace.plugins), (p) => !p.isValid)) {\n    console.log(`\\n    ${kleur.bold().underline('Your plugins were unable to initialize correctly')}    \\n`);\n\n    _.each(workspace.plugins, (plugin) => {\n      _.each(plugin.inputItems, (item) => {\n        if (item.isValid) return;\n\n        console.log(kleur.red('Failing plugin input ------------------'));\n\n        console.log([\n          `${plugin.initByService?.serviceName || ''} ${kleur.gray('(service)')}`,\n          `${kleur.gray('')}${plugin.instanceName} ${kleur.gray('(plugin instance)')}`,\n          ` ${kleur.gray('')}${item.key} ${kleur.gray('(input key)')}`,\n        ].join('\\n'));\n\n        console.log(`\\n${kleur.underline('Input value')}: ${formattedValue(item.resolvedValue, false)}`);\n\n        const errors = _.compact([\n          item.coercionError,\n          ...item.validationErrors || [],\n          item.schemaError,\n        ]);\n        console.log(`\\n${kleur.underline('Error(s)')}:`);\n        console.log(errors?.map((err) => `- ${err.message}`).join('\\n'));\n      });\n    });\n\n    throw new CliExitError('Plugin initialization errors');\n  }\n\n  // now show schema errors\n  if (_.some(_.values(workspace.allServices), (s) => s.schemaErrors?.length)) {\n    console.log(`\\n    ${kleur.bold().underline('Your config schema is invalid')}    \\n`);\n    console.log(kleur.gray('The following services have issues:\\n'));\n\n    _.each(workspace.allServices, (service) => {\n      if (!service.schemaErrors?.length) return;\n\n      console.log(service.serviceName);\n      console.log(_.map(service.schemaErrors, formatError).join('\\n'));\n    });\n    // console.log(errorsTable.toString());\n    throw new CliExitError('Config schema errors');\n  }\n}\n\nexport function checkForConfigErrors(service: DmnoService, opts?: {\n  showAll?: boolean\n}) {\n  const failingItems = _.filter(service.config, (item) => !item.isValid);\n\n  // TODO: make isValid flag on service to work\n  if (failingItems.length > 0) {\n    console.log(`\\n    ${kleur.bold().underline(`Configuration of service \"${kleur.magenta(service.serviceName)}\" is currently invalid `)}    \\n`);\n    console.log('Invalid items:\\n');\n\n    _.each(failingItems, (item) => {\n      console.log(getItemSummary(item.toJSON()));\n      console.log();\n    });\n    if (opts?.showAll) {\n      console.log();\n      console.log(joinAndCompact([\n        'Valid items:',\n        kleur.italic().gray('(remove `--show-all` flag to hide)'),\n      ]));\n      console.log();\n      const validItems = _.filter(service.config, (i) => !!i.isValid);\n      _.each(validItems, (item) => {\n        console.log(getItemSummary(item.toJSON()));\n      });\n    }\n\n    throw new CliExitError('Schema is invalid');\n  }\n}\n","import kleur from 'kleur';\nimport _ from 'lodash-es';\nimport { ExecaChildProcess, execa } from 'execa';\nimport which from 'which';\n\nimport { tryCatch } from '@dmno/ts-lib';\nimport { DmnoCommand } from '../lib/dmno-command';\nimport { formatError, formattedValue, getItemSummary } from '../lib/formatting';\nimport { addServiceSelection } from '../lib/selection-helpers';\nimport { getCliRunCtx } from '../lib/cli-ctx';\nimport { addCacheFlags } from '../lib/cache-helpers';\nimport { addWatchMode } from '../lib/watch-mode-helpers';\nimport { checkForConfigErrors, checkForSchemaErrors } from '../lib/check-errors-helpers';\n\n\nconst program = new DmnoCommand('run')\n  .summary('Injects loaded config into an external command')\n  .description('Runs a command with the resolved config for a service')\n  .usage('[options] -- [command to pass config to]')\n  .argument('external command')\n  .example('dmno run --service service1 -- printenv $SOME_ITEM', 'Runs the echo command with the resolved config for service1')\n  .example('dmno run -service service1 -- somecommand --some-option=(printenv SOME_VAR)', 'Runs the somecommand with the resolved config using SOME_VAR via printenv');\n\naddWatchMode(program);\naddServiceSelection(program);\naddCacheFlags(program);\n\n\nlet commandProcess: ExecaChildProcess | undefined;\nlet childCommandKilledFromRestart = false;\n\nprogram.action(async (_command, opts: {\n  service: string,\n}, more) => {\n  const commandToRunAsArgs = more.args;\n  const commandToRunStr = more.args.join(' ');\n  const rawCommand = more.args[0];\n  const commandArgsOnly = more.args.slice(1);\n\n  const pathAwareCommand = which.sync(rawCommand, { nothrow: true });\n  // if (pathAwareCommand) {\n  //   logger.debug(`expanded [${rawCommand}] to [${pathAwareCommand}]`);\n  // } else {\n  //   logger.debug(`could not expand command [${rawCommand}]`);\n  // }\n\n  const ctx = getCliRunCtx();\n\n  // if subcommand is still running, we'll kill it\n  // this could be a re-run via watch mode\n  if (commandProcess && commandProcess.exitCode === null) {\n    childCommandKilledFromRestart = true;\n    commandProcess.kill(2);\n  }\n\n  if (!ctx.selectedService) return;\n\n  // TODO: not quite right\n  const workspace = ctx.workspace!;\n  const service = ctx.selectedService;\n  checkForSchemaErrors(workspace);\n  await service.resolveConfig();\n  checkForConfigErrors(service);\n\n  const serviceEnv = service.getEnv();\n\n  commandProcess = execa(pathAwareCommand || rawCommand, commandArgsOnly, {\n    stdio: 'inherit',\n    env: {\n      ...process.env,\n      ...serviceEnv,\n      DMNO_INJECTED_ENV: JSON.stringify(service.getInjectedEnvJSON()),\n    },\n  });\n  // console.log('PARENT PID = ', process.pid);\n  // console.log('CHILD PID = ', commandProcess.pid);\n\n  let exitCode: number;\n  try {\n    const commandResult = await commandProcess;\n    // console.log(commandResult);\n    exitCode = commandResult.exitCode;\n  } catch (error) {\n    // console.log('child command error!', error);\n    if ((error as any).signal === 'SIGINT' && childCommandKilledFromRestart) {\n      // console.log('child command failed due to being killed form restart');\n      childCommandKilledFromRestart = false;\n      return;\n    }\n\n    // console.log('child command result error', error);\n    if ((error as any).signal === 'SIGINT' || (error as any).signal === 'SIGKILL') {\n      process.exit(1);\n    } else {\n      console.log((error as Error).message);\n      console.log(`command [${commandToRunStr}] failed`);\n      console.log('try running the same command without dmno');\n      console.log('if you get a different result, dmno may be the problem...');\n      // console.log(`Please report issue here: <${REPORT_ISSUE_LINK}>`);\n    }\n    exitCode = (error as any).exitCode || 1;\n  }\n\n  if (ctx.watchEnabled) {\n    if (!childCommandKilledFromRestart) {\n      if (exitCode === 0) {\n        console.log('\\n command completed successfully');\n      } else {\n        console.log(`\\n command failed - exit code = ${exitCode}`);\n      }\n    }\n  }\n\n  // if first run, we need to attach some extra exit handling\n  if (!ctx.isWatchModeRestart) {\n    // try to make sure we shut down cleanly and kill the child process\n    process.on('exit', (code: any, signal: any) => {\n      // if (childCommandKilledFromRestart) {\n      //   childCommandKilledFromRestart = false;\n      //   return;\n      // }\n      // console.log('exit!', code, signal);\n      commandProcess?.kill(9);\n    });\n\n\n    ['SIGTERM', 'SIGINT'].forEach((signal) => {\n      process.on(signal, () => {\n        // console.log('SIGNAL = ', signal);\n        commandProcess?.kill(9);\n        process.exit(1);\n      });\n    });\n    // TODO: handle other signals?\n  }\n});\n\nexport const RunCommand = program;\n","import kleur from 'kleur';\nimport _ from 'lodash-es';\nimport { outdent } from 'outdent';\nimport gradient from 'gradient-string';\nimport { DmnoCommand } from '../lib/dmno-command';\nimport { formatError, formattedValue, getItemSummary } from '../lib/formatting';\nimport { getCliRunCtx } from '../lib/cli-ctx';\nimport { ConfigServer } from '../../config-loader/config-server';\nimport { addCacheFlags } from '../lib/cache-helpers';\nimport { addServiceSelection } from '../lib/selection-helpers';\nimport { DMNO_DEV_BANNER, fallingDmnoLoader, fallingDmnosAnimation } from '../lib/loaders';\n\nconst TERMINAL_COLS = Math.floor(process.stdout.columns * 0.75);\n\nconst program = new DmnoCommand('dev')\n  .summary('dev / watch mode')\n  .description(`\nRuns the service in dev mode, and watches for changes and updates as needed.\n  `)\n  .option('--silent', 'do not log anything, useful when using in conjunction with a ConfigServerClient which will do its own logging')\n  .example('dmno dev', 'Runs the service in dev mode');\n\naddServiceSelection(program, { allowNoSelection: true });\n// TODO: need to clarify behaviour around \"clear-cache\" and if that clears once or on every load\naddCacheFlags(program);\n\nprogram.action(async (opts: {\n  silent?: boolean,\n  service?: string,\n}, more) => {\n  const ctx = getCliRunCtx();\n\n  const configServer = new ConfigServer(ctx.configLoader);\n  ctx.configLoader.devMode = true;\n\n  if (!opts.silent) {\n    console.log(DMNO_DEV_BANNER);\n    await fallingDmnosAnimation();\n  }\n\n  let firstLoad = true;\n  async function logResult() {\n    if (opts.silent) return;\n\n    if (!firstLoad) {\n      console.log(gradient('cyan', 'pink')(`\\n Config reloaded ${''.repeat(TERMINAL_COLS - 20)}`));\n    }\n    firstLoad = false;\n    console.log('');\n    const workspace = await ctx.configLoader.getWorkspace();\n    if (opts.service) {\n      const service = workspace.getService(opts.service);\n\n      _.each(service.config, (item) => {\n        console.log(getItemSummary(item.toJSON()));\n      });\n    } else {\n      console.log('config loaded!');\n    }\n\n    console.log(\n      kleur.gray('\\n watching your config files for changes... hit CTRL+C to exit'),\n    );\n  }\n\n  // calling reload will regenerate types and resolve the config\n  // TODO: we may want to chagne how the initial load in dev mode works so we dont need to reload here...\n  await ctx.configLoader.reload();\n\n  await logResult();\n\n  configServer.onReload = () => logResult();\n\n\n\n  // console.log(ctx.configLoader.uuid);\n});\n\nexport const DevCommand = program;\n","import ipc from 'node-ipc';\nimport mitt, { Handler } from 'mitt';\nimport Debug from 'debug';\nimport { DeferredPromise, createDeferredPromise } from '@dmno/ts-lib';\n\nimport kleur from 'kleur';\nimport { ConfigLoader } from './config-loader';\nimport { createDebugTimer } from '../cli/lib/debug-timer';\nimport { ConfigLoaderRequestMap } from './ipc-requests';\n\n\nconst debug = Debug('dmno');\nconst debugTimer = createDebugTimer('dmno:config-server');\n\nexport class ConfigServer {\n  readonly uuid = process.env.DMNO_CONFIG_SERVER_UUID || crypto.randomUUID();\n\n  constructor(private configLoader: ConfigLoader) {\n    this.registerRequestHandlers();\n    this.initIpcServer();\n    this.configLoader.onReload = this.onConfigReload.bind(this);\n  }\n\n  get workspace() { return this.configLoader.dmnoWorkspace!; }\n\n\n  private requestHandlers = {} as Record<keyof ConfigLoaderRequestMap, any>;\n  private registerRequestHandler<K extends keyof ConfigLoaderRequestMap>(\n    requestType: K,\n    handler: (payload: ConfigLoaderRequestMap[K]['payload']) => Promise<ConfigLoaderRequestMap[K]['response']>,\n  ) {\n  // console.log(`registered handler for requestType: ${requestType}`);\n    if (this.requestHandlers[requestType]) {\n      throw new Error(`Duplicate IPC request handler detected for requestType \"${requestType}\"`);\n    }\n    this.requestHandlers[requestType] = handler;\n  }\n\n\n  // eslint-disable-next-line class-methods-use-this\n  shutdown() {\n    ipc.disconnect('dmno');\n  }\n\n  private ipcReadyDeferred = createDeferredPromise();\n  private get ipcReady() { return this.ipcReadyDeferred.promise; }\n  private initIpcServer() {\n    // NOTE - we may want to initialize an ipc instance rather than using the global setup\n    // but the TS types (from DefinitelyTyped) aren't working well for that :(\n    ipc.config.id = 'dmno';\n    ipc.config.retry = 1500;\n    ipc.config.silent = true;\n\n    // currently this defaults to using a socket at `/tmp/app.dmno`\n    // we could put the socket in the root .dmno folder?\n    // or at least name it differently?\n    ipc.serve(`/tmp/${this.uuid}.dmno.sock`); // this has a callback... we aren't waiting here\n\n    ipc.server.on('start', () => {\n      debugTimer('IPC server started');\n    });\n\n    ipc.server.on('connect', (msg) => {\n      debugTimer('ipc server connect event');\n    });\n\n    ipc.server.on('error', (err) => {\n      debug('IPC error: ', err);\n    });\n\n    ipc.server.on('socket.disconnected', (socket, destroyedSocketID) => {\n      ipc.log(`client ${destroyedSocketID} has disconnected!`);\n    });\n\n    ipc.server.on('request', async (message, socket) => {\n      debug('received request from IPC client', message);\n      const handler = (this.requestHandlers as any)[message.requestType];\n      if (!handler) {\n        throw new Error(`No handler for request type: ${message.requestType}`);\n      }\n\n      // we may receive a request before the config loader is ready\n      await this.configLoader.isReady;\n      await this.ipcReady; // probably not necessary\n      const result = await handler(message.payload);\n      ipc.server.emit(socket, 'request-response', {\n        requestId: message.requestId,\n        response: result,\n      });\n    });\n\n    // ipc.server.on('event', (eventMessage) => {\n    //   console.log('ipc server received event', eventMessage);\n    //   return this.eventBus.emit(eventMessage.eventType, eventMessage.payload);\n    // });\n\n    ipc.server.on('ready', (response) => {\n      debugTimer('IPC server received ready signal');\n      this.ipcReadyDeferred.resolve();\n      // this.readyAt = new Date();\n\n      // debug(kleur.yellow(`took ${+this.readyAt - +this.startAt} ms to boot`));\n    });\n\n    debugTimer('ipc server start!');\n    ipc.server.start();\n\n\n    // process.on('SIGKILL', () => {\n    //   console.log('CONFIG SERVER - SIGKILL');\n    // });\n    process.on('SIGTERM', () => {\n      // console.log('CONFIG SERVER PROCESS - SIGTERM');\n    });\n    process.on('SIGINT', () => {\n      // console.log('CONFIG SERVER PROCESS - SIGINT');\n    });\n    process.on('exit', (code) => {\n      ipc.server.stop();\n      // console.log('CONFIG SERVER PROCESS - EXIT');\n    });\n  }\n\n  eventBus = mitt();\n  onEvent(eventType: string, handler: Handler) {\n    // console.log('loader process subscribe to event', eventType, handler);\n    this.eventBus.on(eventType, handler);\n  }\n\n\n\n  // eslint-disable-next-line class-methods-use-this\n  private broadcastIpcEvent(type: string, payload: any) {\n    ipc.server.broadcast('event', { type, payload });\n  }\n\n  onReload?: () => void;\n  private onConfigReload() {\n    this.broadcastIpcEvent('reload', {});\n    if (this.onReload) this.onReload();\n  }\n\n\n  // request handlers //////////////////////////////////////////\n\n  registerRequestHandlers() {\n    this.registerRequestHandler('load-full-schema', async (payload) => {\n      await this.workspace.resolveConfig();\n      return this.workspace.toJSON();\n    });\n\n    this.registerRequestHandler('get-resolved-config', async (payload) => {\n      // if selecting by package name, we'll first make sure the package is valid and initialized\n      // this may need to move somewher else / happen earlier when setting up `dmno dev`?\n      if (payload.packageName) {\n        const packageManager = this.configLoader.workspaceInfo.packageManager;\n        const selectedPackageInfo = this.configLoader.workspacePackagesData.find((p) => p.name === payload.packageName);\n        if (selectedPackageInfo) {\n          if (!selectedPackageInfo.dmnoFolder) {\n            console.log(`\\n Package ${selectedPackageInfo.name} has not yet been initialized as a DMNO service`);\n            console.log();\n            // TODO we'll want a helper to get commands for the current package manager (pnpm exec dmno)\n            // could also detect current directory and skip the cd\n            console.log('Please run the following command to get it set up:');\n            console.log(kleur.cyan(` cd ${selectedPackageInfo.path} && ${packageManager} exec dmno init`));\n            console.log();\n            process.exit(1);\n          }\n        } else {\n          throw new Error(`Package ${payload.packageName} does not exist in your workspace`);\n        }\n      }\n\n\n      await this.workspace.resolveConfig();\n      const service = this.workspace.getService(payload);\n      if (!service) {\n        throw new Error(`Unable to select service - ${payload.serviceName || payload.packageName}`);\n      }\n\n      return service.toJSON();\n    });\n\n\n    // registerRequestHandler('generate-types', async (payload) => {\n    //   if (!schemaLoaded) await reloadAllConfig();\n    //   const service = dmnoWorkspace.getService(payload);\n    //   if (!service) throw new Error('Unable to select a service');\n\n    //   return { tsSrc: await generateTypescriptTypes(service) };\n    // });\n  }\n}\n\n\n\n\n\n","import _ from 'lodash-es';\nimport kleur from 'kleur';\nimport gradient from 'gradient-string';\nimport { createDeferredPromise } from '@dmno/ts-lib';\nimport { outdent } from 'outdent';\nimport logUpdate from 'log-update';\n\n\nconst TERMINAL_COLS = Math.floor(process.stdout.columns * 0.9);\nconst LOADER_WIDTH = Math.min(TERMINAL_COLS, 100);\n\nconst gradientColorizer = gradient('cyan', 'pink');\n\nexport async function fallingDmnoLoader(\n  loadingText: string = '',\n  loadedText: string = '',\n  totalTime = 1500,\n) {\n  if (loadingText) loadingText += ' ';\n  if (loadedText) loadedText += ' ';\n\n  const frameDelay = Math.floor(totalTime / LOADER_WIDTH / 2);\n\n  // console.log(kleur.green('Loading DMNO schema'));\n\n  const deferred = createDeferredPromise();\n\n  let currentCol = 0;\n  let isFalling = false;\n  const interval = setInterval(() => {\n    currentCol++;\n\n    // \n\n    let str = '';\n    if (!isFalling) {\n      for (let i = 0; i < currentCol; i++) {\n        if (i < loadingText.length) {\n          str += loadingText.slice(i, i + 1);\n        } else {\n          str += ''; // \n        }\n      }\n    } else {\n      for (let i = 0; i <= LOADER_WIDTH; i++) {\n        if (i < loadingText.length) {\n          str += loadingText.slice(i, i + 1);\n        } else if (i <= currentCol - 2) str += '';\n        else if (i <= currentCol - 1) str += '';\n        else if (i <= currentCol) str += '';\n        else str += ''; // \n      }\n    }\n    logUpdate(kleur.bold().green(str));\n\n    if (currentCol > LOADER_WIDTH) {\n      if (!isFalling) {\n        currentCol = 0;\n        isFalling = true;\n      } else {\n        clearInterval(interval);\n        setTimeout(() => {\n          let str = '';\n          for (let i = 0; i <= LOADER_WIDTH; i++) {\n            if (i < loadedText.length) {\n              str += loadedText.slice(i, i + 1);\n            } else {\n              str += '';\n            }\n          }\n\n          logUpdate(kleur.bold().green(str));\n          console.log('\\n');\n          deferred.resolve();\n        }, Math.floor(totalTime * 0.1));\n      }\n    }\n  }, frameDelay);\n\n  return deferred.promise;\n}\n\n\nexport async function fallingDmnosAnimation(\n  loadingText: string = '',\n  loadedText: string = '',\n  totalTime = 1500,\n) {\n  if (loadingText) loadingText += ' ';\n  if (loadedText) loadedText += ' ';\n\n  const frameDelay = Math.floor(totalTime / LOADER_WIDTH / 2);\n\n  const deferred = createDeferredPromise();\n\n  let currentCol = 0;\n  let isFalling = false;\n  const interval = setInterval(() => {\n    currentCol++;\n\n    let str = '';\n    if (!isFalling) {\n      for (let i = 0; i < currentCol; i++) {\n        if (i === 0) str += '';\n        else str += '';\n      }\n    } else {\n      for (let i = 0; i < LOADER_WIDTH; i++) {\n        if (i === 0) str += '';\n        // else if (i < loadingText.length) {\n        //   str += loadingText.slice(i, i + 1);\n        else if (i < currentCol) str += '';\n        else if (i === currentCol) str += '';\n        else str += '';\n      }\n    }\n    logUpdate(gradientColorizer(str + ' '.repeat(LOADER_WIDTH + 1 - str.length)));\n\n    if (currentCol === LOADER_WIDTH) {\n      if (!isFalling) {\n        currentCol = 0;\n        isFalling = true;\n      } else {\n        clearInterval(interval);\n        setTimeout(() => {\n          let str = loadedText;\n          str += ''.repeat(LOADER_WIDTH + 1 - str.length);\n\n          logUpdate(gradientColorizer(str));\n          console.log('\\n');\n          deferred.resolve();\n        }, Math.floor(totalTime * 0.1));\n      }\n    }\n  }, frameDelay);\n\n  return deferred.promise;\n}\n\n\nexport const DMNO_DEV_BANNER2 = gradient('#00FF0A', '#00C2FF').multiline(outdent`\n   \n    \n    \n  \n`);\nexport const DMNO_DEV_BANNER = gradient('#00FF0A', '#00C2FF').multiline(outdent`\n     \n             \n             \n    \n`);\n\n// let DOMINO_W_D = gradient('#00FF0A', '#00C2FF').multiline(outdent`\n//   \n//        \n//        \n//   \n// `);\nconst EMPTY_DOMINO = outdent`\n  \n            \n            \n  \n`;\nconst DMNO_W_D_WHITE = outdent`\n  \n        \n        \n  \n`;\n\nconst EMPTY_DOMINO_LINES = gradient('#00FF0A', '#00C2FF').multiline(EMPTY_DOMINO).split('\\n');\nconst dominoWithDArray = structuredClone(EMPTY_DOMINO_LINES);\ndominoWithDArray[1] = spliceString(dominoWithDArray[1], 193, 50, kleur.white(''));\ndominoWithDArray[2] = spliceString(dominoWithDArray[2], 193, 50, kleur.white(''));\ndominoWithDArray[1] = spliceString(dominoWithDArray[1], 55, 50, kleur.white('  '));\ndominoWithDArray[2] = spliceString(dominoWithDArray[2], 55, 50, kleur.white('  '));\n\n\n\n// splicing with ansi codes is very finnicky... will need better tooling, but this helps a bit\n// for (let i = 0; i < EMPTY_DOMINO_LINES[1].length; i++) {\n//   const dominoWithDArray = structuredClone(EMPTY_DOMINO_LINES);\n//   // dominoWithDArray[1] = spliceString(dominoWithDArray[1], i, 50, kleur.white(''));\n//   // dominoWithDArray[2] = spliceString(dominoWithDArray[2], i, 50, kleur.white(''));\n//   dominoWithDArray[1] = spliceString(dominoWithDArray[1], i, 50, kleur.white(' '));\n//   dominoWithDArray[2] = spliceString(dominoWithDArray[2], i, 50, kleur.white(' '));\n//   console.log(i);\n//   console.log(dominoWithDArray.join('\\n'));\n// }\n\n\n// dominoWithDArray[1] = spliceString(dominoWithDArray[1], 172, 3, kleur.white(''));\n// dominoWithDArray[2] = spliceString(dominoWithDArray[2], 172, 3, kleur.white(''));\nexport const DOMINO_WITH_D = dominoWithDArray.join('\\n');\n\nexport default function spliceString(string: string, index: number, count: number, insert: string) {\n  const array = _.toArray(string);\n  array.splice(index, count, insert);\n  return array.join('');\n}\n\nexport function getDmnoMascot(message: string = '') {\n  return `\n    \n                     ${message ? '' : ''}${message}\n              \n                 \n    \n                     `;\n}\n\n","import { execSync, fork } from 'child_process';\nimport { inherits } from 'util';\nimport kleur from 'kleur';\nimport _ from 'lodash-es';\nimport { select } from '@inquirer/prompts';\nimport { ExecaChildProcess, execa } from 'execa';\nimport which from 'which';\nimport Debug from 'debug';\nimport { tryCatch } from '@dmno/ts-lib';\nimport { DmnoCommand } from '../lib/dmno-command';\nimport { formatError, formattedValue } from '../lib/formatting';\nimport { fallingDmnoLoader } from '../lib/loaders';\nimport { getCliRunCtx } from '../lib/cli-ctx';\nimport { addServiceSelection, addPluginSelection } from '../lib/selection-helpers';\nimport { SerializedDmnoPlugin } from '../../config-loader/serialization-types';\nimport { CliExitError } from '../lib/cli-error';\n\nconst debug = Debug('dmno:plugin-cli');\n\nconst program = new DmnoCommand('plugin')\n  .summary('Interacts with dmno plugins')\n  .description('Runs CLI commands related to a specific plugin instance')\n  .example('dmno plugin -p my-plugin', 'Runs the CLI for the my-plugin plugin')\n  .example('dmno plugin -p my-plugin -s my-service', 'Runs the CLI for the my-plugin plugin with the my-service service');\n\naddServiceSelection(program, { });\naddPluginSelection(program);\n\nlet isTerminating = false;\nprogram.action(async (opts: {\n  plugin: string,\n  service?: string,\n}, more) => {\n  const ctx = getCliRunCtx();\n  if (!ctx.selectedPlugin) {\n    throw new CliExitError('No plugin instance selected');\n  }\n\n  let cliPath = ctx.selectedPlugin.cliPath;\n\n  if (!cliPath) throw new Error('no cli for this plugin!');\n  if (!cliPath.endsWith('.mjs')) cliPath += '.mjs';\n\n  // console.log(more.args);\n\n  const pluginCliProcess = fork(cliPath, more.args, { stdio: 'inherit' });\n  debug('PARENT PROCESS = ', process.pid);\n  debug('CHILD PROCESS = ', pluginCliProcess.pid);\n\n  // make sure we kill the child if the parent is about to die\n  process.on('exit', (code) => {\n    debug(`About to exit with code: ${code}`);\n    pluginCliProcess.kill(9);\n  });\n  // TODO: handle other signals?\n  process.on('SIGTERM', () => {\n    isTerminating = true;\n    pluginCliProcess.kill(9);\n    process.exit(1);\n  });\n\n  // pluginCliProcess.on('message', (childPluginMessage) => {\n  //   console.log('child cli message', childPluginMessage);\n  // });\n\n  pluginCliProcess.on('close', (code, signal) => {\n    if (!isTerminating) process.exit(code || 1);\n  });\n\n  pluginCliProcess.on('disconnect', () => {\n    debug('child cli disconnect');\n    // process.exit(1);\n  });\n\n  pluginCliProcess.on('error', (err) => {\n    debug('child cli process error', err);\n    // process.exit(0);\n  });\n\n  pluginCliProcess.on('exit', (code, signal) => {\n    debug('child cli process exit', code, signal);\n    if (!isTerminating) process.exit(code || 1);\n  });\n\n  // pluginCliProcess.on('spawn', () => {\n  //   console.log('child cli process spawn');\n  // });\n\n\n  // reload the workspace and resolve values\n  const workspace = await tryCatch(async () => {\n    return await ctx.configLoader.getWorkspace();\n  }, (err) => {\n    console.log(kleur.red().bold('Loading config failed'));\n    console.log(err.message);\n    process.exit(1);\n  });\n\n  await workspace.resolveConfig();\n  const resolvedPlugin = workspace.plugins[opts.plugin!];\n\n  pluginCliProcess.send(['init', {\n    workspace: workspace.toJSON(),\n    plugin: resolvedPlugin.toJSON(),\n    selectedServiceName: opts.service,\n  }]);\n});\n\nexport const PluginCommand = program;\n","import { execSync } from 'node:child_process';\nimport fs from 'node:fs';\nimport kleur from 'kleur';\nimport _ from 'lodash-es';\nimport boxen from 'boxen';\nimport outdent from 'outdent';\nimport {\n  select, input, checkbox, confirm,\n} from '@inquirer/prompts';\n\nimport { tryCatch } from '@dmno/ts-lib';\n\nimport gradient from 'gradient-string';\nimport { PackageManager, findDmnoServices, pathExists } from '../../config-loader/find-services';\nimport { DmnoCommand } from '../lib/dmno-command';\n\nimport { formatError, formattedValue, joinAndCompact } from '../lib/formatting';\nimport { getCliRunCtx } from '../lib/cli-ctx';\nimport {\n  DMNO_DEV_BANNER, fallingDmnoLoader, fallingDmnosAnimation,\n  getDmnoMascot,\n} from '../lib/loaders';\nimport { initDmnoForService } from '../lib/init-helpers';\nimport { DISCORD_INVITE_URL, GITHUB_REPO_URL } from '../../lib/constants';\nimport { CliExitError } from '../lib/cli-error';\n\nconst program = new DmnoCommand('init')\n  .summary('Sets up dmno')\n  .description('Sets up dmno in your repo, and can help add to new packages within your monorepo - safe to run multiple times')\n  .option('--silent', 'automatically select defaults and do not prompt for any input')\n  .example('dmno init', 'Set up dmno and uses interactive menus to make selections');\n\nprogram.action(async (opts: {\n  silent?: boolean,\n}, thisCommand) => {\n  console.log(DMNO_DEV_BANNER);\n  // console.log(kleur.gray('let us help you connect the dots   '));\n\n  const [workspaceInfo] = await Promise.all([\n    findDmnoServices(true),\n    fallingDmnosAnimation(),\n  ]);\n\n\n  // await fallingDmnoLoader(' Scanning repo', ' Scan complete');\n\n  const rootPath = workspaceInfo.workspacePackages[0].path;\n\n  console.log();\n  console.log(kleur.gray(`- Package manager: ${workspaceInfo.packageManager}`));\n  console.log(kleur.gray(`- Workspace root path: ${rootPath}`));\n  console.log(kleur.gray(`- Monorepo mode: ${workspaceInfo.isMonorepo ? 'ENABLED' : 'DISABLED'}`));\n  if (workspaceInfo.isMonorepo) {\n    console.log(kleur.gray(`- Total Packages Count: ${workspaceInfo.workspacePackages.length}`));\n  }\n  console.log();\n\n  // console.log(boxen(`Welcome to ${kleur.magenta('DMNO!')}`, { padding: 1, borderStyle: 'round', borderColor: 'greenBright' }));\n  // console.log(kleur.italic().green(\"We're here to help you connect the dots    \"));\n  // console.log('');\n\n  const rootPackage = workspaceInfo.workspacePackages[0];\n\n  if (!workspaceInfo.autoSelectedPackage) {\n    throw new Error('unable to detect which package you are in... whats happening?');\n  }\n  const rootDmnoFolderExists = await pathExists(`${rootPackage.path}/.dmno`);\n  // we may change this logic later?\n  const showOnboarding = (workspaceInfo.autoSelectedPackage.isRoot && !rootDmnoFolderExists) && !opts.silent;\n\n  // if in a specific service, we'll just init that service\n  if (!workspaceInfo.autoSelectedPackage.isRoot) {\n    // ensure dmno has already been set up at the root\n    // TODO: we could do some other checks for this too\n    if (!rootDmnoFolderExists) {\n      throw new CliExitError('Workspace root .dmno folder does not exist yet', {\n        suggestion: 'Please first run `dmno init` in the root of your monorepo',\n      });\n    }\n    // initialize dmno in this service only\n    await initDmnoForService(workspaceInfo, workspaceInfo.autoSelectedPackage.path);\n\n  // if running at the root, we'll init the root and then let the user choose which service(s)\n  } else {\n    // First run in the root! show some special onboarding stuff...\n\n    if (showOnboarding) {\n      console.log(' Hello and welcome to dmno!');\n    }\n\n    // first initialize in root\n    await initDmnoForService(workspaceInfo, rootPackage.path, opts.silent);\n\n    if (workspaceInfo.isMonorepo && !opts.silent) {\n      if (workspaceInfo.workspacePackages.length === 1) {\n        console.log('No packages found in your monorepo.');\n        console.log('After you create them, you can rerun this command `dmno init`');\n      } else {\n      // then let user select service(s) to init\n        console.log();\n        const installPackagePaths = await checkbox({\n          message: 'Which service(s) would you like to initialize as dmno services?\\n',\n          choices: workspaceInfo.workspacePackages.slice(1).map((packageInfo) => {\n            return {\n              value: packageInfo.path,\n              name: `${packageInfo.name} - ${kleur.italic().gray(packageInfo.relativePath)}`,\n            };\n          }),\n        });\n        for (const packagePath of installPackagePaths) {\n          await initDmnoForService(workspaceInfo, packagePath);\n        }\n      }\n    }\n  }\n\n  if (showOnboarding) {\n    console.log(getDmnoMascot(kleur.bold().yellow('Thank you SO much!')));\n\n    console.log(`\\nThis software is ${kleur.green('free')}, and we hope you ${kleur.italic().bold().red('LOVE')} it \\n`);\n\n    console.log(joinAndCompact([\n      ' If you have a sec, please star us on github',\n      kleur.gray('    ') + kleur.cyan(GITHUB_REPO_URL),\n      ' ',\n      ' And chat with us on discord!',\n      kleur.gray('    ') + kleur.cyan(DISCORD_INVITE_URL),\n    ], '\\n'));\n\n    console.log(joinAndCompact([\n      ' ',\n      `This is early software that is changing fast and will be shaped by amazing users ${kleur.italic('just like you')}.`,\n      \"With your consent, we'd love to add you to our email list so we can keep you in the loop.\",\n      kleur.italic().gray(\"We promise we won't share your email and we'll only send you really awesome stuff.\"),\n    ], '\\n'));\n\n    const emailOptIn = await confirm({\n      message: 'Can we add you to our email list?',\n    });\n    if (emailOptIn) {\n      console.log(' Great!');\n      // we could use execSync('git config user.email').toString().trim();\n      // but feels a little creepy?\n      const email = await input({\n        message: 'What is your work email?',\n      });\n\n      console.log(' Thanks so much!\\n');\n\n      const userStudyOptIn = await confirm({\n        message: 'Would you be up for doing a user study and providing some feedback?',\n      });\n      if (userStudyOptIn) {\n        console.log(\" Amazing - we'll be in touch soon!\");\n      } else {\n        console.log('No worries at all.');\n        console.log(`If you ever do want to chat hit us up on discord @ ${DISCORD_INVITE_URL}`);\n      }\n\n      // TODO: figure out how we want to disable this while we are building/testing this\n      const response = await tryCatch(async () => {\n        // TODO: would love to use dmno for this URL, but using dmno while _building_ dmno feels like it might be tricky\n        return await fetch('https://signup-api.dmno.dev/signup', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({\n            email,\n            emailOptIn,\n            userStudyOptIn,\n            source: 'cli',\n            // TODO: more info about the current version of cli, system, etc?\n          }),\n        });\n      }, (_err) => {});\n\n      if (response && !response.ok) {\n        console.log((await response.json()).message);\n      }\n    } else {\n      console.log('No worries! You can always sign up later at https://dmno.dev');\n    }\n\n\n    console.log(kleur.gray('\\nDont worry, you wont see this onboarding stuff again.'));\n  }\n\n  console.log(joinAndCompact([\n    ' ',\n    'For details about how to start defining your config schema:',\n    kleur.bold().magenta('https://dmno.dev/docs/guides/schema'),\n    ' ',\n    'For drop-in integrations to use DMNO with your favorite tools:',\n    kleur.bold().magenta('https://dmno.dev/docs/integrations/overview'),\n    ' ',\n    'For plugins to securely manage your secrets:',\n    kleur.bold().magenta('https://dmno.dev/docs/plugins/overview'),\n    ' ',\n  ], '\\n'));\n\n\n  process.exit(0);\n});\n\nexport const InitCommand = program;\n","import { execSync } from 'child_process';\nimport fs from 'node:fs';\nimport path from 'path';\nimport _ from 'lodash-es';\nimport { parse as parseJSONC } from 'jsonc-parser';\nimport buildEsmResolver from 'esm-resolve';\nimport kleur from 'kleur';\nimport { outdent } from 'outdent';\nimport { input, confirm } from '@inquirer/prompts';\nimport validatePackageName from 'validate-npm-package-name';\nimport boxen from 'boxen';\nimport { tryCatch, promiseDelay } from '@dmno/ts-lib';\nimport { PackageManager, ScannedWorkspaceInfo, pathExists } from '../../config-loader/find-services';\nimport { joinAndCompact } from './formatting';\nimport { findOrCreateConfigFile, updateConfigFile } from './config-file-updater';\nimport { getDiffColoredText } from './diff-utils';\nimport { loadServiceDotEnvFiles } from '../../lib/dotenv-utils';\nimport {\n  findEnvVarsInCode, generateDmnoConfigInitialCode, inferDmnoSchema,\n} from './schema-scaffold';\nimport { checkIsFileGitIgnored } from '../../lib/git-utils';\n\nconst STEP_DELAY = 300;\n\nconst DMNO_FOLDER_TSCONFIG = outdent`\n  {\n    \"compilerOptions\": {\n      \"strict\": true\n    },\n    \"include\": [\n      \"./**/*.mts\",\n      \"./.typegen/global.d.ts\"\n    ]\n  }\n`;\n\nconst ENV_LOCAL = outdent`\n  #                     \n  # DO NOT COMMIT TO VERSION CONTROL\n  # This file contains local config overrides, some of which are likely sensitive\n  #                     \n\n  MY_SECRET_ITEM=supersecretkey123\n\n`;\n\nfunction setupStepMessage(message: string, opts?: {\n  type?: 'noop' | 'failure' | 'skip',\n  path?: string,\n  package?: string,\n  packageVersion?: string,\n  docs?: string,\n  tip?: string,\n}) {\n  const icon = {\n    noop: '',\n    failure: '',\n    skip: ' ',\n    _default: '',\n  }[opts?.type || '_default'];\n  let docsLink = opts?.docs || '';\n\n  if (docsLink && docsLink.startsWith('/')) docsLink = `https://dmno.dev/docs${docsLink}`;\n\n  return joinAndCompact([\n    `${icon} ${opts?.type === 'failure' ? kleur.bgRed(message) : message}`,\n    opts?.path && ['    ', kleur.italic().gray(opts.path)].join(''),\n    opts?.package && [\n      '    ',\n      kleur.italic().magenta(opts.package),\n      opts.packageVersion ? kleur.gray(` @ \"${opts.packageVersion}\"`) : '',\n    ].join(''),\n    opts?.tip && `    ${opts.tip}`,\n    docsLink && (`   ${kleur.italic(` see docs @ ${docsLink}`)}`),\n    ' ',\n  ], '\\n');\n}\n\n\nfunction installPackage(\n  packagePath: string,\n  packageManager: PackageManager,\n  packageName: string,\n  isMonoRepoRoot?: boolean,\n) {\n  // `add` works in all 3, `install` does not\n  execSync(`cd ${packagePath} && ${packageManager} add ${packageName} ${isMonoRepoRoot && packageManager === 'pnpm' ? '-w' : ''}`);\n}\n\n\nconst KNOWN_INTEGRATIONS_MAP: Record<string, { package: string, docs?: string }> = {\n  astro: {\n    package: '@dmno/astro-integration',\n    docs: '/integrations/astro',\n  },\n  next: {\n    package: '@dmno/nextjs-integration',\n    docs: '/integrations/nextjs',\n  },\n  vite: {\n    package: '@dmno/vite-integration',\n    docs: '/integrations/vite',\n  },\n  express: {\n    package: 'dmno',\n    docs: '/integrations/node',\n  },\n  koa: {\n    package: 'dmno',\n    docs: '/integrations/node',\n  },\n};\n\nexport async function initDmnoForService(workspaceInfo: ScannedWorkspaceInfo, servicePath: string, silent?: boolean) {\n  const rootPath = workspaceInfo.workspacePackages[0].path;\n  const nonRootPaths = workspaceInfo.workspacePackages.slice(1).map((s) => s.path);\n  const { packageManager } = workspaceInfo;\n\n  const service = workspaceInfo.workspacePackages.find((s) => s.path === servicePath);\n  if (!service) throw new Error('service not found');\n\n  const projectLabel = workspaceInfo.isMonorepo ? `workspace ${service.isRoot ? 'root' : 'package'}` : 'your project';\n  console.log(boxen(\n    [\n      `Initializing dmno in ${projectLabel} - ${kleur.magenta(service.name)}`,\n      kleur.italic().gray(service.path),\n    ].join('\\n'),\n    {\n      padding: 1, borderStyle: 'round', borderColor: 'greenBright',\n    },\n  ));\n  console.log();\n\n  // hidden env flag to force overwriting existing files\n  // might make this an actual cli option but not sure if needed\n  const overwriteMode = !!process.env.DMNO_INIT_OVERWRITE;\n\n  let packageJsonDeps: Record<string, string> = {};\n\n  async function reloadPackageJson() {\n    const packageJsonPath = `${service!.path}/package.json`;\n    const packageJson = await tryCatch(async () => {\n      const rawPackageJson = await fs.promises.readFile(packageJsonPath);\n      return JSON.parse(rawPackageJson.toString());\n    }, (err) => {\n      console.log(`Unable to parse ${kleur.green(packageJsonPath)}`);\n      throw err;\n    });\n    packageJsonDeps = {\n      ...packageJson.dependencies,\n      ...packageJson.devDependencies,\n    };\n  }\n  await reloadPackageJson();\n\n\n  const isDmnoInstalled = !!packageJsonDeps.dmno;\n  const dmnoVersionRange = packageJsonDeps.dmno;\n  // TODO: here we could prompt you to _upgrade_ your version of dmno\n\n  // INSTALL DMNO\n  if (!overwriteMode && isDmnoInstalled) {\n    console.log(setupStepMessage('dmno already installed', { type: 'noop', package: 'dmno', packageVersion: dmnoVersionRange }));\n  } else {\n    try {\n      installPackage(service.path, packageManager, 'dmno', workspaceInfo.isMonorepo && service.isRoot);\n      await reloadPackageJson();\n\n      console.log(setupStepMessage('dmno installed', { package: 'dmno', packageVersion: packageJsonDeps.dmno }));\n    } catch (err) {\n      console.log(' dmno install failed');\n      throw err;\n    }\n  }\n\n  // INSTALL KNOWN INTEGRATIONS\n  const installedIntegrationPublicPrefixes: Array<string> = [];\n  for (const knownIntegrationDep in KNOWN_INTEGRATIONS_MAP) {\n    // currently we check dependencies, but we could look for specific config files instead\n    if (packageJsonDeps[knownIntegrationDep]) {\n      const suggestedDmnoIntegration = KNOWN_INTEGRATIONS_MAP[\n        knownIntegrationDep as keyof typeof KNOWN_INTEGRATIONS_MAP\n      ];\n\n      if (suggestedDmnoIntegration.package === 'dmno') {\n        console.log(setupStepMessage(`DMNO + ${knownIntegrationDep} - natively supported integration`, {\n          type: 'noop',\n          docs: suggestedDmnoIntegration.docs,\n        }));\n      } else if (packageJsonDeps[suggestedDmnoIntegration.package]) {\n        console.log(setupStepMessage(`DMNO + ${knownIntegrationDep} - integration already installed`, {\n          type: 'noop',\n          package: suggestedDmnoIntegration.package,\n          packageVersion: packageJsonDeps[suggestedDmnoIntegration.package],\n          docs: suggestedDmnoIntegration.docs,\n        }));\n      } else {\n        console.log(`It looks like this package uses ${kleur.green(knownIntegrationDep)}!`);\n        const confirmIntegrationInstall = await confirm({\n          message: `Would you like to install the ${kleur.green(suggestedDmnoIntegration.package)} package?`,\n        });\n\n        if (!confirmIntegrationInstall) {\n          console.log('No worries - you can always install it later!');\n        } else {\n          installPackage(service.path, workspaceInfo.packageManager, suggestedDmnoIntegration.package, false);\n          await reloadPackageJson();\n\n          console.log(setupStepMessage(`DMNO + ${knownIntegrationDep} integration installed!`, { package: suggestedDmnoIntegration.package, packageVersion: packageJsonDeps[suggestedDmnoIntegration.package] }));\n        }\n      }\n\n      // RUN KNOWN INTEGRATIONS CONFIG CODEMODS\n      if (suggestedDmnoIntegration.package !== 'dmno' && packageJsonDeps[suggestedDmnoIntegration.package]) {\n        try {\n          // import.meta.resolve isn't flexible enough for us at the moment\n          const esmResolver = buildEsmResolver(service.path, {\n            isDir: true,\n            constraints: 'node',\n            resolveToAbsolute: true,\n          });\n          const integrationMetaFile = esmResolver(`${suggestedDmnoIntegration.package}/meta`);\n          if (!integrationMetaFile) {\n            throw new Error('Unable to find integration meta info file');\n          }\n          // TODO: add some typing on the meta provider stuff...\n          const integrationMetaRaw = await fs.promises.readFile(integrationMetaFile, 'utf8');\n          const integrationMeta = parseJSONC(integrationMetaRaw);\n\n          // track the public env var prefix (ex: `NEXT_PUBLIC_`)\n          if (integrationMeta.publicPrefix) {\n            installedIntegrationPublicPrefixes.push(integrationMeta.publicPrefix);\n          }\n\n          // currently we are assuming only a single codemod and that it will be for a config file\n          // but will likely change\n          const configCodeMods = integrationMeta.installationCodemods?.[0];\n\n          const { createWithContents, path: configFileFullPath } = await findOrCreateConfigFile(\n            service.path,\n            configCodeMods.glob,\n            configCodeMods.createFileIfNotFound,\n          );\n          const configFileName = configFileFullPath.split('/').pop();\n          if (configFileFullPath) {\n            const originalConfigFileSrc = createWithContents ?? await fs.promises.readFile(configFileFullPath, 'utf-8');\n            const updatedConfigFileSrc = await updateConfigFile(originalConfigFileSrc, configCodeMods);\n\n            if (originalConfigFileSrc === updatedConfigFileSrc) {\n              console.log(setupStepMessage(`${configFileName} already sets up ${suggestedDmnoIntegration.package}`, { type: 'noop', path: configFileFullPath }));\n            } else {\n              const diffText = getDiffColoredText(createWithContents ? '' : originalConfigFileSrc, updatedConfigFileSrc);\n              if (createWithContents) {\n                console.log(kleur.italic().bgBlue(` DMNO will create a new ${knownIntegrationDep} config file for you `));\n              } else {\n                console.log(kleur.italic().bgBlue(' DMNO will make the following changes to your config file '));\n              }\n              console.log(kleur.italic().gray(`> Filename: ${configFileName}\\n`));\n              // boxen wasn't handling indentation and line wrapping well\n              console.log(diffText.trim());\n              console.log(kleur.italic().bgBlue(' -------------------------------------------------------- '));\n\n              const confirmedConfigChanges = await confirm({\n                message: 'Continue?',\n              });\n              if (confirmedConfigChanges) {\n                await fs.promises.writeFile(configFileFullPath, updatedConfigFileSrc);\n                console.log(setupStepMessage(`${configFileName} updated to set up ${suggestedDmnoIntegration.package}`, { path: configFileFullPath }));\n              } else {\n                console.log(setupStepMessage(`Skipped ${configFileName} updates to set up ${suggestedDmnoIntegration.package}`, { type: 'skip', path: configFileFullPath }));\n              }\n            }\n          }\n        } catch (err) {\n          console.log(err);\n        }\n      }\n    }\n  }\n\n  // CREATE .dmno FOLDER\n  await promiseDelay(STEP_DELAY);\n  if (service.dmnoFolder) {\n    console.log(setupStepMessage('.dmno folder already exists!', { type: 'noop' }));\n  } else {\n    // create dmno folder\n    await fs.promises.mkdir(`${service.path}/.dmno`);\n    console.log(setupStepMessage('.dmno folder created!'));\n  }\n\n  const dotEnvFiles = await loadServiceDotEnvFiles(service.path, {\n    excludeDirs: service.isRoot ? nonRootPaths : [],\n  });\n\n  // CREATE .dmno/config.mts\n  let configFileGenerated = false;\n  const configMtsPath = `${service.path}/.dmno/config.mts`;\n  if (!overwriteMode && await pathExists(configMtsPath)) {\n    await promiseDelay(STEP_DELAY);\n    console.log(setupStepMessage('.dmno/config.mts already exists!', { type: 'noop', path: configMtsPath }));\n  } else {\n    const recommendedName = service.isRoot ? 'root' : service.name.replace(/^@[^/]+\\//, '');\n\n    let serviceName: string | undefined = silent ? recommendedName : undefined;\n    while (serviceName === undefined) {\n      // TODO: better cli input with more options for dynamic help info\n      serviceName = await input({\n        message: 'What do you want to name this service? (enter \"?\" for help)',\n        default: recommendedName,\n        validate(value) {\n          // leaving empty will package name from package.json\n          if (!value) return true;\n          if (value === '?') return true;\n\n          // TODO: better error messages?\n          const validationResult = validatePackageName(value);\n          if (validationResult.validForNewPackages) return true;\n          return validationResult.errors?.[0] || 'invalid name';\n        },\n      });\n      serviceName = serviceName.trim();\n\n      if (serviceName === '?') {\n        console.log(boxen([\n          'Every \"service\" in dmno, including the root, has a name which we refer to as the \"service name\".',\n          '',\n          'If you don\\'t specify one, we\\'ll use the name from your package.json file. But, package names often have a prefix/scope (e.g., \"@mycoolorg/some-service\") and you may need to type this name in a few places - like selecting a service via the dmno CLI - you want to keep it simple.',\n          '',\n          'You can use our suggestion, write your own name, or delete the default to inherit the name from package.json.',\n          '',\n          kleur.italic(`you can always change this later by editing ${kleur.blue('.dmno/config.mts')}`),\n        ].join('\\n'), {\n          padding: 1, margin: 1, borderStyle: 'double', title: 'Help - service name',\n        }));\n        serviceName = undefined;\n      }\n    }\n\n    const envVarsFromCode = await findEnvVarsInCode(service.path, {\n      excludeDirs: service.isRoot ? nonRootPaths : [],\n    });\n    const inferredSchema = await inferDmnoSchema(dotEnvFiles, envVarsFromCode, installedIntegrationPublicPrefixes);\n    const schemaMtsCode = generateDmnoConfigInitialCode(service.isRoot, serviceName, inferredSchema);\n    configFileGenerated = true;\n\n    await fs.promises.writeFile(\n      configMtsPath,\n      schemaMtsCode,\n    );\n    console.log(setupStepMessage('.dmno/config.mts created!', {\n      path: configMtsPath,\n      tip: 'Please review and update this file!',\n    }));\n  }\n\n  // clean up dotenv files - delete samples and checked in files\n  const committedDotEnvFiles = dotEnvFiles.filter((d) => !d.isGitIgnored);\n  if (committedDotEnvFiles.length) {\n    await promiseDelay(STEP_DELAY);\n    if (configFileGenerated) {\n      for (const dotEnvFile of committedDotEnvFiles) {\n        console.log(`\\nYou no longer need your ${kleur.blue(dotEnvFile.fileName)} file - as we've incorporated it into your new ${kleur.blue('.dmno/config.mts')} file.`);\n        const confirmDelete = await confirm({\n          message: `Can we delete ${kleur.blue(dotEnvFile.relativePath)}?`,\n        });\n        if (confirmDelete) {\n          await fs.promises.unlink(dotEnvFile.path);\n          console.log(setupStepMessage(`deleted dotenv file - ${dotEnvFile.fileName}`, { path: dotEnvFile.path }));\n        } else {\n          console.log(setupStepMessage(`did NOT delete ${kleur.blue(dotEnvFile.fileName)}`, {\n            type: 'skip',\n            tip: 'Please delete this file and migrate any useful into your config.mts file',\n            path: dotEnvFile.path,\n          }));\n        }\n      }\n    } else {\n      console.log(`\\nWe recommend you delete any .env files (including samples) that you have checked into git, and instead incorporate them into your ${kleur.blue('.dmno/config.mts')} file. Please delete these files:`);\n      console.log(committedDotEnvFiles.map((f) => `  - ${kleur.blue(f.relativePath)}`).join('\\n'));\n      console.log();\n    }\n  }\n\n  const ignoredDotEnvFiles = dotEnvFiles.filter((d) => d.isGitIgnored && !d.path.includes('/.dmno/'));\n  if (ignoredDotEnvFiles.length) {\n    await promiseDelay(STEP_DELAY);\n    console.log('\\nTo avoid potential issues and confusion, we recommend you move any .env file(s) into your .dmno folder and load them via dmno.');\n\n    for (const dotEnvFile of ignoredDotEnvFiles) {\n      const confirmMove = await confirm({\n        message: `Can we move ${kleur.blue(dotEnvFile.relativePath)}?`,\n      });\n\n      const newPath = `${service.path}/.dmno/${dotEnvFile.fileName}`;\n\n      if (confirmMove) {\n        await fs.promises.rename(dotEnvFile.path, newPath);\n        // make sure that if the file was gitignored before the move that it still is - we don't want to help the user accidentally commit secrets\n        // .env.local will be handled by the root gitignore since we always are creating those files\n        if (dotEnvFile.fileName !== '.env.local' && dotEnvFile.isGitIgnored && !(await checkIsFileGitIgnored(newPath))) {\n          await fs.promises.appendFile(`${service.path}/.gitignore`, `\\n./.dmno/${dotEnvFile.fileName}`);\n        }\n        console.log(setupStepMessage(`moved ${kleur.blue(dotEnvFile.relativePath)} to .dmno folder`, { path: newPath }));\n      } else {\n        console.log(setupStepMessage(`did NOT move ${kleur.blue(dotEnvFile.fileName)}`, {\n          type: 'skip',\n          tip: 'Please move this file into the .dmno folder',\n          path: dotEnvFile.path,\n        }));\n      }\n    }\n  }\n\n  // create empty .env.local\n  await promiseDelay(STEP_DELAY);\n  const envLocalPath = `${service.path}/.dmno/.env.local`;\n  if (!overwriteMode && await pathExists(envLocalPath)) {\n    console.log(setupStepMessage('.dmno/.env.local already exists!', { type: 'noop', path: envLocalPath }));\n  } else {\n    await fs.promises.writeFile(envLocalPath, ENV_LOCAL);\n    console.log(setupStepMessage('.dmno/.env.local created!', { path: envLocalPath }));\n  }\n\n\n\n  // CREATE .dmno/tsconfig.json\n  await promiseDelay(STEP_DELAY);\n  const tsConfigPath = `${service.path}/.dmno/tsconfig.json`;\n  if (!overwriteMode && await pathExists(tsConfigPath)) {\n    console.log(setupStepMessage('.dmno/tsconfig.json already exists!', { type: 'noop', path: tsConfigPath }));\n  } else {\n    await fs.promises.writeFile(tsConfigPath, DMNO_FOLDER_TSCONFIG);\n    console.log(setupStepMessage('.dmno/tsconfig.json created!', { path: tsConfigPath }));\n  }\n\n\n  if (service.isRoot) {\n    await promiseDelay(STEP_DELAY);\n    const gitIgnorePath = `${servicePath}/.gitignore`;\n\n    let gitIgnore = '';\n    let createdGitIgnore = false;\n    try {\n      gitIgnore = await fs.promises.readFile(gitIgnorePath, 'utf8');\n    } catch (err) {\n      await fs.promises.writeFile(gitIgnorePath, '');\n      createdGitIgnore = true;\n    }\n    // TODO: check for each item rather than all or nothing\n    // TODO: show some kind of warning if user is not within a git repo\n    if (gitIgnore.includes('**/.dmno/cache.json')) {\n      console.log(setupStepMessage('.gitignore already includes dmno files', { type: 'noop', path: gitIgnorePath }));\n    } else {\n      gitIgnore += outdent`\n        # dmno files ###\n        # local cache for resolved values\n        **/.dmno/cache.json\n        # encryption key used for cache\n        **/.dmno/cache-key.json\n        # generated type files\n        **/.dmno/.typegen\n        # iconify cache used in generated types\n        **/.dmno/.icon-cache\n        # local config overrides\n        **/.dmno/.env.local\n      `;\n      await fs.promises.writeFile(gitIgnorePath, gitIgnore);\n      console.log(setupStepMessage(`.gitignore ${createdGitIgnore ? 'created' : 'updated'} with dmno files!`, { path: gitIgnorePath }));\n    }\n  }\n\n  // SET UP TYPESCRIPT\n  let srcDirPath = `${service.path}/src`;\n  if (!fs.existsSync(srcDirPath)) srcDirPath = service.path;\n  const dmnoEnvFilePath = `${srcDirPath}/dmno-env.d.ts`;\n  if (fs.existsSync(dmnoEnvFilePath)) {\n    console.log(setupStepMessage('injecting dmno types - dmno-env.d.ts already exists', {\n      type: 'noop',\n      path: dmnoEnvFilePath,\n      docs: '/guides/typescript',\n    }));\n  } else {\n    let globalDtsRelativePath = path.relative(srcDirPath, `${service.path}/.dmno/.typegen/global.d.ts`);\n    if (globalDtsRelativePath.startsWith('.dmno')) globalDtsRelativePath = `./${globalDtsRelativePath}`;\n    await fs.promises.writeFile(dmnoEnvFilePath, outdent`\n      // inject DMNO_CONFIG global\n      /// <reference types=\"${globalDtsRelativePath}\" />\n      // inject DMNO_PUBLIC_CONFIG global\n      /// <reference types=\"${globalDtsRelativePath.replace('global.d.ts', 'global-public.d.ts')}\" />\n\n    `);\n    console.log(setupStepMessage('injecting dmno types - created dmno-env.d.ts file', {\n      path: dmnoEnvFilePath,\n      docs: '/guides/typescript',\n    }));\n  }\n\n  // const tsConfigFiles = await (\n  //   new fdir() // eslint-disable-line new-cap\n  //     .withRelativePaths()\n  //     .glob('./tsconfig.json', './tsconfig.*.json', 'jsconfig.json')\n  //     .withMaxDepth(0)\n  //     .crawl(service.path)\n  //     .withPromise()\n  // );\n  // if (!tsConfigFiles.length) {\n  //   console.log(setupStepMessage('Failed to inject dmno types - no tsconfig/jsconfig found', {\n  //     type: 'failure',\n  //     docs: '/guides/typescript',\n  //   }));\n  // }\n  // for (const tsConfigFileName of tsConfigFiles) {\n  //   const tsConfigPath = `${service.path}/${tsConfigFileName}`;\n  //   const originalTsConfigContents = (await fs.promises.readFile(tsConfigPath)).toString();\n  //   const updatedTsConfigContents = await injectDmnoTypesIntoTsConfig(originalTsConfigContents);\n  //   if (updatedTsConfigContents) {\n  //     // TODO: maybe want to confirm with the user and show a diff?\n  //     await fs.promises.writeFile(tsConfigPath, updatedTsConfigContents);\n\n  //     console.log(setupStepMessage(`injected dmno types into ${tsConfigFileName}`, {\n  //       path: tsConfigPath,\n  //       // docs: suggestedDmnoIntegration.docs,\n  //     }));\n  //   } else {\n  //     console.log(setupStepMessage('tsconfig already includes dmno types', {\n  //       type: 'noop',\n  //       path: tsConfigPath,\n  //       // docs: suggestedDmnoIntegration.docs,\n  //     }));\n  //   }\n  // }\n\n\n  // SECRETS PLUGINS\n  // TODO\n  // if (service.isRoot) {}\n}\n","import fs from 'node:fs';\nimport _ from 'lodash-es';\nimport * as acorn from 'acorn';\nimport tsPlugin from 'acorn-typescript';\nimport { fdir } from 'fdir';\nimport { stringInsert } from './string-utils';\n\n\ntype ConfigFileUpdateActions =\n  { arrayContains: string }\n  | { wrapWithFn: string };\n\n\nexport async function findOrCreateConfigFile(\n  baseDir: string,\n  glob: string,\n  createSettings?: {\n    fileName: string,\n    contents: string,\n  },\n) {\n  const expandedPathsFromGlobs = await (\n    new fdir() // eslint-disable-line new-cap\n      .withRelativePaths()\n      .glob(glob)\n      .crawl(baseDir)\n      .withPromise()\n  );\n  if (!expandedPathsFromGlobs.length) {\n    if (createSettings) {\n      const newFilePath = `${baseDir}/${createSettings.fileName}`;\n      return { createWithContents: createSettings.contents, path: newFilePath };\n    } else {\n      throw new Error(`failed to find matching config file in ${baseDir} with glob \"${glob}\"`);\n    }\n  } else if (expandedPathsFromGlobs.length > 1) {\n    throw new Error(`found multiple matching config files in ${baseDir} with glob \"${glob}\"`);\n  }\n  return { path: `${baseDir}/${expandedPathsFromGlobs[0]}` };\n}\n\nexport async function updateConfigFile(\n  originalSrc: string,\n  opts: {\n    imports?: Array<{\n      moduleName: string,\n      importDefaultAs?: string,\n      importVars?: Array<string>;\n    }>,\n    updates?: Array<{\n      // so far, we only need to modify the default export, but we may need other options\n      symbol: 'EXPORT',\n      path?: Array<string>,\n      action: ConfigFileUpdateActions,\n    }>\n  },\n) {\n  const mods: Array<{ insertAt: number, text: string }> = [];\n\n  // @ts-ignore\n  const parser = acorn.Parser.extend(tsPlugin());\n  const ast = parser.parse(originalSrc, { sourceType: 'module', ecmaVersion: 'latest', locations: true });\n  // console.dir(ast, { depth: null });\n\n  const importNodes: Array<acorn.ImportDeclaration> = ast.body.filter((n) => n.type === 'ImportDeclaration') as any;\n\n  // determine existing style of quotes / semicolons\n  const q = importNodes?.[0]?.source.raw?.endsWith('\"') ? '\"' : \"'\";\n  const semi = (!importNodes.length || originalSrc.substr(importNodes[0].end - 1, 1) === ';') ? ';' : '';\n\n  for (const singleImport of opts.imports || []) {\n    const { moduleName, importDefaultAs, importVars } = singleImport;\n    // first see if the file is already imported\n    const existingImportNode = importNodes.find((n) => n.source.value === moduleName);\n    if (existingImportNode) {\n      // here we could edit the exiting import, but for now we'll assume that if the import exists\n      // then the user already knows what they are doing\n\n      // we may also need to know what vars/names they imported\n    } else {\n      /* eslint-disable no-nested-ternary, prefer-template */\n      const importStr = 'import '\n        + (importDefaultAs || '')\n        + ((importDefaultAs && importVars?.length) ? ', ' : '')\n        + (importVars?.length ? `{ ${importVars?.join(', ')} }` : '')\n        + ((importDefaultAs || importVars?.length) ? ' from ' : '')\n        + `${q}${moduleName}${q}${semi}`;\n\n\n      // TODO: if there are no existing imports, we may want to insert after any comments rather than the start of the file\n      mods.push({\n        insertAt: importNodes[0]?.start || 0,\n        text: `${importStr}\\n`,\n      });\n\n      // logic to import last - we could add this as an _option_ if useful\n      // // we'll insert our import as the last one before any local files\n      // const lastModuleImportNode = importNodes.findLast((n) => {\n      //   const importedStr = n.source.value as string;\n      //   return !importedStr.startsWith('./') && !importedStr.startsWith('../');\n      // });\n      // mods.push({\n      //   // if no imports, we could potentially find the last comment or something?\n      //   insertAt: lastModuleImportNode?.end || 0,\n      //   text: `\\n${importStr}`,\n      // });\n    }\n  }\n\n  for (const singleUpdate of opts.updates || []) {\n    // currently we're always updating the default export\n    // as we encounter more use cases, we can expand all our options here\n    if (singleUpdate.symbol === 'EXPORT') {\n      let nodeToUpdate: acorn.AnyNode | undefined;\n      let pathNodeToUpdate: acorn.AnyNode | undefined;\n      for (const n of ast.body) {\n        // matches `export default ...`\n        if (n.type === 'ExportDefaultDeclaration') {\n          nodeToUpdate = n.declaration;\n        // matches `module.exports = ...`\n        } else if (\n          n.type === 'ExpressionStatement'\n          && n.expression.type === 'AssignmentExpression' && n.expression.operator === '='\n          && originalSrc.substring(n.expression.left.start, n.expression.left.end) === 'module.exports'\n        ) {\n          nodeToUpdate = n.expression.right;\n        }\n        if (nodeToUpdate) break;\n      }\n      if (!nodeToUpdate) throw new Error('Unable to find `export default` or `module.exports = `');\n\n      // if a path was passed in, we'll try to find it in an object\n      if (singleUpdate.path) {\n        // if the node is a function call we'll dive into it and assume we want the first arg\n        // (this matches the `export default defineConfig({...})` pattern that many config files use)\n        if (nodeToUpdate.type === 'CallExpression' && nodeToUpdate.arguments.length) {\n          nodeToUpdate = nodeToUpdate.arguments[0];\n        }\n        if (nodeToUpdate.type !== 'ObjectExpression') {\n          throw new Error('Expected to find an object node to use apply the path selector');\n        }\n        // currently only supports path of depth 1, but should support going deeper\n        pathNodeToUpdate = nodeToUpdate.properties.find((n) => n.type === 'Property' && (n.key as any).name === singleUpdate.path![0]);\n        if (pathNodeToUpdate && pathNodeToUpdate.type !== 'Property') {\n          throw new Error('Node is not a property');\n        }\n      }\n\n      if (!nodeToUpdate) {\n        throw new Error('unable to find AST node to update');\n      }\n\n      // this action will ensure an array contains an item matching some code\n      if ('arrayContains' in singleUpdate.action) {\n        // handle the case where the path doesn't exist in the object yet\n        if (!pathNodeToUpdate) {\n          if (nodeToUpdate.type === 'ObjectExpression') {\n            const trailingSpace = originalSrc.charAt(nodeToUpdate.end - 2) === ' ';\n            mods.push({\n              insertAt: nodeToUpdate.end - (trailingSpace ? 2 : 1),\n              text: [\n                nodeToUpdate.properties.length ? ', ' : ' ',\n                `${singleUpdate.path}: [${singleUpdate.action.arrayContains}]`,\n                !trailingSpace ? ' ' : '',\n              ].join(''),\n            });\n            break;\n          } else {\n            throw new Error(`Unable to insert new array at path ${singleUpdate.path}`);\n          }\n        }\n\n        if (pathNodeToUpdate.type !== 'Property') {\n          throw new Error('node to update is not an object property');\n        } else if (pathNodeToUpdate.value.type !== 'ArrayExpression') {\n          throw new Error('node property value is not an array');\n        }\n\n        const arrayItems = pathNodeToUpdate.value.elements;\n        let itemFound = false;\n        for (const arrayItem of pathNodeToUpdate.value.elements) {\n          if (!arrayItem) continue;\n          const itemStr = originalSrc.substring(arrayItem.start, arrayItem.end);\n\n          // we use startWith instead of === so that it handles things like `somePlugin() as AstroPlugin`\n          // not at all perfect, but an edge case we are seeing internally... will make it more robust eventually\n          if (itemStr.startsWith(singleUpdate.action.arrayContains)) {\n            itemFound = true;\n            break;\n          }\n        }\n\n        if (itemFound) {\n          break;\n        } else {\n          const isMultiLine = originalSrc.substring(pathNodeToUpdate.value.start, pathNodeToUpdate.value.end).includes('\\n');\n\n          mods.push({\n            insertAt: pathNodeToUpdate.value.start + 1,\n            text:\n              // TODO: handle empty array\n              // TODO: better handling of indents / line breaks too, single line arrays\n              (isMultiLine ? '\\n    ' : '')\n              + singleUpdate.action.arrayContains\n              + (arrayItems.length ? ', ' : ''),\n          });\n        }\n\n      // this action will wrap the node with a function call ex: `wrapWithCode(NODE)`\n      } else if ('wrapWithFn' in singleUpdate.action) {\n        // naively just check if the fn is anywhere within the code\n        // eventually we'll want to be smarter but we'll potentially need to walk a tree of wrapped fn calls\n        if (originalSrc.substring(nodeToUpdate.start, nodeToUpdate.end).includes(singleUpdate.action.wrapWithFn)) {\n          break;\n        }\n        mods.push(\n          {\n            insertAt: nodeToUpdate.start,\n            text: `${singleUpdate.action.wrapWithFn}(`,\n          },\n          {\n            insertAt: nodeToUpdate.end,\n            text: ')',\n          },\n        );\n      }\n    }\n  }\n\n  let updatedSrc = originalSrc;\n  let insertedChars = 0;\n  for (const singleMod of mods) {\n    updatedSrc = stringInsert(insertedChars + singleMod.insertAt, updatedSrc, singleMod.text);\n    insertedChars += singleMod.text.length;\n  }\n\n  return updatedSrc;\n}\n\n\n","import { diffWords } from 'diff';\nimport kleur from 'kleur';\n\nexport function getDiffColoredText(input: string, output: string): string {\n  const diffResult = diffWords(input, output);\n\n  if (!diffResult.some((chunk) => chunk.added || chunk.removed)) {\n    return output;\n  }\n\n  const diffText = diffResult.map((chunk) => {\n    if (!chunk.added && !chunk.removed) return chunk.value;\n    return chunk.value.split('\\n')\n      .map(kleur[chunk.added ? 'green' : 'red'])\n      .join('\\n');\n  }).join('');\n\n  return diffText;\n}\n","import fs from 'node:fs';\nimport _ from 'lodash-es';\nimport { fdir } from 'fdir';\nimport { LoadedDotEnvFile } from '../../lib/dotenv-utils';\nimport { joinAndCompact } from './formatting';\nimport { asyncEachLimit } from '../../lib/async-utils';\n\n// data structure to store our scaffolded dmno config that will be transformed into actual code\n// it will be a subset of our actual config, and we'll need to store the\nexport type DmnoConfigScaffoldItem = {\n  exampleValue?: any,\n  description?: string,\n  extends?: InferredBasicTypes,\n  value?: any,\n  valuesForEnv?: Record<string, any>,\n  sensitive?: boolean,\n  comment?: string,\n};\ntype DmnoConfigScaffold = Record<string, DmnoConfigScaffoldItem>;\n\nexport async function inferDmnoSchema(\n  dotEnvFiles: Array<LoadedDotEnvFile>,\n  envVarsFromCode: EnvVarsFromCode,\n  publicPrefixes?: Array<string>,\n) {\n  const dmnoSchema: DmnoConfigScaffold = {};\n\n  for (const dotEnvFile of dotEnvFiles) {\n    for (const itemKey in dotEnvFile.items) {\n      const dotEnvItem = dotEnvFile.items[itemKey];\n\n      const itemHasPublicPrefix = _.some(publicPrefixes, (prefix) => itemKey.startsWith(prefix));\n\n      dmnoSchema[itemKey] ||= {\n        // we default everything is sensitive, and can then undo it later\n        ...!itemHasPublicPrefix && { sensitive: true },\n      };\n\n      let coercedItemVal: any | undefined;\n      if (\n        !dmnoSchema[itemKey].extends\n        && dotEnvItem.value !== undefined\n        && dotEnvItem.value !== ''\n      ) {\n        const inferredType = inferTypeFromEnvStringVal(dotEnvItem.value);\n        if (inferredType.type !== 'string') dmnoSchema[itemKey].extends = inferredType.type;\n        if (inferredType.coercedValue !== undefined) {\n          coercedItemVal = inferredType.coercedValue;\n        }\n        // some types dont really make sense to ever be sensitive - not sure about other types yet...\n        if (['boolean'].includes(inferredType.type)) {\n          delete dmnoSchema[itemKey].sensitive;\n        }\n        if (inferredType.comment) {\n          // TODO: we could have multiple kinds of comments (ex: extendsComment) so they go next to the right place\n          dmnoSchema[itemKey].comment = inferredType.comment;\n        }\n      }\n\n      // use comments as description if coming from defaults or sample file\n      if (\n        (dotEnvItem.preComment || dotEnvItem.postComment)\n        && !dotEnvFile.applyForEnv\n      ) {\n        dmnoSchema[itemKey].description ||= dotEnvItem.preComment || dotEnvItem.postComment;\n      }\n\n      // fill in sample value\n      if (dotEnvItem.value && dotEnvFile.isSampleFile && !dotEnvFile.applyForEnv) {\n        dmnoSchema[itemKey].exampleValue = dotEnvItem.value;\n      }\n\n      // put value in the schema if not gitignored\n      if (\n        dotEnvItem.value !== undefined\n        && !dotEnvFile.isSampleFile\n        && !dotEnvFile.isGitIgnored\n        && !dotEnvFile.isOverridesFile\n      ) {\n        // we'll assume items with values committed into the repo are not sensitive\n        delete dmnoSchema[itemKey].sensitive;\n\n        if (!dotEnvFile.applyForEnv) {\n          dmnoSchema[itemKey].value = coercedItemVal ?? dotEnvItem.value;\n        } else {\n          dmnoSchema[itemKey].valuesForEnv ||= {};\n          dmnoSchema[itemKey].valuesForEnv![dotEnvFile.applyForEnv] = coercedItemVal ?? dotEnvItem.value;\n        }\n      }\n    }\n  }\n  for (const varKey in envVarsFromCode) {\n    const itemHasPublicPrefix = _.some(publicPrefixes, (prefix) => varKey.startsWith(prefix));\n\n    // TODO: we could think about inferring static/dynamic based on whether it came from process.env or import.meta\n    // and also sensitivity based on public prefixes for the service's integration (ie NEXT_PUBLIC_...)\n    dmnoSchema[varKey] ||= {\n      ...!itemHasPublicPrefix && { sensitive: true },\n    };\n  }\n  return dmnoSchema;\n}\nexport function generateDmnoSchemaCode(schemaScaffold: DmnoConfigScaffold) {\n  const itemsAsCode: Array<string> = [];\n  for (const itemKey in schemaScaffold) {\n    if (_.isEmpty(schemaScaffold[itemKey])) {\n      itemsAsCode.push(`${itemKey}: {},`);\n      continue;\n    }\n\n    const scaffoldItem = _.cloneDeep(schemaScaffold[itemKey]);\n    let itemCode = `${itemKey}: {\\n`;\n\n    for (const propKey in scaffoldItem) {\n      // skip emitting value if we are going to use a toggle\n      if (propKey === 'value' && scaffoldItem.valuesForEnv) continue;\n      if (propKey === 'valuesForEnv') continue;\n      const propVal = scaffoldItem[propKey as keyof typeof scaffoldItem];\n      if (propKey === 'comment') {\n        itemCode += `  // ${propVal}\\n`;\n      } else if (propKey === 'extends') {\n        itemCode += `  ${propKey}: DmnoBaseTypes.${propVal},\\n`;\n      } else {\n        itemCode += `  ${propKey}: ${JSON.stringify(propVal)},\\n`;\n      }\n    }\n\n    if (scaffoldItem.valuesForEnv) {\n      const switchEntries: Array<string> = [];\n      if (scaffoldItem.value !== undefined) {\n        switchEntries.push(`_default: ${JSON.stringify(scaffoldItem.value)}`);\n      }\n      for (const envKey in scaffoldItem.valuesForEnv) {\n        switchEntries.push(`${envKey}: ${JSON.stringify(scaffoldItem.valuesForEnv[envKey])}`);\n      }\n      itemCode += '  value: switchByNodeEnv({\\n';\n      itemCode += switchEntries.map((switchEntryLine) => `    ${switchEntryLine},\\n`).join('');\n      itemCode += '  })\\n';\n    }\n\n    itemCode += '},';\n    itemsAsCode.push(itemCode);\n  }\n\n  return itemsAsCode.join('\\n');\n}\n\n\nexport function generateDmnoConfigInitialCode(\n  isRoot: boolean,\n  serviceName: string,\n  configSchemaScaffold: DmnoConfigScaffold,\n) {\n  const defineFn = isRoot ? 'defineDmnoWorkspace' : 'defineDmnoService';\n  const schemaConfigAsCode = generateDmnoSchemaCode(configSchemaScaffold);\n  const usesSwitchByNodeEnv = schemaConfigAsCode.includes('value: switchByNodeEnv({');\n  const dmnoImports = [\n    'DmnoBaseTypes',\n    defineFn,\n    usesSwitchByNodeEnv && 'switchByNodeEnv',\n  ];\n  return [\n    `import { ${joinAndCompact(dmnoImports, ', ')} } from 'dmno';`,\n    '',\n    `export default ${defineFn}({`,\n    serviceName ? `  name: '${serviceName}',` : '  // no name specified - inherit from package.json',\n    isRoot ? undefined : '  pick: [],',\n    '  schema: {',\n    ...schemaConfigAsCode.split('\\n').map((line) => `    ${line}`),\n    '  },',\n    '});',\n    '',\n  ].join('\\n');\n}\n\n\n\n\ntype InferredBasicTypes = 'string' | 'number' | 'boolean' | 'email' | 'url';\ntype InferredTypeSchema = { type: InferredBasicTypes, coercedValue?: any, comment?: string };\n// probably should live somewhere else?\nconst TRUE_VALS = ['true', 't', '1'];\nconst FALSE_VALS = ['false', 'f', '0'];\nconst NUMERIC_REGEX = /^-?\\d*(\\.\\d+)?$/;\nconst EMAIL_REGEX = /^[\\w-.]+@([\\w-]+\\.)+[\\w-]{2,4}$/;\nconst URL_REGEX = /(?:^|\\s)((https?:\\/\\/)?(?:localhost|[\\w-]+(?:\\.[\\w-]+)+)(:\\d+)?(\\/\\S*)?)/;\n/** fairly naive attempt at inferring some basic types from string values */\nexport function inferTypeFromEnvStringVal(val: string): InferredTypeSchema {\n  if (TRUE_VALS.includes(val.toLowerCase())) {\n    return {\n      type: 'boolean',\n      coercedValue: true,\n      ...val === '1' && { comment: 'TODO: review this - value was `1`, so could be number instead of boolean?' },\n    };\n  }\n  if (FALSE_VALS.includes(val.toLowerCase())) {\n    return {\n      type: 'boolean',\n      coercedValue: false,\n      ...val === '0' && { comment: 'TODO: review this - value was `0`, so could be number instead of boolean?' },\n    };\n  }\n  if (NUMERIC_REGEX.test(val)) return { type: 'number', coercedValue: parseFloat(val) };\n  if (URL_REGEX.test(val)) return { type: 'url' };\n  if (EMAIL_REGEX.test(val)) return { type: 'email' };\n  return { type: 'string' };\n}\n\n\n\nconst ENV_VAR_REGEX = /(process\\.env|import\\.meta\\.env)\\.([A-Za-z_][A-Za-z0-9_$]*)/g;\n\ntype EnvVarsFromCode = Record<string, Record<string, boolean>>;\n// ex: { SOME_VAR: { 'process.env': true } }\nexport async function findEnvVarsInCode(\n  dirPath: string,\n  opts?: {\n    excludeDirs?: Array<string>\n  },\n) {\n  // TODO: we may want to prompt the user instead\n  // and eventually we may need to detect env var usage in other languages\n  const fileExtensions = [\n    'ts', 'mts', 'cts', 'tsx',\n    'js', 'mjs', 'cjs', 'jsx',\n    'mdx', 'astro', 'vue', 'svelte',\n  ];\n  const filesToSearch = await (\n    new fdir() // eslint-disable-line new-cap\n      .withBasePath()\n      .glob(`**/*.{${fileExtensions.join(',')}}`)\n      .exclude((excludeDirName, excludeDirPath) => {\n        if (excludeDirName === 'node_modules') return true;\n        if (excludeDirName === '.dmno') return true;\n        // exclude directories - note as passed in, they do not have trailing slashes)\n        // but the dirPath does, so we must trailing slash\n        if (opts?.excludeDirs?.includes(excludeDirPath.replace(/\\/$/, ''))) return true;\n        return false;\n      })\n      .crawl(dirPath)\n      .withPromise()\n  );\n\n  const envVars: EnvVarsFromCode = {};\n  await asyncEachLimit(filesToSearch, async (filePath) => {\n    try {\n      const fileStat = await fs.promises.stat(filePath);\n      // we'll skip scanning files over 500kb for now... can probably even turn that way down\n      if (fileStat.size > 500 * 1000) return;\n\n      const contents = await fs.promises.readFile(filePath, 'utf-8');\n      const matches = contents.matchAll(ENV_VAR_REGEX);\n      if (!matches) return;\n\n      Array.from(matches).forEach((match) => {\n        const [_matchedString, globalName, varName] = match;\n        envVars[varName] ||= {};\n        envVars[varName][globalName] = true;\n      });\n    } catch (err) {\n      // fail silently for now\n      // console.log(err);\n    }\n  }, 10); // we'll do 10 files at a time, maybe could be higher?\n  return envVars;\n}\n\n","export const GITHUB_REPO_URL = 'https://github.com/dmno-dev/dmno';\nexport const DISCORD_INVITE_URL = 'https://chat.dmno.dev';\n","import fs from 'node:fs/promises';\nimport kleur from 'kleur';\nimport _ from 'lodash-es';\nimport { outdent } from 'outdent';\nimport { DmnoCommand } from '../lib/dmno-command';\nimport { formatError, formattedValue, getItemSummary } from '../lib/formatting';\nimport { getCliRunCtx } from '../lib/cli-ctx';\nimport { ConfigServer } from '../../config-loader/config-server';\nimport { addCacheFlags } from '../lib/cache-helpers';\nimport { addServiceSelection } from '../lib/selection-helpers';\nimport { fallingDmnoLoader, fallingDmnosAnimation } from '../lib/loaders';\nimport { pathExists } from '../../config-loader/find-services';\n\nconst program = new DmnoCommand('clear-cache')\n  .summary('cache utils')\n  .description(outdent`\n    Tools to clear / reset the cache\n\n    Also note many commands have \\`--skip-cache\\` and \\`--clear-cache\\` flags\n  `)\n  .example('dmno clear-cache', 'Clear the entire cache');\n  // .example('dmno cache clear -s web', 'Clear items from the cache used by the \"web\" service only');\n\n\n// addServiceSelection(program);\n\nprogram.action(async (opts, more) => {\n  const ctx = getCliRunCtx();\n  const workspace = await ctx.configLoader.getWorkspace();\n\n  if (!await pathExists(workspace.cacheFilePath)) {\n    console.log(' Workspace cache file already gone!\\n');\n    process.exit(0);\n  }\n\n\n  await fs.rm(workspace.cacheFilePath);\n  console.log(' Workspace cache file erased');\n  console.log(kleur.italic().gray(workspace.cacheFilePath));\n  console.log();\n\n  process.exit(0);\n});\n\nexport const ClearCacheCommand = program;\n","import kleur from 'kleur';\nimport _ from 'lodash-es';\nimport { DmnoCommand } from '../lib/dmno-command';\n\nimport { addServiceSelection } from '../lib/selection-helpers';\nimport { getCliRunCtx } from '../lib/cli-ctx';\nimport { addCacheFlags } from '../lib/cache-helpers';\nimport { addWatchMode } from '../lib/watch-mode-helpers';\nimport { CliExitError } from '../lib/cli-error';\nimport { checkForConfigErrors, checkForSchemaErrors } from '../lib/check-errors-helpers';\n\n\nconst program = new DmnoCommand('printenv')\n  .summary('Print a single config value')\n  .description('Resolves the config and then prints a single value')\n  .argument('<itemPath>')\n  .example('dmno printenv SOME_KEY', 'resolves config and prints the value of the single item');\n\naddWatchMode(program); // must be first\naddServiceSelection(program);\naddCacheFlags(program);\n\nprogram.action(async (itemPath: string, opts: {}, thisCommand) => {\n  const ctx = getCliRunCtx();\n\n  ctx.expectingOutput = true;\n\n  if (!ctx.selectedService) return; // error message already handled\n\n  const workspace = ctx.workspace!;\n  const service = ctx.selectedService;\n  checkForSchemaErrors(workspace);\n  await service.resolveConfig();\n  checkForConfigErrors(service);\n\n  // TODO: could be smarter about not caring about errors unless they affect the item(s) being printed\n  // TODO: support nested paths\n  // TODO: do we want to support multiple items?\n\n  if (!service.config[itemPath]) {\n    throw new CliExitError(`Config item ${itemPath} not found in config schema`, {\n      details: [\n        'Perhaps you meant one of:',\n        ..._.map(service.config, (val, key) => `${kleur.gray('-')} ${key}`),\n      ],\n    });\n  }\n\n\n  // TODO: what to do about formatting of arrays/objects/etc\n  // now just print the resolved value\n  ctx.logOutput(service.config[itemPath].resolvedValue);\n});\n\nexport const PrintEnvCommand = program;\n"]}