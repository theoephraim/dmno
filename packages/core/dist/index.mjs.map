{"version":3,"sources":["../src/config-engine/common-types.ts","../src/config-engine/resolvers/formula-resolver.ts","../src/config-engine/resolvers/switch-resolver.ts","../src/config-loader/config-server-client.ts"],"names":[],"mappings":"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","sourcesContent":["import { DmnoBaseTypes, createDmnoDataType } from './base-types';\nimport { ValidationError } from './errors';\n\nconst PG_REGEX = /(postgres(?:ql)?):\\/\\/(?:([^@\\s]+)@)?([^/\\s]+)(?:\\/(\\w+))?(?:\\?(.+))?/;\nconst postgresConnectionString = createDmnoDataType({\n  extends: 'string',\n  sensitive: true,\n  typeDescription: 'Postgres connection url',\n  externalDocs: {\n    description: 'explanation from prisma docs',\n    url: 'https://www.prisma.io/dataguide/postgresql/short-guides/connection-uris#a-quick-overview',\n  },\n  ui: {\n    icon: 'akar-icons:postgresql-fill',\n    color: '336791', // postgres brand color :)\n  },\n\n  validate(val, ctx) {\n    if (!PG_REGEX.test(val)) return new ValidationError('Invalid postgres connection url');\n  },\n});\n\n/**\n * Placeholder for a few vendor specific data types...\n * these will be extracted into separate modules!\n */\nexport const CommonDataTypes = {\n  postgresConnectionString,\n};\n","/* eslint-disable class-methods-use-this */\nimport { ResolverContext } from '../config-engine';\nimport { ConfigValueResolver, createResolver } from './resolvers';\n\nexport const dmnoFormula = (formula: string) => createResolver({\n  icon: 'gravity-ui:curly-brackets-function',\n  label: `formula: ${formula}`,\n  async resolve(ctx) {\n    return `${formula} = result`;\n  },\n});\n","/* eslint-disable class-methods-use-this */\nimport _ from 'lodash-es';\n\nimport {\n  InlineValueResolverDef, createResolver, processInlineResolverDef,\n} from './resolvers';\nimport { ResolverContext } from '../config-engine';\n\ntype SwitchByResolverOptions = Record<string, InlineValueResolverDef>;\n\nexport const switchBy = (switchByKey: string, branches: SwitchByResolverOptions) => {\n  return createResolver({\n    icon: 'gravity-ui:branches-right',\n    label: `switch by ${switchByKey}`,\n    resolveBranches: _.map(branches, (itemDef, itemKey) => ({\n      // TODO: do we want to use a special symbol? or pass default as different arg?\n      isDefault: itemKey === '_default' || itemKey === '_',\n      condition: (ctx: ResolverContext) => ctx.get(switchByKey) === itemKey,\n      id: itemKey,\n      label: `${switchByKey} === \"${itemKey}\"`,\n      resolver: processInlineResolverDef(itemDef),\n    })),\n  });\n};\n\nexport const switchByNodeEnv = (branches: SwitchByResolverOptions) => switchBy('NODE_ENV', branches);\nexport const switchByDmnoEnv = (branches: SwitchByResolverOptions) => switchBy('DMNO_ENV', branches);\n","import { ChildProcess, spawn } from 'node:child_process';\nimport ipc from 'node-ipc';\nimport mitt, { Handler } from 'mitt';\nimport Debug from 'debug';\n\nimport { DeferredPromise, createDeferredPromise } from '@dmno/ts-lib';\nimport { createDebugTimer } from '../cli/lib/debug-timer';\nimport { ConfigLoaderRequestMap } from './ipc-requests';\nimport { SerializedService } from './serialization-types';\nimport { formatError, getItemSummary } from '../cli/lib/formatting';\nimport { InjectedDmnoEnv } from '../config-engine/config-engine';\nimport { detectPackageManagerSync } from '../lib/detect-package-manager';\n\nconst debug = Debug('dmno');\nconst debugTimer = createDebugTimer('dmno:loader-client');\n\nfunction getCurrentPackageName() {\n  if (process.env.npm_package_name !== undefined) return process.env.npm_package_name;\n  if (process.env.PNPM_PACKAGE_NAME !== undefined) return process.env.PNPM_PACKAGE_NAME;\n}\n\n\nexport class ConfigServerClient {\n  eventBus = mitt();\n\n  readonly serverId: string;\n  private ipc: typeof ipc;\n  constructor() {\n    this.ipc = ipc;\n\n    if (process.env.DMNO_CONFIG_SERVER_UUID) {\n      this.serverId = process.env.DMNO_CONFIG_SERVER_UUID;\n    } else {\n      this.serverId = crypto.randomUUID();\n      this.initOwnedConfigServer();\n    }\n\n    this.initIpcClient();\n  }\n\n  private isShuttingDown = false;\n\n  shutdown() {\n    if (this.isShuttingDown) return;\n    this.isShuttingDown = true;\n    this.ipc.disconnect('dmno');\n    if (this.ownedDmnoConfigServerProcess) {\n      this.ownedDmnoConfigServerProcess.kill(2);\n    }\n  }\n\n  private ownedDmnoConfigServerProcess?: ChildProcess;\n  private initOwnedConfigServer() {\n    const { packageManager } = detectPackageManagerSync();\n\n    // use `pnpm exec` or `npm exec` etc...\n    this.ownedDmnoConfigServerProcess = spawn(packageManager, 'exec -- dmno dev --silent'.split(' '), {\n      stdio: 'inherit',\n      env: {\n        ...process.env,\n        DMNO_CONFIG_SERVER_UUID: this.serverId,\n        // PATH: process.env.PATH,\n      },\n    });\n    // console.log(this.ownedDmnoConfigServerProcess);\n\n    process.on('SIGTERM', () => {\n      // console.log('client process - sigterm!');\n      this.shutdown();\n    });\n\n    process.on('exit', () => {\n      // console.log('client process - exit!');\n      this.shutdown();\n    });\n\n    this.ownedDmnoConfigServerProcess.on('close', (code, signal) => {\n      // console.log('dmno config server - close');\n    });\n\n    this.ownedDmnoConfigServerProcess.on('disconnect', () => {\n      // console.log('dmno config server - disconnect');\n      // process.exit(1);\n    });\n\n    this.ownedDmnoConfigServerProcess.on('error', (err) => {\n      // console.log('dmno config server process -  error', err);\n      // process.exit(0);\n    });\n\n    this.ownedDmnoConfigServerProcess.on('exit', (code, signal) => {\n      // console.log('dmno config server process exit', code, signal);\n      if (!this.isShuttingDown) process.exit(code || 1);\n    });\n  }\n\n\n\n  private ipcReadyDeferred = createDeferredPromise();\n  private initIpcClient() {\n    this.ipc.config.id = 'dmno';\n    this.ipc.config.retry = 1500;\n    this.ipc.config.silent = true;\n\n    // we pass in a uuid to identify the running process IPC socket\n    // this allows us to run multiple concurrent loaders...\n    // TBD whether that makes sense or if we should share a single process?\n\n    debugTimer('begin ipc client connection');\n    this.ipc.connectTo('dmno', `/tmp/${this.serverId}.dmno.sock`, () => {\n      debugTimer('ipc client connectTo callback');\n\n      this.ipc.of.dmno.on('connect', () => {\n        debugTimer('ipc client connect event + emit ready');\n        this.ipc.log('## connected to dmno ##', this.ipc.config.retry);\n        this.ipc.of.dmno.emit('ready');\n        this.ipcReadyDeferred.resolve();\n      });\n\n      this.ipc.of.dmno.on('disconnect', () => {\n        this.ipc.log('disconnected from dmno');\n      });\n\n      this.ipc.of.dmno.on('event', (eventMessage) => {\n        // console.log('received IPC event message', eventMessage);\n        this.eventBus.emit(eventMessage.type, eventMessage.payload);\n      });\n\n      this.ipc.of.dmno.on('request-response', this.handleRequestResponse.bind(this));\n    });\n  }\n\n  // Tools for request/response communication with the loader proces\n  // by default IPC just lets us send messages. This tooling allows us to make \"requests\"\n  // and then receive a response - with type-safety throughout the process\n\n  private requestCounter = 1;\n  private requests = {} as Record<string, {\n    startedAt: Date,\n    deferredPromise: DeferredPromise\n  }>;\n\n  // TS magic here lets us auto-complete the available request types\n  // and have a typed payload and response :)\n  async makeRequest<K extends keyof ConfigLoaderRequestMap>(\n    key: K,\n\n    // some TS trickery to support passing no second arg when payload is undefined\n    // see https://minajevs.medium.com/how-to-make-function-parameters-optional-in-typescript-8cb4fa22171d\n    ...args: ConfigLoaderRequestMap[K]['payload'] extends undefined ? [] : [ConfigLoaderRequestMap[K]['payload']]\n  ): Promise<ConfigLoaderRequestMap[K]['response']> {\n    await this.ipcReadyDeferred.promise;\n    debug('making IPC request', key);\n\n    const payload = args?.[0];\n\n    // make sure IPC and the process is booted before we do anything\n    // await this.isReady;\n\n\n    // in order to make multiple concurrent requests, we create a \"request id\"\n    // and use it to match up the reply. We'll use a simple counter for now...\n    // we may want to add a random client id prefix too?\n    const requestId = this.requestCounter++;\n\n    this.requests[requestId] = {\n      startedAt: new Date(),\n      deferredPromise: createDeferredPromise(),\n    };\n\n    // TODO: we may want to store more metadata so we can handle things like timeouts?\n    ipc.of.dmno.emit('request', {\n      requestId,\n      requestType: key,\n      payload,\n    });\n\n    return this.requests[requestId].deferredPromise.promise as any;\n  }\n\n  /** internal method called when receiving a request response */\n  private handleRequestResponse(responseMessage: {\n    requestId: string,\n    response: any,\n    error?: any,\n  }) {\n    debug('handle req response', responseMessage);\n    const req = this.requests[responseMessage.requestId];\n    // we just look up the request using the requestId, and resolve the deffered\n    // promise with the response payload\n    if (!req) {\n      throw new Error(`IPC request not found: ${responseMessage.requestId}`);\n    }\n    if (responseMessage.error) {\n      const e = new Error(responseMessage.error.message);\n      e.stack = responseMessage.error.stack;\n      req.deferredPromise.reject(e);\n    } else {\n      req.deferredPromise.resolve(responseMessage.response);\n    }\n\n    const reqTimeMs = +new Date() - +req.startedAt;\n    debug(`request took ${reqTimeMs}ms`);\n\n    // clean up...?\n    delete this.requests[responseMessage.requestId];\n  }\n\n\n  async getServiceConfig() {\n    const packageName = getCurrentPackageName();\n    if (packageName === '') {\n      throw new Error('To use dmno, you must set a package \"name\" in your package.json file');\n    }\n    // what to do if we can't figure out a package name?\n\n    const serviceConfig = await this.makeRequest('get-resolved-config', { packageName });\n    return serviceConfig;\n  }\n\n  static checkServiceIsValid(service: SerializedService, log = true) {\n    if (service.configLoadError) {\n      console.log('ðŸš¨ ðŸš¨ ðŸš¨  unable to load config schema  ðŸš¨ ðŸš¨ ðŸš¨');\n      console.log(formatError(service.configLoadError));\n      return false;\n    }\n    // plugins!\n\n    if (service.schemaErrors?.length) {\n      console.log('ðŸš¨ ðŸš¨ ðŸš¨  config schema is invalid  ðŸš¨ ðŸš¨ ðŸš¨');\n      console.log(service.schemaErrors.forEach((err) => {\n        console.log(formatError(err));\n      }));\n      return false;\n    }\n\n    const failingItems = Object.values(service.config).filter((c) => !c.isValid);\n    if (failingItems.length) {\n      console.log('ðŸš¨ ðŸš¨ ðŸš¨  config is invalid  ðŸš¨ ðŸš¨ ðŸš¨');\n      failingItems.forEach((item) => {\n        console.log(getItemSummary(item));\n        console.log();\n      });\n      return false;\n    }\n\n    return true;\n  }\n}\n\nexport function serializedServiceToInjectedConfig(service: SerializedService): InjectedDmnoEnv {\n  const injectedEnv: InjectedDmnoEnv = {};\n  for (const itemKey in service.config) {\n    const configItem = service.config[itemKey];\n    injectedEnv[itemKey] = {\n      sensitive: !!configItem.dataType.sensitive,\n      dynamic: !!configItem.isDynamic,\n      value: configItem.resolvedValue,\n    };\n  }\n  return injectedEnv;\n}\n"]}