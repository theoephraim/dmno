{"version":3,"sources":["../../../node_modules/.pnpm/js-message@1.0.7/node_modules/js-message/Message.js","../../../node_modules/.pnpm/@node-ipc+js-queue@2.0.3/node_modules/@node-ipc/js-queue/queue.js","../src/config-engine/errors.ts","../src/config-engine/resolvers/resolvers.ts","../src/config-engine/config-engine.ts","../../encryption-lib/src/index.ts","../src/config-engine/base-types.ts","../src/lib/env-vars.ts","../src/lib/json-utils.ts","../src/lib/dotenv-utils.ts","../src/lib/exec-utils.ts","../src/lib/git-utils.ts","../src/lib/async-utils.ts","../src/config-engine/plugins.ts","../../../node_modules/.pnpm/@achrinza+node-ipc@10.1.10/node_modules/@achrinza/node-ipc/entities/Defaults.js","../../../node_modules/.pnpm/@achrinza+node-ipc@10.1.10/node_modules/@achrinza/node-ipc/dao/client.js","../../../node_modules/.pnpm/@achrinza+node-ipc@10.1.10/node_modules/@achrinza/node-ipc/entities/EventParser.js","../../../node_modules/.pnpm/@achrinza+strong-type@0.1.11/node_modules/@achrinza/strong-type/index.js","../../../node_modules/.pnpm/@achrinza+event-pubsub@5.0.9/node_modules/@achrinza/event-pubsub/index.js","../../../node_modules/.pnpm/@achrinza+node-ipc@10.1.10/node_modules/@achrinza/node-ipc/dao/socketServer.js","../../../node_modules/.pnpm/@achrinza+node-ipc@10.1.10/node_modules/@achrinza/node-ipc/services/IPC.js","../../../node_modules/.pnpm/@achrinza+node-ipc@10.1.10/node_modules/@achrinza/node-ipc/node-ipc.js","../src/cli/lib/debug-timer.ts","../src/cli/lib/formatting.ts","../src/lib/detect-package-manager.ts"],"names":["Message","Queue","_","fs","path","asyncMap","ConfigValueResolver","Debug","debug","configPath","log","net","tls","import_js_message","eventParser","emit","err","connect","UDPType","kleur"],"mappings":"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","sourcesContent":["function Message() {\r\n    Object.defineProperties(\r\n        this, {\r\n            data: {\r\n                enumerable: true,\r\n                get: getData,\r\n                set: setData\r\n            },\r\n            type: {\r\n                enumerable: true,\r\n                get: getType,\r\n                set: setType\r\n            },\r\n            load:{\r\n                enumerable:true,\r\n                writable:false,\r\n                value:parse\r\n            },\r\n            JSON: {\r\n                enumerable: true,\r\n                get: getJSON\r\n            }\r\n        }\r\n    );\r\n\r\n    var type = '';\r\n    var data = {};\r\n\r\n    function getType() {\r\n        return type;\r\n    }\r\n\r\n    function getData() {\r\n        return data;\r\n    }\r\n\r\n    function getJSON() {\r\n        return JSON.stringify(\r\n            {\r\n                type: type,\r\n                data: data\r\n            }\r\n        );\r\n    }\r\n\r\n    function setType(value) {\r\n        type = value;\r\n    }\r\n\r\n    function setData(value) {\r\n        data = value;\r\n    }\r\n\r\n    function parse(message){\r\n        try{\r\n            var message=JSON.parse(message);\r\n            type=message.type;\r\n            data=message.data;\r\n        }catch(err){\r\n            var badMessage=message;\r\n            type='error',\r\n            data={\r\n                message:'Invalid JSON response format',\r\n                err:err,\r\n                response:badMessage\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports=Message;\r\n","function Queue(asStack){\n    Object.defineProperties(\n        this,\n        {\n            add:{\n                enumerable:true,\n                writable:false,\n                value:addToQueue\n            },\n            next:{\n                enumerable:true,\n                writable:false,\n                value:run\n            },\n            clear:{\n                enumerable:true,\n                writable:false,\n                value:clearQueue\n            },\n            contents:{\n                enumerable:false,\n                get:getQueue,\n                set:setQueue\n            },\n            autoRun:{\n                enumerable:true,\n                writable:true,\n                value:true\n            },\n            stop:{\n                enumerable:true,\n                writable:true,\n                value:false\n            }\n        }\n    );\n\n    var queue=[];\n    var running=false;\n    var stop=false;\n\n    function clearQueue(){\n        queue=[];\n        return queue;\n    }\n\n    function getQueue(){\n        return queue;\n    }\n\n    function setQueue(val){\n        queue=val;\n        return queue;\n    }\n\n    function addToQueue(){\n        for(var i in arguments){\n            queue.push(arguments[i]);\n        }\n        if(!running && !this.stop && this.autoRun){\n            this.next();\n        }\n    }\n\n    function run(){\n        running=true;\n        if(queue.length<1 || this.stop){\n            running=false;\n            return;\n        }\n\n        queue.shift().bind(this)();\n    }\n}\n\nmodule.exports=Queue;\n","import kleur from 'kleur';\nimport _ from 'lodash-es';\n\nexport class DmnoError extends Error {\n  originalError?: Error;\n  get isUnexpected() { return !!this.originalError; }\n\n  icon = '❌';\n\n  constructor(err: string | Error) {\n    if (_.isError(err)) {\n      super(err.message);\n      this.originalError = err;\n      this.icon = '💥';\n    } else {\n      super(err);\n    }\n    this.name = this.constructor.name;\n  }\n\n  toJSON() {\n    return {\n      icon: this.icon,\n      type: this.name,\n      name: this.name,\n      message: this.message,\n      isUnexpected: this.isUnexpected,\n    };\n  }\n}\n\nexport class ConfigLoadError extends DmnoError {\n  readonly cleanedStack: Array<string>;\n  constructor(err: Error) {\n    super(err);\n\n    // remove first line since its the error message\n    let stackLines = (err.stack?.split('\\n') || []).slice(1);\n    stackLines = stackLines.filter((l) => {\n      // filter out unimportant lines related to just running/loading\n      // we could filter out more of dmno/core code once things stabilize\n      if (l.includes(' at ViteNodeRunner.')) return false;\n      if (l.includes('core/src/config-loader/config-loader.ts')) return false;\n      return true;\n    });\n\n\n    this.message = `${err.name}: ${err.message}`;\n\n\n\n    this.cleanedStack = stackLines || [];\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      cleanedStack: this.cleanedStack,\n    };\n  }\n}\nexport class SchemaError extends DmnoError {\n  icon = '🧰';\n}\nexport class ValidationError extends DmnoError {\n  icon = '❌';\n}\nexport class CoercionError extends DmnoError {\n  icon = '🛑';\n}\nexport class ResolutionError extends DmnoError {\n  icon = '⛔';\n}\n\nexport class EmptyRequiredValueError extends ValidationError {\n  icon = '❓';\n  constructor(_val: undefined | null | '') {\n    super('Value is required but is currently empty');\n  }\n}\n","/* eslint-disable class-methods-use-this */\nimport _ from 'lodash-es';\nimport {\n  DmnoConfigItemBase, ResolverContext,\n} from '../config-engine';\nimport { ResolutionError } from '../errors';\nimport { DmnoPlugin } from '../plugins';\nimport { SerializedResolver } from '../../config-loader/serialization-types';\n\n// TODO: do we allow Date?\n// what to do about null/undefined?\nexport type ConfigValue = string | number | boolean | null | { [key: string]: ConfigValue } | Array<ConfigValue>;\n\ntype ValueResolverResult = undefined | ConfigValue;\ntype ConfigValueInlineFunction =\n  (ctx: ResolverContext) => MaybePromise<ValueResolverResult>;\nexport type InlineValueResolverDef =\n  // static value\n  ConfigValue |\n  // resolver - ex: formula, fetch from vault, etc\n  ConfigValueResolver |\n  // inline function, which can return a value or another resolver\n  ConfigValueInlineFunction;\n\n\n\nexport type ConfigValueOverride = {\n  /** the value of the override */\n  value: ConfigValue;\n\n  /** comments about the item from the file */\n  comments?: string\n\n  // TODO: this will get more complex, as env files can be in different levels of the project\n  /** where does the value come from */\n  source: string;\n  /**\n   * some overrides apply only in certan envs, for example if coming from `.env.production` */\n  envFlag?: string;\n};\n\n\n\ntype ValueOrValueGetter<T> = T | ((ctx: ResolverContext) => T);\ntype MaybePromise<T> = T | Promise<T>;\n\ntype ResolverDefinition = {\n  /** reference back to the plugin which created the resolver (if applicable) */\n  createdByPlugin?: DmnoPlugin,\n  /** set a specific icon for the resolver, will default to the plugin's icon if set */\n  icon?: ValueOrValueGetter<string>,\n  /** label for the resolver */\n  label: ValueOrValueGetter<string>,\n  /**\n   * caching key for the final value\n   * this is just a convenience to avoid having to explicityl interact with the caching logic directly\n   * */\n  cacheKey?: ValueOrValueGetter<string>,\n} &\n({\n  resolve: (ctx: ResolverContext) => MaybePromise<ValueResolverResult>,\n} | {\n  resolveBranches: Array<ResolverBranch>\n});\n\nexport function createResolver(def: ResolverDefinition) {\n  return new ConfigValueResolver(def);\n}\n\n\n\n\ntype ResolverBranch = {\n  id: string,\n  label: string;\n  resolver: ConfigValueResolver;\n  condition: (ctx: ResolverContext) => boolean;\n  isDefault: boolean;\n  isActive?: boolean;\n};\n\nexport class ConfigValueResolver {\n  constructor(readonly def: ResolverDefinition) {\n    // TODO: figure out this pattern... we'll have several bits of setings that\n    // are either static or need some basic resolution\n    if (_.isString(this.def.icon)) this.icon = this.def.icon;\n    if (_.isString(this.def.label)) this.label = this.def.label;\n\n    // link the branch resolvers back to their branch definition\n    // and to this parent resolver\n    // so they can access the branch path if needed\n    if ('resolveBranches' in this.def) {\n      _.each(this.def.resolveBranches, (branchDef) => {\n        branchDef.resolver.branchDef = branchDef;\n        branchDef.resolver.parentResolver = this;\n      });\n    }\n  }\n\n  isResolved = false;\n  resolvedValue?: ConfigValue;\n  isUsingCache = false;\n\n  resolutionError?: ResolutionError;\n\n  icon?: string;\n  label?: string;\n\n  private _configItem?: DmnoConfigItemBase;\n  set configItem(configItem: DmnoConfigItemBase | undefined) {\n    this._configItem = configItem;\n    if ('resolveBranches' in this.def) {\n      _.each(this.def.resolveBranches, (branch) => {\n        branch.resolver.configItem = configItem;\n      });\n    }\n  }\n  get configItem() {\n    return this._configItem;\n  }\n\n  parentResolver?: ConfigValueResolver;\n  branchDef?: ResolverBranch;\n\n  get branchIdPath(): string | undefined {\n    if (!this.branchDef) return undefined;\n    if (this.parentResolver) {\n      const parentBranchIdPath = this.parentResolver.branchIdPath;\n      if (parentBranchIdPath) {\n        return `${this.parentResolver.branchIdPath}/${this.branchDef.id}`;\n      }\n    }\n    return this.branchDef?.id;\n  }\n\n  getFullPath() {\n    return _.compact([\n      this.configItem?.getFullPath(),\n      this.branchIdPath,\n    ]).join('#');\n  }\n\n\n  async resolve(ctx: ResolverContext) {\n    if (_.isFunction(this.def.icon)) this.icon = this.def.icon(ctx);\n    if (_.isFunction(this.def.label)) this.label = this.def.label(ctx);\n\n    // optional cache key can be static or a fn\n    let cacheKey: string | undefined;\n    if (_.isString(this.def.cacheKey)) cacheKey = this.def.cacheKey;\n    else if (_.isFunction(this.def.cacheKey)) {\n      // TODO: should add error handling here\n      cacheKey = await this.def.cacheKey(ctx);\n    }\n    // if a cache key is set, we first check the cache and return that value if found\n    if (cacheKey) {\n      // console.log(kleur.bgMagenta(`CHECK VALUE CACHE FOR KEY: ${this.cacheKey}`));\n      const cachedValue = await ctx.getCacheItem(cacheKey);\n      if (cachedValue !== undefined) {\n        // console.log(kleur.bgMagenta('> USING CACHED VALUE!'));\n        this.resolvedValue = cachedValue;\n        this.isResolved = true;\n        this.isUsingCache = true;\n        return;\n      }\n    }\n\n    let resolutionResult: ConfigValueResolver | ValueResolverResult;\n\n    // deal with branched case (ex: switch / if-else)\n    if ('resolveBranches' in this.def) {\n      // find first branch that passes\n      let matchingBranch = _.find(this.def.resolveBranches, (branch) => {\n        if (branch.isDefault) return false;\n        return branch.condition(ctx);\n      });\n      if (!matchingBranch) {\n        matchingBranch = _.find(this.def.resolveBranches, (branch) => branch.isDefault);\n      }\n\n      _.each(this.def.resolveBranches, (branch) => {\n        branch.isActive = branch === matchingBranch;\n      });\n\n      // TODO: might be able to force a default to be defined?\n      if (!matchingBranch) {\n        throw new Error('no matching resolver branch found and no default');\n      }\n      resolutionResult = matchingBranch.resolver || undefined;\n\n    // deal with normal case\n    } else {\n      // actually call the resolver\n      try {\n        resolutionResult = await this.def.resolve(ctx);\n      } catch (err) {\n        if (err instanceof ResolutionError) {\n          this.resolutionError = err;\n        } else {\n          this.resolutionError = new ResolutionError(err as Error);\n        }\n        this.isResolved = false;\n        return;\n      }\n    }\n\n    // if the result of resolution was another resolver, now we need to call that one\n    if (resolutionResult instanceof ConfigValueResolver) {\n      // resolutionResult is now a child resolver which must be resolved itself\n      // NOTE we have to call this recursively so that caching can be triggered on each resolver\n      const childCtx = new ResolverContext(resolutionResult);\n      await resolutionResult.resolve(childCtx);\n      this.resolvedValue = resolutionResult.resolvedValue;\n      // TODO: deal with errors - and need to bubble them up...?\n    } else {\n      // what if the result is undefined?\n      this.resolvedValue = resolutionResult;\n    }\n\n    this.isResolved = true;\n\n    // save result in cache if this resolver has a cache key\n    if (cacheKey && this.resolvedValue !== undefined && this.resolvedValue !== null) {\n      // console.log(kleur.bgMagenta(`SAVE CACHED VALUE IN KEY: ${this.cacheKey}`));\n      await ctx.setCacheItem(cacheKey, this.resolvedValue);\n    }\n  }\n\n  toJSON(): SerializedResolver {\n    return {\n      isResolved: this.isResolved,\n      icon: this.icon,\n      label: this.label,\n      createdByPluginInstanceName: this.def.createdByPlugin?.instanceName,\n      // itemPath: this.configItem?.getFullPath(),\n      // branchIdPath: this.branchIdPath,\n      ...'resolveBranches' in this.def && {\n        branches: _.map(this.def.resolveBranches, (b) => ({\n          id: b.id,\n          label: b.label,\n          isDefault: b.isDefault,\n          isActive: b.isActive,\n          resolver: b.resolver.toJSON(),\n        })),\n      },\n      resolvedValue: this.resolvedValue,\n      resolutionError: this.resolutionError?.toJSON(),\n    };\n  }\n}\n\nexport function processInlineResolverDef(resolverDef: InlineValueResolverDef) {\n  // set up value resolver\n\n  // inline function case\n  if (_.isFunction(resolverDef)) {\n    return createResolver({\n      icon: 'f7:function',\n      label: 'fn',\n      resolve: resolverDef,\n    });\n\n  // already a resolver case\n  } else if (resolverDef instanceof ConfigValueResolver) {\n    return resolverDef;\n\n  // static value case\n  } else if (resolverDef !== undefined) {\n    return createResolver({\n      icon: 'material-symbols:check-circle',\n      label: 'static',\n      resolve: async () => resolverDef,\n    });\n  } else {\n    throw new Error('invalid resolver definition');\n  }\n}\n\n/**\n * helper fn to add caching to a value resolver that does not have it built-in\n * for example, a fn that generates a random number / key\n * */\nexport function cacheFunctionResult(resolverFn: ConfigValueInlineFunction): ConfigValueResolver;\nexport function cacheFunctionResult(cacheKey: string, resolverFn: ConfigValueInlineFunction): ConfigValueResolver;\nexport function cacheFunctionResult(\n  cacheKeyOrResolverFn: string | ConfigValueInlineFunction,\n  resolverFn?: ConfigValueInlineFunction,\n): ConfigValueResolver {\n  const explicitCacheKey = _.isString(cacheKeyOrResolverFn) ? cacheKeyOrResolverFn : undefined;\n  const fn = _.isString(cacheKeyOrResolverFn) ? resolverFn! : cacheKeyOrResolverFn;\n\n  return createResolver({\n    icon: 'f7:function', // TODO: different fn for cached?\n    label: 'cached fn',\n    cacheKey: explicitCacheKey || ((ctx) => ctx.resolverFullPath),\n    resolve: fn,\n  });\n}\n\n\n\n// export class DeferredDeploymentResolver extends ConfigValueResolver {\n//   icon = 'radix-icons:component-placeholder';\n//   getPreviewLabel() {\n//     return 'generated during deployment';\n//   }\n//   async _resolve(ctx: ResolverContext) {\n//     return 'resolved by deployment process';\n//   }\n// }\n// export const valueCreatedDuringDeployment = () => new DeferredDeploymentResolver();\n\n\nexport function createdPickedValueResolver(sourceItem: DmnoConfigItemBase, valueTransform?: ((val: any) => any)) {\n  return createResolver({\n    icon: 'material-symbols:content-copy-outline-sharp',\n    label: 'picked value',\n    async resolve(ctx) {\n      // since we handle resolution of services in the right order\n      // we can assume the picked value will be resolved already (if it was possible at all)\n      if (!sourceItem.isResolved) {\n        return new Error('picked value has not been resolved yet');\n      }\n      if (valueTransform) {\n        return valueTransform(sourceItem.resolvedValue);\n      } else {\n        return sourceItem.resolvedValue;\n      }\n    },\n  });\n}\n\n","import fs from 'node:fs';\nimport path from 'node:path';\nimport crypto from 'node:crypto';\nimport { execSync } from 'node:child_process';\nimport _ from 'lodash-es';\nimport Debug from 'debug';\nimport validatePackageName from 'validate-npm-package-name';\nimport graphlib from '@dagrejs/graphlib';\nimport {\n  decrypt, encrypt, generateDmnoEncryptionKeyString, generateEncryptionKeyString, importDmnoEncryptionKeyString,\n} from '@dmno/encryption-lib';\n\nimport { parse as parseJSONC } from 'jsonc-parser';\nimport {\n  DmnoBaseTypes, DmnoDataType, DmnoSimpleBaseTypeNames,\n} from './base-types';\nimport {\n  ConfigValue,\n  InlineValueResolverDef, ConfigValueOverride, ConfigValueResolver, createdPickedValueResolver,\n} from './resolvers/resolvers';\nimport { getConfigFromEnvVars } from '../lib/env-vars';\nimport { SerializedConfigItem, SerializedService, SerializedWorkspace } from '../config-loader/serialization-types';\nimport {\n  CoercionError, ConfigLoadError, ResolutionError, SchemaError, ValidationError,\n} from './errors';\nimport { DmnoPlugin } from './plugins';\nimport { stringifyJsonWithCommentBanner } from '../lib/json-utils';\nimport { loadDotEnvIntoObject, loadServiceDotEnvFiles } from '../lib/dotenv-utils';\nimport { asyncMapValues } from '../lib/async-utils';\n\nconst debug = Debug('dmno');\n\ntype ConfigRequiredAtTypes = 'build' | 'boot' | 'run' | 'deploy';\nexport type CacheMode = 'skip' | 'clear' | true;\n\ntype ConfigContext = {\n  get: (key: string) => any;\n};\ntype ValueOrValueFromContextFn<T> = T | ((ctx: ConfigContext) => T);\n\n// items (and types) can extend other types by either specifying\n// - another type that was initialized - ex: `DmnoBaseTypes.string({ ... })`\n// - another type that was not initialized - ex: `DmnoBaseTypes.string`\n// - string label for a small subset of simple base types - ex: `'string'`\nexport type TypeExtendsDefinition<TypeSettings = any> =\n  DmnoDataType |\n  DmnoSimpleBaseTypeNames |\n  (() => DmnoDataType) |\n  ((opts: TypeSettings) => DmnoDataType);\n\n\n\nexport type TypeValidationResult = boolean | undefined | void | Error | Array<Error>;\n\n/**\n * options for defining an individual config item\n * @category HelperMethods\n */\n\nexport type ConfigItemDefinition<ExtendsTypeSettings = any> = {\n  /** short description of what this config item is for */\n  summary?: string;\n  /** longer description info including details, gotchas, etc... supports markdown  */\n  description?: string;\n  /** expose this item to be \"pick\"ed by other services, usually used for outputs of run/deploy */\n  expose?: boolean;\n\n  /** description of the data type itself, rather than the instance */\n  typeDescription?: string;\n\n  /** example value */\n  exampleValue?: any;\n\n  /** link to external documentation */\n  externalDocs?: {\n    description?: string,\n    url: string,\n  };\n\n  /** dmno config ui specific options */\n  ui?: {\n    /** icon to use, see https://icones.js.org/ for available options\n    * @example mdi:aws\n    */\n    icon?: string;\n\n    /** color (any valid css color)\n    * @example FF0000\n    */\n    color?: string;\n  };\n\n  /** whether this config is sensitive and must be kept secret */\n  sensitive?: boolean; // TODO: can this be a (ctx) => fn?\n\n  /** is this config item required, an error will be shown if empty */\n  required?: boolean; // TODO: can this be a (ctx) => fn?\n\n  /** at what time is this value required */\n  useAt?: ConfigRequiredAtTypes | Array<ConfigRequiredAtTypes>;\n\n  /** opt in/out of build-type code replacements - default is false unless changed at the service level */\n  dynamic?: boolean;\n\n  // we allow the fn that returns the data type so you can use the data type without calling the empty initializer\n  // ie `DmnoBaseTypes.string` instead of `DmnoBaseTypes.string({})`;\n  /** the type the item is based, can be a DmnoBaseType or something custom */\n  extends?: TypeExtendsDefinition<ExtendsTypeSettings>;\n\n  /** a validation function for the value, return true if valid, otherwise throw an error */\n  validate?: ((val: any, ctx: ResolverContext) => TypeValidationResult);\n  /** same as \\`validate\\` but async */\n  asyncValidate?: ((val: any, ctx: ResolverContext) => Promise<TypeValidationResult>);\n  /** a function to coerce values */\n  coerce?: ((val: any, ctx: ResolverContext) => any);\n\n  /** set the value, can be static, or a function, or use helpers */\n  value?: InlineValueResolverDef;\n\n  /** import value a env variable with a different name */\n  importEnvKey?: string;\n  /** export value as env variable with a different name */\n  exportEnvKey?: string;\n};\n\ntype PickConfigItemDefinition = {\n  /** which service to pick from, defaults to \"root\" */\n  source?: string;\n  /** key(s) to pick, or function that matches against all keys from source */\n  key: string | Array<string> | ((key: string) => boolean),\n\n  /** new key name or function to rename key(s) */\n  renameKey?: string | ((key: string) => string),\n\n  /** function to transform value(s) */\n  transformValue?: (value: any) => any,\n\n  // TOOD: also allow setting the value (not transforming)\n  // value?: use same value type as above\n};\n\ntype ConfigItemDefinitionOrShorthand = ConfigItemDefinition | TypeExtendsDefinition;\n\n\ntype DynamicConfigModes =\n  /* non-sensitive = static, sensitive = dynamic (this is the default) */\n  'public_static' |\n  /* everything static, dynamic not supported */\n  'only_static' |\n  /* everything dynamic, static not supported */\n  'only_dynamic' |\n  /* default is static */\n  'default_static' |\n  /* default_dynamic */\n  'default_dynamic';\n\n/**\n * options for defining a service's config schema\n * @category HelperMethods\n */\nexport type DmnoWorkspaceConfig = {\n  /** root service name, if empty will fallback to name from package.json */\n  name?: string,\n  /** settings for the root service - children will be inherit individual settings unless overridden */\n  settings?: DmnoServiceSettings,\n  /** config schema items that live in the workspace root */\n  schema: Record<string, ConfigItemDefinitionOrShorthand>,\n};\n\n\ntype DmnoServiceSettings = {\n  /** default behaviour for \"dynamic\" vs \"static\" behaviour of config items */\n  dynamicConfig?: DynamicConfigModes,\n};\n\n/**\n * options for defining a service's config schema\n * @category HelperMethods\n */\nexport type DmnoServiceConfig = {\n  /** service name - if empty, name from package.json will be used */\n  name?: string,\n  /** name of parent service (if applicable) - if empty this service will be a child of the root service */\n  parent?: string,\n  /** optional array of \"tags\" for the service */\n  tags?: Array<string>,\n  /** settings for this service - each item will be inherited from parent(s) if unspecified */\n  settings?: DmnoServiceSettings,\n  /** array of config items to be picked from parent */\n  pick?: Array<PickConfigItemDefinition | string>,\n  /** the config schema itself */\n  schema: Record<string, ConfigItemDefinitionOrShorthand>,\n};\n\n\n\n\nexport type InjectedDmnoEnvItem = {\n  value: any,\n  sensitive?: boolean | 1 | '1',\n  dynamic?: boolean | 1 | '1',\n};\nexport type InjectedDmnoEnv = Record<string, InjectedDmnoEnvItem>;\n\n\n\nexport function defineDmnoService(opts: DmnoServiceConfig) {\n  debug('LOADING SCHEMA!', opts);\n  // we'll mark the object so we know it was initialized via defineDmnoWorkspace\n  (opts as any)._isDmnoServiceConfig = true;\n  return opts;\n}\n\nexport function defineDmnoWorkspace(opts: DmnoWorkspaceConfig) {\n  debug('LOADING ROOT SCHEMA!', opts);\n  // we'll mark the object so we know it was initialized via defineDmnoWorkspace\n  (opts as any)._isDmnoWorkspaceConfig = true;\n  return opts;\n}\n\n// config item keys are all checked against this regex\n// currently it must start with a letter (to make it a valid js property)\n// and can only contain letters, number, and underscore\n// we may want to restrict \"__\" if we use that as the nesting separator for env var overrides?\nconst VALID_ITEM_KEY_REGEX = /^[a-z]\\w+$/i;\n\nexport class ConfigPath {\n  constructor(readonly path: string) { }\n}\nexport const configPath = (path: string) => new ConfigPath(path);\n\n\ntype SerializedCacheEntry = {\n  updatedAt: string,\n  encryptedValue: string;\n  usedByItems: Array<string>;\n};\ntype SerializedCache = {\n  version: string;\n  keyName: string;\n  items: Record<string, SerializedCacheEntry>;\n};\ntype SerializedCacheKey = {\n  version: string;\n  key: string;\n};\nclass CacheEntry {\n  readonly usedByItems: Set<string>;\n  readonly updatedAt: Date;\n  readonly encryptedValue?: string;\n\n  constructor(\n    readonly key: string,\n    readonly value: any,\n    more?: {\n      encryptedValue?: string,\n      usedBy?: string | Array<string>,\n      updatedAt?: Date,\n    },\n  ) {\n    this.updatedAt = more?.updatedAt || new Date();\n    this.usedByItems = new Set(_.castArray(more?.usedBy || []));\n    // we store the value passed rather than recalculating so the cache file won't churn\n    this.encryptedValue = more?.encryptedValue;\n  }\n  async getEncryptedValue() {\n    return encrypt(CacheEntry.encryptionKey, this.value, CacheEntry.encryptionKeyName);\n  }\n  // have to make this async because of the encryption call\n  async getJSON(): Promise<SerializedCacheEntry> {\n    return {\n      encryptedValue: this.encryptedValue || await this.getEncryptedValue(),\n      updatedAt: this.updatedAt.toISOString(),\n      usedByItems: Array.from(this.usedByItems),\n    };\n  }\n\n  static async fromSerialized(itemKey: string, raw: SerializedCacheEntry) {\n    // currently this setup means the encryptedValue changes on every run...\n    // we could instead store the encryptedValue and reuse it if it has not changed\n    const value = await decrypt(CacheEntry.encryptionKey, raw.encryptedValue, CacheEntry.encryptionKeyName);\n    // we are also tossing out the saved \"usedBy\" entries since we'll have new ones after this config run\n    return new CacheEntry(itemKey, value, {\n      updatedAt: new Date(raw.updatedAt),\n      encryptedValue: raw.encryptedValue,\n    });\n  }\n\n  // not sure about this... but for now it seems true that we'll use a single key at a time\n  static encryptionKey: crypto.webcrypto.CryptoKey;\n  static encryptionKeyName: string;\n}\n\ntype NestedOverrideObj<T = string> = {\n  [key: string]: NestedOverrideObj<T> | T;\n};\n\nexport class OverrideSource {\n  constructor(\n    readonly type: string,\n    private values: NestedOverrideObj,\n    readonly enabled = true,\n  ) {}\n\n  /** get an env var override value using a dot notation path */\n  getOverrideForPath(path: string) {\n    return _.get(this.values, path);\n  }\n}\n\n\n\nexport class DmnoWorkspace {\n  private services: Record<string, DmnoService> = {};\n  private servicesArray: Array<DmnoService> = [];\n  private servicesByPackageName: Record<string, DmnoService> = {};\n\n  private rootServiceName = 'root';\n  get rootService() { return this.services[this.rootServiceName]; }\n  get rootPath() { return this.rootService.path; }\n\n  readonly processEnvOverrides = new OverrideSource('process.env', getConfigFromEnvVars());\n\n  addService(service: DmnoService) {\n    if (this.services[service.serviceName]) {\n      // this should maybe be part of a workspace error rather than exploding?\n      throw new Error(`Service names must be unique - duplicate name detected \"${service.serviceName}\"`);\n    } else {\n      this.services[service.serviceName] = service;\n      this.servicesArray.push(service);\n      this.servicesByPackageName[service.packageName] = service;\n      if (service.isRoot) this.rootServiceName = service.serviceName;\n    }\n  }\n\n  private servicesDag = new graphlib.Graph({ directed: true });\n  initServicesDag() {\n    // initialize a services DAG\n    // note - we may want to experiment with \"compound nodes\" to have the services contain their config items as children?\n\n    for (const service of this.servicesArray) {\n      this.servicesDag.setNode(service.serviceName, { /* can add more metadata here */ });\n    }\n\n    // first set up graph edges based on \"parent\"\n    for (const service of this.servicesArray) {\n    // check if parent service is valid\n      const parentServiceName = service.rawConfig?.parent;\n      if (parentServiceName) {\n        if (!this.services[parentServiceName]) {\n          service.schemaErrors.push(new SchemaError(`Unable to find parent service \"${parentServiceName}\"`));\n        } else if (parentServiceName === service.serviceName) {\n          service.schemaErrors.push(new SchemaError('Cannot set parent to self'));\n        } else {\n        // creates a directed edge from parent to child\n          this.servicesDag.setEdge(parentServiceName, service.serviceName, { type: 'parent' });\n        }\n\n        // anything without an explicit parent set is a child of the root\n      } else if (!service.isRoot) {\n        this.servicesDag.setEdge(this.rootServiceName, service.serviceName, { type: 'parent' });\n      }\n    }\n\n    // add graph edges based on \"pick\"\n    // we will not process individual items yet, but this will give us a DAG of service dependencies\n    for (const service of this.servicesArray) {\n      // eslint-disable-next-line @typescript-eslint/no-loop-func\n      _.each(service.rawConfig?.pick, (rawPick) => {\n      // pick defaults to picking from \"root\" unless otherwise specified\n        const pickFromServiceName = _.isString(rawPick)\n          ? this.rootServiceName\n          : (rawPick.source || this.rootServiceName);\n        if (!this.services[pickFromServiceName]) {\n          service.schemaErrors.push(new SchemaError(`Invalid service name in \"pick\" config - \"${pickFromServiceName}\"`));\n        } else if (pickFromServiceName === service.serviceName) {\n          service.schemaErrors.push(new SchemaError('Cannot \"pick\" from self'));\n        } else {\n        // create directed edge from service output feeding into this one (ex: database feeeds DB_URL into api )\n          this.servicesDag.setEdge(pickFromServiceName, service.serviceName, { type: 'pick' });\n        }\n      });\n    }\n\n    // look for cycles in the services graph, add schema errors if present\n    const graphCycles = graphlib.alg.findCycles(this.servicesDag);\n    _.each(graphCycles, (cycleMemberNames) => {\n    // each cycle is just an array of node names in the cycle\n      _.each(cycleMemberNames, (name) => {\n        this.services[name].schemaErrors.push(new SchemaError(`Detected service dependency cycle - ${cycleMemberNames.join(' + ')}`));\n      });\n    });\n\n    // if no cycles were found in the services graph, we use a topological sort to get the right order to continue loading config\n    if (!graphCycles.length) {\n      const sortedServiceNames = graphlib.alg.topsort(this.servicesDag);\n      // we'll sort the services array into dependency order\n      this.servicesArray = _.map(sortedServiceNames, (serviceName) => this.services[serviceName]);\n      debug('DEP SORTED SERVICES', sortedServiceNames);\n    }\n  }\n  processConfig() {\n    for (const service of this.servicesArray) {\n      const ancestorServiceNames = this.servicesDag.predecessors(service.serviceName) || [];\n\n      // process \"picked\" items\n      for (const rawPickItem of service.rawConfig?.pick || []) {\n        const pickFromServiceName = _.isString(rawPickItem)\n          ? this.rootServiceName\n          : (rawPickItem.source || this.rootServiceName);\n        const isPickingFromAncestor = ancestorServiceNames.includes(pickFromServiceName);\n        const rawPickKey = _.isString(rawPickItem) ? rawPickItem : rawPickItem.key;\n        const pickFromService = this.services[pickFromServiceName];\n        if (!pickFromService) {\n          // NOTE: we've already added a schema error if item is picking from an non-existant service\n          // while setting up the services DAG, so we can just bail on the item\n          continue;\n        }\n\n        // first we'll gather a list of the possible keys we can pick from\n        // when picking from an ancestor, we pick from all config items\n        // while non-ancestors expose only items that have `expose: true` set on them\n        const potentialKeysToPickFrom: Array<string> = [];\n\n        if (isPickingFromAncestor) {\n          potentialKeysToPickFrom.push(..._.keys(pickFromService.config));\n        } else {\n          // whereas only \"exposed\" items can be picked from non-ancestors\n          const exposedItems = _.pickBy(pickFromService.config, (itemConfig) => !!itemConfig.type.getDefItem('expose'));\n          potentialKeysToPickFrom.push(..._.keys(exposedItems));\n        }\n\n        const keysToPick: Array<string> = [];\n\n        // if key is a string or array of strings, we'll need to check they are valid\n        if (_.isString(rawPickKey) || _.isArray(rawPickKey)) {\n          for (const keyToCheck of _.castArray(rawPickKey)) {\n            if (!potentialKeysToPickFrom.includes(keyToCheck)) {\n              // TODO: we could include if the key exists but is not marked to \"expose\"?\n              service.schemaErrors.push(new SchemaError(`Picked item ${pickFromServiceName} > ${keyToCheck} was not found`));\n            } else {\n              keysToPick.push(keyToCheck);\n            }\n          }\n\n        // if it's a function, we'll be filtering from the list of potential items\n        } else if (_.isFunction(rawPickKey)) { // fn that filters keys\n          const pickKeysViaFilter = _.filter(potentialKeysToPickFrom, rawPickKey);\n\n          // we probably want to warn the user if the filter selected nothing?\n          if (!pickKeysViaFilter.length) {\n            // TODO: we may want to mark this error as a \"warning\" or something?\n            // or some other way of configuring / ignoring\n            service.schemaErrors.push(new SchemaError(`Pick from ${pickFromServiceName} using key filter fn had no matches`));\n          } else {\n            keysToPick.push(...pickKeysViaFilter);\n            // console.log('pick keys by filter', pickKeysViaFilter);\n          }\n        }\n\n        for (let i = 0; i < keysToPick.length; i++) {\n          const pickKey = keysToPick[i];\n          // deal with key renaming\n          let newKeyName = pickKey;\n          if (!_.isString(rawPickItem) && rawPickItem.renameKey) {\n            // renameKey can be a static string (if dealing with a single key)\n            if (_.isString(rawPickItem.renameKey)) {\n              // deal with the case of trying to rename multiple keys to a single value\n              // TODO: might be able to discourage this in the TS typing?\n              if (keysToPick.length > 1) {\n                // add an error (once)\n                if (i === 0) {\n                  service.schemaErrors.push(new SchemaError(`Picked multiple keys from ${pickFromServiceName} using static rename`));\n                }\n                // add an index suffix... so the items will at least still appear\n                newKeyName = `${rawPickItem.renameKey}-${i}`;\n              } else {\n                newKeyName = rawPickItem.renameKey;\n              }\n\n            // or a function to transform the existing key\n            } else {\n              newKeyName = rawPickItem.renameKey(pickKey);\n            }\n          }\n\n          service.addConfigItem(new DmnoPickedConfigItem(newKeyName, {\n            sourceItem: pickFromService.config[pickKey],\n            transformValue: _.isString(rawPickItem) ? undefined : rawPickItem.transformValue,\n          }, service));\n          // TODO: add to dag node with link to source item\n        }\n      }\n\n      // process the regular config schema items\n      for (const itemKey in service.rawConfig?.schema) {\n        if (!itemKey.match(VALID_ITEM_KEY_REGEX)) {\n          service.schemaErrors.push(new SchemaError(`Invalid item key \"${itemKey}\"`));\n        } else {\n          const itemDef = service.rawConfig?.schema[itemKey];\n          service.addConfigItem(new DmnoConfigItem(itemKey, itemDef, service));\n        }\n\n        // TODO: add dag node\n      }\n    }\n  }\n  async resolveConfig() {\n    await this.loadCache();\n    // servicesArray is already sorted by dependencies\n    for (const service of this.servicesArray) {\n      if (service.schemaErrors.length) {\n        debug(`SERVICE ${service.serviceName} has schema errors: `);\n        debug(service.schemaErrors);\n      } else {\n        await service.resolveConfig();\n      }\n    }\n    await this.writeCache();\n  }\n\n  get allServices() {\n    return this.servicesArray;\n  }\n\n  getService(descriptor: string | { serviceName?: string, packageName?: string }) {\n    if (_.isString(descriptor)) {\n      return this.services[descriptor];\n    } else {\n      if (descriptor.serviceName) return this.services[descriptor.serviceName];\n      if (descriptor.packageName) return this.servicesByPackageName[descriptor.packageName];\n    }\n    throw new Error(`unable to find service - ${descriptor}`);\n  }\n\n  get cacheFilePath() { return `${this.rootPath}/.dmno/cache.json`; }\n  get cacheKeyFilePath() { return `${this.rootPath}/.dmno/cache-key.json`; }\n  private valueCache: Record<string, CacheEntry> = {};\n  private cacheLastLoadedAt: Date | undefined;\n  private cacheMode: CacheMode = true;\n  setCacheMode(cacheMode: typeof this.cacheMode) {\n    this.cacheMode = cacheMode;\n  }\n  private async loadCache() {\n    if (this.cacheMode === 'skip') return;\n    // might want to attach the CacheEntry to the workspace instead to get the key?\n    // or we could always pass it around as needed\n\n    // currently we are creating a cache key automatically if one does not exist\n    // is that what we want to do? or have the user take more manual steps? not sure\n    if (!fs.existsSync(this.cacheKeyFilePath)) {\n      let keyName: string;\n      try {\n        const gitUserEmail = execSync('git config user.email').toString().trim();\n        keyName = `${gitUserEmail}/${new Date().toISOString()}`;\n      } catch (err) {}\n      // when running in CI or elsewhere we wont have a git username so we fallback to something else\n      keyName ||= `${process.env.NODE_ENV}/${new Date().toISOString()}`;\n      const dmnoKeyStr = await generateDmnoEncryptionKeyString(keyName);\n\n      const reimportedDmnoKey = await importDmnoEncryptionKeyString(dmnoKeyStr);\n      if (reimportedDmnoKey.keyName !== keyName) throw new Error('reimported key name doesnt match');\n      CacheEntry.encryptionKey = reimportedDmnoKey.key;\n      CacheEntry.encryptionKeyName = keyName;\n\n      const cacheKeyData: SerializedCacheKey = {\n        version: '0.0.1',\n        key: dmnoKeyStr,\n      };\n      await fs.promises.writeFile(this.cacheKeyFilePath, stringifyJsonWithCommentBanner(cacheKeyData));\n\n      if (fs.existsSync(this.cacheFilePath)) {\n        // destroy the cache file, since it will not match the new key...\n        // should we confirm this with the user? probably doesn't matter?\n        await fs.promises.unlink(this.cacheFilePath);\n      }\n    } else {\n      const cacheKeyRawStr = await fs.promises.readFile(this.cacheKeyFilePath, 'utf-8');\n      const cacheKeyRaw = parseJSONC(cacheKeyRawStr) as SerializedCacheKey;\n      const importedDmnoKey = await importDmnoEncryptionKeyString(cacheKeyRaw.key);\n      CacheEntry.encryptionKey = importedDmnoKey.key;\n      CacheEntry.encryptionKeyName = importedDmnoKey.keyName;\n    }\n\n    if (this.cacheMode === 'clear') return;\n    if (!fs.existsSync(this.cacheFilePath)) return;\n    const cacheRawStr = await fs.promises.readFile(this.cacheFilePath, 'utf-8');\n    const cacheRaw = parseJSONC(cacheRawStr) as SerializedCache;\n\n    // check if the ID in the cache file matches the cache key\n    if (CacheEntry.encryptionKeyName !== cacheRaw.keyName) {\n      throw new Error('DMNO cache file does not match cache key');\n    }\n\n    for (const itemCacheKey in cacheRaw.items) {\n      this.valueCache[itemCacheKey] = await CacheEntry.fromSerialized(itemCacheKey, cacheRaw.items[itemCacheKey]);\n    }\n    this.cacheLastLoadedAt = new Date();\n  }\n  private async writeCache() {\n    if (this.cacheMode === 'skip') return;\n    // we don't want to write a file if the cache has not changed because it will trigger vite to reload\n    if (this.cacheLastLoadedAt && _.every(this.valueCache, (item) => item.updatedAt < this.cacheLastLoadedAt!)) {\n      return;\n    }\n\n    const serializedCache: SerializedCache = {\n      version: '0.0.1',\n      keyName: CacheEntry.encryptionKeyName,\n      items: await asyncMapValues(this.valueCache, async (cacheItem) => cacheItem.getJSON()),\n    };\n    const serializedCacheStr = stringifyJsonWithCommentBanner(serializedCache);\n    await fs.promises.writeFile(this.cacheFilePath, serializedCacheStr, 'utf-8');\n  }\n  async getCacheItem(key: string, usedBy?: string) {\n    if (this.cacheMode === 'skip') return undefined;\n    if (key in this.valueCache) {\n      if (usedBy) this.valueCache[key].usedByItems.add(usedBy);\n      return this.valueCache[key].value;\n    }\n  }\n  async setCacheItem(key: string, value: string, usedBy?: string) {\n    if (this.cacheMode === 'skip') return undefined;\n    this.valueCache[key] = new CacheEntry(key, value, { usedBy });\n  }\n\n  plugins: Record<string, DmnoPlugin> = {};\n\n  toJSON(): SerializedWorkspace {\n    return {\n      plugins: _.mapValues(this.plugins, (p) => p.toJSON()),\n      services: _.mapValues(\n        _.keyBy(this.services, (s) => s.serviceName),\n        (s) => s.toJSON(),\n      ),\n    };\n  }\n}\n\n\nexport class DmnoService {\n  /** name of service according to package.json file  */\n  readonly packageName: string;\n  /** name of service within dmno - pulled from config.ts but defaults to packageName if not provided  */\n  readonly serviceName: string;\n  /** true if service is root */\n  readonly isRoot: boolean;\n  /** path to the service itself */\n  readonly path: string;\n  /** unprocessed config schema pulled from config.ts */\n  readonly rawConfig?: DmnoServiceConfig;\n  /** error encountered while _loading_ the config schema */\n  readonly configLoadError?: ConfigLoadError;\n  /** error within the schema itself */\n  readonly schemaErrors: Array<SchemaError> = []; // TODO: probably want a specific error type...?\n\n  /** processed config items - not necessarily resolved yet */\n  readonly config: Record<string, DmnoConfigItem | DmnoPickedConfigItem> = {};\n\n  readonly workspace: DmnoWorkspace;\n\n  injectedPlugins: Array<DmnoPlugin> = [];\n  ownedPlugins: Array<DmnoPlugin> = [];\n\n  private settings: DmnoServiceSettings = {};\n\n  private overrideSources = [] as Array<OverrideSource>;\n\n  constructor(opts: {\n    packageName: string,\n    path: string,\n    workspace: DmnoWorkspace,\n  } & (\n    // TODO: this type difference should be applied to rawConfig too\n    // but they are currently close enough that it doesn't matter\n    { isRoot: true, rawConfig: DmnoWorkspaceConfig | ConfigLoadError, } |\n    { isRoot: false, rawConfig: DmnoServiceConfig | ConfigLoadError }\n  )) {\n    this.workspace = opts.workspace;\n    this.isRoot = opts.isRoot;\n    this.packageName = opts.packageName;\n    this.path = opts.path;\n\n    if (_.isError(opts.rawConfig)) {\n      this.serviceName = this.packageName;\n      this.configLoadError = opts.rawConfig;\n    } else {\n      // service name questions here:\n      // - default root to \"root\" instead of package name?\n      // - disallow renaming the root service?\n      // - stop naming a non-root service \"root\"?\n      this.rawConfig = opts.rawConfig;\n      this.settings = opts.rawConfig.settings || {};\n\n      if (this.rawConfig.name) {\n        const validateNameResult = validatePackageName(this.rawConfig.name);\n        if (!validateNameResult.validForNewPackages) {\n          const nameErrors = _.concat([], validateNameResult.warnings, validateNameResult.errors);\n          this.schemaErrors.push(new SchemaError(`Invalid service name \"${this.rawConfig.name}\" - ${nameErrors.join(', ')}`));\n        }\n        this.serviceName = this.rawConfig.name;\n      } else {\n        this.serviceName = opts.isRoot ? 'root' : this.packageName;\n      }\n    }\n  }\n\n  get parentService(): DmnoService | undefined {\n    if (this.rawConfig?.parent) {\n      const parent = this.workspace.getService({ serviceName: this.rawConfig?.parent });\n      if (parent) return parent;\n      throw new Error(`Unable to find parent service: ${this.rawConfig.parent}`);\n    }\n  }\n\n  getSettingsItem<K extends keyof DmnoServiceSettings>(key: K): DmnoServiceSettings[K] | undefined {\n    if (key in this.settings) return this.settings[key];\n    return this.parentService?.getSettingsItem(key);\n  }\n\n  addConfigItem(item: DmnoConfigItem | DmnoPickedConfigItem) {\n    if (item instanceof DmnoPickedConfigItem && this.rawConfig?.schema[item.key]) {\n      // check if a picked item is conflicting with a regular item\n      this.schemaErrors.push(new SchemaError(`Picked config key conflicting with a locally defined item - \"${item.key}\"`));\n    } else if (this.config[item.key]) {\n      // TODO: not sure if we want to add the item anyway under a different key?\n      // probably want to expose more info too\n      this.schemaErrors.push(new SchemaError(`Config keys must be unique, duplicate detected - \"${item.key}\"`));\n    } else {\n      this.config[item.key] = item;\n    }\n  }\n\n  async loadOverrideFiles() {\n    this.overrideSources = [];\n\n    // TODO: this is not at all optimized for speed...\n    // particularly it is doing a check on if the file is gitignored\n    // and if we are loading not in dev mode, we may just want to load files that will be applied\n    const dotEnvFiles = await loadServiceDotEnvFiles(this.path, { onlyLoadDmnoFolder: true });\n\n    dotEnvFiles.forEach((dotEnvFile) => {\n      this.overrideSources.unshift(\n        new OverrideSource(\n          dotEnvFile.fileName,\n          dotEnvFile.envObj,\n          // TODO: specific env overrides are being enabled based on process.env.NODE_ENV\n          // we probably want to be smarter about how _that_ gets resolved first\n          // and store it at the workspace level or something...?\n          !dotEnvFile.applyForEnv || dotEnvFile.applyForEnv === process.env.NODE_ENV,\n        ),\n      );\n    });\n\n    // load multiple override files\n    // .env.{ENV}.local\n    // .env.local\n    // .env.{ENV}\n    // .env\n\n    // TODO: support other formats (yaml, toml, json) - probably should all be through a plugin system\n  }\n\n  async resolveConfig() {\n    await this.loadOverrideFiles();\n\n    for (const itemKey in this.config) {\n      const configItem = this.config[itemKey];\n      const itemPath = configItem.getPath(true);\n\n\n\n      // reset overrides\n      configItem.overrides = [];\n      // set override from environment (process.env)\n      _.each([\n        // process.env overrides exist at the workspace root\n        this.workspace.processEnvOverrides,\n        // other override sources - (just env files for now)\n        ...this.overrideSources.filter((o) => o.enabled),\n      ], (overrideSource) => {\n        const overrideVal = overrideSource.getOverrideForPath(itemPath);\n        if (overrideVal !== undefined) {\n          // TODO: deal with nested items\n\n          configItem.overrides.push({\n            source: overrideSource.type,\n            value: overrideVal,\n          });\n        }\n      });\n\n      // currently this resolve fn will trigger resolve on nested items\n      await configItem.resolve();\n\n      // notify all plugins about the resolved item in case it resolves an input\n      if (configItem.isResolved) {\n        for (const plugin of this.ownedPlugins) {\n          // const plugin = this.workspace.plugins[pluginKey];\n          plugin.attemptInputResolutionsUsingConfigItem(configItem);\n        }\n      }\n    }\n\n    // final check on all plugins\n    for (const plugin of this.ownedPlugins) {\n      // const plugin = this.workspace.plugins[pluginKey];\n      plugin.checkItemsResolutions();\n    }\n  }\n\n  getConfigItemByPath(path: string) {\n    const pathParts = path.split('.');\n    let currentItem: DmnoConfigItemBase = this.config[pathParts[0]];\n    for (let i = 1; i < pathParts.length; i++) {\n      const pathPart = pathParts[i];\n      if (_.has(currentItem.children, pathPart)) {\n        currentItem = currentItem.children[pathPart];\n      } else {\n        throw new Error(`Trying to access ${this.serviceName} / ${path} failed at ${pathPart}`);\n      }\n    }\n    return currentItem;\n  }\n\n  get isValid() {\n    if (this.configLoadError) return false;\n    if (this.schemaErrors?.length) return false;\n    return true;\n  }\n\n  getEnv() {\n    const env: Record<string, any> = _.mapValues(this.config, (item) => {\n      return item.resolvedValue;\n    });\n    return env;\n  }\n  getInjectedEnvJSON(): InjectedDmnoEnv {\n    const env: Record<string, any> = _.mapValues(this.config, (item) => {\n      return item.toInjectedJSON();\n    });\n    return env;\n  }\n\n  toJSON(): SerializedService {\n    return {\n      isValid: this.isValid,\n      isResolved: true,\n      packageName: this.packageName,\n      serviceName: this.serviceName,\n      path: this.path,\n      configLoadError: this.configLoadError?.toJSON(),\n      schemaErrors:\n        this.schemaErrors?.length\n          ? _.map(this.schemaErrors, (err) => err.toJSON())\n          : undefined,\n\n      ownedPluginNames: _.map(this.ownedPlugins, (p) => p.instanceName),\n      injectedPluginNames: _.map(this.injectedPlugins, (p) => p.instanceName),\n\n      config: _.mapValues(this.config, (item, _key) => item.toJSON()),\n    };\n  }\n}\n\nexport class ResolverContext {\n  // TODO: the item has everything we need, but is it what we want to pass in?\n  // lots of ? and ! on ts types here because data doesn't exist at init time...\n  private resolver?: ConfigValueResolver;\n  private configItem: DmnoConfigItemBase;\n  constructor(\n    // private configItem: DmnoConfigItemBase,\n    resolverOrItem: ConfigValueResolver | DmnoConfigItemBase,\n  ) {\n    if (resolverOrItem instanceof ConfigValueResolver) {\n      this.resolver = resolverOrItem;\n      this.configItem = this.resolver.configItem!;\n    } else {\n      this.configItem = resolverOrItem;\n    }\n  }\n\n  get service() {\n    return this.configItem.parentService;\n  }\n  get serviceName() {\n    return this.service?.serviceName;\n  }\n  get itemPath() {\n    return this.configItem.getPath();\n  }\n  get itemFullPath() {\n    return this.configItem.getFullPath();\n  }\n  get resolverFullPath() {\n    return this.resolver ? this.resolver.getFullPath() : this.itemFullPath;\n  }\n  get resolverBranchIdPath() {\n    return this.resolver?.branchIdPath;\n  }\n\n  get(itemPath: string) {\n    const item = this.service?.getConfigItemByPath(itemPath);\n    if (!item) {\n      throw new Error(`Tried to get item that does not exist ${itemPath}`);\n    }\n    if (!item.isResolved) {\n      throw new Error(`Tried to access item that was not resolved - ${item.getPath()}`);\n    }\n    return item.resolvedValue;\n  }\n\n\n  // TODO: probably dont want to pull cache disable setting from the workspace/service/etc\n  async getCacheItem(key: string) {\n    if (process.env.DISABLE_DMNO_CACHE) return undefined;\n    return this.service?.workspace.getCacheItem(key, this.itemFullPath);\n  }\n  async setCacheItem(key: string, value: ConfigValue) {\n    if (process.env.DISABLE_DMNO_CACHE) return;\n    if (value === undefined || value === null) return;\n    return this.service?.workspace.setCacheItem(key, value.toString(), this.itemFullPath);\n  }\n  async getOrSetCacheItem(key: string, getValToWrite: () => Promise<string>) {\n    if (!process.env.DISABLE_DMNO_CACHE) {\n      const cachedValue = await this.getCacheItem(key);\n      if (cachedValue) return cachedValue;\n    }\n    const val = await getValToWrite();\n    if (!process.env.DISABLE_DMNO_CACHE) {\n      await this.setCacheItem(key, val);\n    }\n    return val;\n  }\n}\n\n\nexport abstract class DmnoConfigItemBase {\n  constructor(\n    /** the item key / name */\n    readonly key: string,\n    private parent?: DmnoService | DmnoConfigItemBase,\n  ) {}\n\n  overrides: Array<ConfigValueOverride> = [];\n\n  valueResolver?: ConfigValueResolver;\n\n  isResolved = false;\n\n  get resolvedRawValue(): ConfigValue | undefined {\n    if (this.overrides.length) {\n      return this.overrides[0].value;\n    }\n    return this.valueResolver?.resolvedValue;\n  }\n\n  /** error encountered during resolution */\n  get resolutionError(): ResolutionError | undefined {\n    return this.valueResolver?.resolutionError;\n  }\n\n  /** resolved value _after_ coercion logic applied */\n  resolvedValue?: ConfigValue;\n\n  // not sure if the coercion error should be stored in resolution error or split?\n  /** error encountered during coercion step */\n  coercionError?: CoercionError;\n\n\n  /** more details about the validation failure if applicable */\n  validationErrors?: Array<ValidationError>;\n  /** whether the final resolved value is valid or not */\n  get isValid(): boolean | undefined {\n    if (this.coercionError) return false;\n    if (this.validationErrors && this.validationErrors?.length > 0) return false;\n    if (this.resolutionError) return false;\n    return true;\n    // return this.validationErrors.length === 0;\n  }\n\n  abstract get type(): DmnoDataType;\n\n  children: Record<string, DmnoConfigItemBase> = {};\n\n  get parentService(): DmnoService | undefined {\n    if (this.parent instanceof DmnoService) {\n      return this.parent;\n    } else if (this.parent instanceof DmnoConfigItemBase) {\n      return this.parent.parentService;\n    }\n  }\n\n  getPath(respectImportOverride = false): string {\n    const itemKey = (respectImportOverride && this.type.getDefItem('importEnvKey')) || this.key;\n    if (this.parent instanceof DmnoConfigItemBase) {\n      const parentPath = this.parent.getPath(respectImportOverride);\n      return `${parentPath}.${itemKey}`;\n    }\n    return itemKey;\n  }\n  getFullPath(respectImportOverride = false): string {\n    if (!this.parentService?.serviceName) {\n      throw new Error('unable to get full path - this item is not attached to a service');\n    }\n    return `${this.parentService.serviceName}!${this.getPath(respectImportOverride)}`;\n  }\n\n  get isDynamic() {\n    // this resolves whether the item should actually be treated as static or dynamic\n    // which takes into account the specific item's `dynamic` override\n    // the parent's dynamicConfig setting and if the item is \"sensitive\" (if the servies is in `public_static` mode)\n\n    // NOTE - this is the only place this logic exists\n\n    // get the config default mode of the service\n    const serviceDynamicConfigMode = this.parentService?.getSettingsItem('dynamicConfig');\n\n    if (serviceDynamicConfigMode === 'only_dynamic') return true;\n    if (serviceDynamicConfigMode === 'only_static') return false;\n\n    const explicitSetting = this.type.getDefItem('dynamic');\n    if (explicitSetting !== undefined) return explicitSetting;\n\n    if (serviceDynamicConfigMode === 'default_dynamic') return true;\n    if (serviceDynamicConfigMode === 'default_static') return false;\n\n    // 'public_static' mode is default behaviour\n    // sensitive = dynamic, non-sensitive = static\n    return !!this.type.getDefItem('sensitive');\n  }\n\n\n  async resolve() {\n    // TODO: not sure if we want to bail here or what it means to be \"resolved\" as things are changing?\n    if (this.isResolved) return;\n\n    const itemResolverCtx = new ResolverContext(this.valueResolver || this);\n\n    // resolve children of objects... this will need to be thought through and adjusted\n\n    // TODO: re-enable children / objects\n\n    // for (const childKey in this.children) {\n    //   // note - this isn't right, each resolve will probably need a new context object?\n    //   // an we'll need to deal with merging values set by the parent with values set in the child\n    //   await this.children[childKey].resolve(ctx);\n    // }\n\n    // console.log(`> resolving ${this.parentService?.serviceName}/${this.key}`);\n    if (this.valueResolver) {\n      await this.valueResolver.resolve(itemResolverCtx);\n    }\n\n    this.isResolved = true;\n\n    // TODO: need to think through if we want to run coercion/validation at all when we've encountered\n    // errors in the previous steps\n\n    // apply coercion logic (for example - parse strings into numbers)\n    // NOTE - currently we trigger this if the resolved value was not undefined\n    // but we may want to coerce undefined values in some cases as well?\n    // need to think through errors + overrides + empty values...\n    if (this.resolvedRawValue !== undefined) {\n      try {\n        const coerceResult = this.type.coerce(_.cloneDeep(this.resolvedRawValue), itemResolverCtx);\n        if (coerceResult instanceof CoercionError) {\n          this.coercionError = coerceResult;\n        } else {\n          this.resolvedValue = coerceResult;\n        }\n      } catch (err) {\n        this.coercionError = new CoercionError(err as Error);\n      }\n    }\n\n    // run validation logic\n    const validationResult = this.type.validate(_.cloneDeep(this.resolvedValue), itemResolverCtx);\n    this.validationErrors = validationResult === true ? [] : validationResult;\n\n    debug(\n      `${this.parentService?.serviceName}/${this.getPath()} = `,\n      JSON.stringify(this.resolvedRawValue),\n      JSON.stringify(this.resolvedValue),\n      this.isValid ? '✅' : `❌ ${this.validationErrors?.[0]?.message}`,\n    );\n  }\n\n  /** this is the shape that gets injected into an serialized json env var by `dmno run` */\n  toInjectedJSON(): InjectedDmnoEnvItem {\n    return {\n      ...this.type.getDefItem('sensitive') && { sensitive: 1 },\n      ...this.isDynamic && { dynamic: 1 },\n      value: this.resolvedValue,\n    };\n  }\n\n  toJSON(): SerializedConfigItem {\n    return {\n      key: this.key,\n      isValid: this.isValid,\n      dataType: this.type.toJSON(),\n      isDynamic: this.isDynamic,\n\n      resolvedRawValue: this.resolvedRawValue,\n      resolvedValue: this.resolvedValue,\n      isResolved: this.isResolved,\n      children: _.mapValues(this.children, (c) => c.toJSON()),\n\n      resolver: this.valueResolver?.toJSON(),\n      overrides: this.overrides,\n\n      // schemaErrors\n      coercionError: this.coercionError?.toJSON(),\n\n      validationErrors:\n        this.validationErrors?.length\n          ? _.map(this.validationErrors, (err) => err.toJSON())\n          : undefined,\n\n      resolutionError: this.resolutionError?.toJSON(),\n    };\n  }\n}\n\n\n\n// this is a \"processed\" config item\nexport class DmnoConfigItem extends DmnoConfigItemBase {\n  readonly type: DmnoDataType;\n  readonly schemaError?: Error;\n\n  constructor(\n    key: string,\n    defOrShorthand: ConfigItemDefinitionOrShorthand,\n    parent?: DmnoService | DmnoConfigItem,\n  ) {\n    super(key, parent);\n\n\n    // TODO: DRY this up -- it's (mostly) the same logic that DmnoDataType uses when handling extends\n    if (_.isString(defOrShorthand)) {\n      if (!DmnoBaseTypes[defOrShorthand]) {\n        throw new Error(`found invalid parent (string) in extends chain - \"${defOrShorthand}\"`);\n      } else {\n        this.type = DmnoBaseTypes[defOrShorthand]({});\n      }\n    } else if (_.isFunction(defOrShorthand)) {\n      // in this case, we have no settings to pass through, so we pass an empty object\n      const shorthandFnResult = defOrShorthand({});\n      if (!(shorthandFnResult instanceof DmnoDataType)) {\n        // TODO: put this in schema error instead?\n        console.log(DmnoDataType, shorthandFnResult);\n        throw new Error('invalid schema as result of fn shorthand');\n      } else {\n        this.type = shorthandFnResult;\n      }\n    } else if (defOrShorthand instanceof DmnoDataType) {\n      this.type = defOrShorthand;\n    } else if (_.isObject(defOrShorthand)) {\n      // this is the only real difference b/w the handling of extends...\n      // we create a DmnoDataType directly without a reusable type for the items defined in the schema directly\n      this.type = new DmnoDataType(defOrShorthand as any, undefined, undefined);\n    } else {\n      // TODO: put this in schema error instead?\n      throw new Error('invalid item schema');\n    }\n\n    try {\n      this.initializeChildren();\n    } catch (err) {\n      this.schemaError = err as Error;\n      debug(err);\n    }\n\n    this.valueResolver = this.type.valueResolver;\n    if (this.valueResolver) this.valueResolver.configItem = this;\n  }\n\n  private initializeChildren() {\n    // special handling for object types to initialize children\n    if (this.type.primitiveTypeFactory === DmnoBaseTypes.object) {\n      _.each(this.type.primitiveType.typeInstanceOptions, (childDef, childKey) => {\n        this.children[childKey] = new DmnoConfigItem(childKey, childDef, this);\n      });\n    }\n    // TODO: also need to initialize the `itemType` for array and dictionary\n    // unless we change how those work altogether...\n  }\n}\n\n// TODO: we could merge this with the above and handle both cases? we'll see\n\nexport class DmnoPickedConfigItem extends DmnoConfigItemBase {\n  /** full chain of items up to the actual config item */\n  private pickChain: Array<DmnoConfigItemBase> = [];\n\n  constructor(\n    key: string,\n    private def: {\n      sourceItem: DmnoConfigItemBase,\n      transformValue?: (val: any) => any,\n    },\n    parent?: DmnoService | DmnoPickedConfigItem,\n  ) {\n    super(key, parent);\n\n    // we'll follow through the chain of picked items until we get to a real config item\n    // note we're storing them in the opposite order as the typechain above\n    // because we'll want to traverse them in this order to do value transformations\n    this.pickChain.unshift(this.def.sourceItem);\n    while (this.pickChain[0] instanceof DmnoPickedConfigItem) {\n      this.pickChain.unshift(this.pickChain[0].def.sourceItem);\n    }\n\n    this.initializeChildren();\n\n    // each item in the chain could have a value transformer, so we must follow the entire chain\n    this.valueResolver = createdPickedValueResolver(this.def.sourceItem, this.def.transformValue);\n    this.valueResolver.configItem = this;\n  }\n\n  /** the real source config item - which defines most of the settings */\n  get originalConfigItem() {\n    // we know the first item in the list will be the actual source (and a DmnoConfigItem)\n    return this.pickChain[0] as DmnoConfigItem;\n  }\n  get type() {\n    return this.originalConfigItem.type;\n  }\n\n  private initializeChildren() {\n    if (this.originalConfigItem.children) {\n      _.each(this.originalConfigItem.children, (sourceChild, childKey) => {\n        this.children[childKey] = new DmnoPickedConfigItem(sourceChild.key, { sourceItem: sourceChild }, this);\n      });\n    }\n  }\n}\n","import crypto, { JsonWebKey } from 'node:crypto';\nimport * as b64ab from 'base64-arraybuffer';\n\nconst KEY_EXPORT_FORMAT = 'jwk';\nconst ENCRYPTION_ALGO = 'AES-GCM';\nconst IV_LENGTH = 12; // For GCM a nonce length of 12 bytes is recommended!\nconst KEY_USAGES = ['encrypt', 'decrypt'] as const;\nconst KEY_SPLIT_SEP = '//';\n\nexport async function generateEncryptionKeyString() {\n  const key = await crypto.subtle.generateKey(\n    { name: ENCRYPTION_ALGO, length: 256 },\n    true,\n    KEY_USAGES,\n  );\n  const exportableKey = await crypto.subtle.exportKey(KEY_EXPORT_FORMAT, key);\n  return exportableKey.k!;\n}\n\nexport async function importEncryptionKey(keyData: JsonWebKey) {\n  return crypto.subtle.importKey(\n    KEY_EXPORT_FORMAT,\n    keyData,\n    ENCRYPTION_ALGO,\n    true,\n    KEY_USAGES,\n  );\n}\nexport async function importEncryptionKeyString(keyStr: string) {\n  return importEncryptionKey({\n    key_ops: KEY_USAGES,\n    ext: true,\n    kty: 'oct',\n    k: keyStr,\n    alg: 'A256GCM',\n  });\n}\n\n\nexport async function generateDmnoEncryptionKeyString(keyName: string) {\n  if (keyName.includes(KEY_SPLIT_SEP)) {\n    throw new Error(`dmno encryption key name must not include separator \"${KEY_SPLIT_SEP}\"`);\n  }\n  const key = await generateEncryptionKeyString();\n  return `dmno${KEY_SPLIT_SEP}${keyName}${KEY_SPLIT_SEP}${key}`;\n}\n\nexport async function importDmnoEncryptionKeyString(dmnoKeyStr: string) {\n  if (!dmnoKeyStr.startsWith(`dmno${KEY_SPLIT_SEP}`)) {\n    throw new Error(`dmno keys must start with dmno${KEY_SPLIT_SEP}`);\n  }\n  const [,keyName, keyStr] = dmnoKeyStr.split(KEY_SPLIT_SEP);\n  if (!keyStr) throw new Error('dmno keys must have a key name');\n\n  const cryptoKey = await importEncryptionKeyString(keyStr);\n\n  return { key: cryptoKey, keyName };\n}\n\nexport async function encrypt(key: crypto.webcrypto.CryptoKey, rawValue: any, additionalData?: string) {\n  const nonce = crypto.randomBytes(IV_LENGTH);\n\n  const encryptedData = await crypto.subtle.encrypt(\n    {\n      name: ENCRYPTION_ALGO,\n      iv: nonce,\n      tagLength: 128, // ?\n      ...additionalData && { additionalData: Buffer.from(additionalData, 'base64') },\n    },\n    key,\n    new TextEncoder().encode(JSON.stringify(rawValue)),\n  );\n  const ivWithData = new Uint8Array(\n    Array.from(nonce).concat(Array.from(new Uint8Array(encryptedData))),\n  );\n  const encryptedStr = b64ab.encode(ivWithData);\n  return encryptedStr;\n}\n\n\nexport async function decrypt(key: crypto.webcrypto.CryptoKey, base64EncryptedVal: string, additionalData?: string) {\n  const nonceCiphertextTag = new Uint8Array(b64ab.decode(base64EncryptedVal));\n  const decryptionNonce = nonceCiphertextTag.subarray(0, IV_LENGTH);\n  const ciphertextTag = nonceCiphertextTag.subarray(IV_LENGTH);\n\n  const decrypted = await crypto.subtle.decrypt({\n    name: ENCRYPTION_ALGO,\n    iv: decryptionNonce,\n    ...additionalData && { additionalData: Buffer.from(additionalData, 'base64') },\n  }, key, ciphertextTag);\n\n  const decryptedStr = new TextDecoder().decode(decrypted);\n  const decryptedValue = JSON.parse(decryptedStr);\n  return decryptedValue;\n}\n\n","import _ from 'lodash-es';\nimport {\n  ConfigItemDefinition, ResolverContext, TypeValidationResult,\n} from './config-engine';\nimport { ConfigValueResolver, processInlineResolverDef } from './resolvers/resolvers';\nimport { CoercionError, EmptyRequiredValueError, ValidationError } from './errors';\nimport { SerializedDmnoDataType } from '../config-loader/serialization-types';\n\n// data types expose all the same options, except they additionally have a \"settings schema\"\n// and their validations/normalize functions get passed in the _instance_ of those settings when invoked\n/**\n * Represents the options for a DmnoDataType\n * @category HelperMethods\n */\ntype DmnoDataTypeOptions<TypeSettings = any> =\n  // the schema item validation/normalize fns do not get passed any settings\n  Omit<ConfigItemDefinition<TypeSettings>, 'validate' | 'asyncValidate' | 'coerce'> &\n  {\n    // TODO: we maybe want to split this into package/name or even org/package/name?\n    // TODO: figure out naming conventions (camel? Pascal? camel `package/typeName`)\n    /** type identifier used internally */\n    typeLabel?: string,\n\n    /** define a schema for the settings that will be passed in when using this data type */\n    settingsSchema?: TypeSettings,\n\n    /** validation function that can use type instance settings */\n    validate?: (val: any, settings: TypeSettings, ctx?: ResolverContext) => TypeValidationResult;\n\n    /** validation function that can use type instance settings */\n    asyncValidate?: (val: any, settings: TypeSettings, ctx?: ResolverContext) => Promise<TypeValidationResult>;\n\n    /** coerce function that can use type instance settings */\n    coerce?: (val: any, settings: TypeSettings, ctx?: ResolverContext) => any;\n\n    /** allows disabling or controling execution order of running the parent type's `validate` function (default = \"before\") */\n    runParentValidate?: 'before' | 'after' | false;\n    /** allows disabling or controling execution order of running the parent type's `asyncValidate` function (default = \"before\") */\n    runParentAsyncValidate?: 'before' | 'after' | false;\n    /** allows disabling or controling execution order of running the parent type's `coerce` function (default = \"before\") */\n    runParentCoerce?: 'before' | 'after' | false;\n\n  };\n\n/**\n * data type factory function - which is the result of `createDmnoDataType`\n * This is the type of our base types and any custom types defined by the user\n * */\nexport type DmnoDataTypeFactoryFn<T> = ((opts?: T) => DmnoDataType<T>);\n/**\n * utility type to extract the settings schema shape from a DmnoDataTypeFactoryFn (for example DmnoBaseTypes.string)\n * this is useful when extending types and wanting to reuse the existing settings\n * */\nexport type ExtractSettingsSchema<F> =\n  F extends DmnoDataTypeFactoryFn<infer T> ? T : never;\n\n\nexport class DmnoDataType<InstanceOptions = any> {\n  // NOTE - note quite sure about this setup yet...\n  // but the idea is to provide a wrapped version of the validate/coerce (the fns that need the type instance options)\n  // while providing transparent access to the rest. This is so the ConfigItem can just walk up the chain of types\n  // without having to understand the details... The other option is to revert that change and\n\n  parentType?: DmnoDataType;\n  private _valueResolver?: ConfigValueResolver;\n\n  constructor(\n    readonly typeDef: DmnoDataTypeOptions<InstanceOptions>,\n    readonly typeInstanceOptions: InstanceOptions,\n    /**\n     * the factory function that created this item\n     * Should be always defined unless this is an inline defined type from a config schema\n     * */\n    private _typeFactoryFn?: DmnoDataTypeFactoryFn<InstanceOptions>,\n  ) {\n    // if this is already one of our primitive base types, we are done\n    if (this.typeDef.extends === PrimitiveBaseType) {\n      // we'll skip setting the parentType since the primitive base type is just a placeholder / marker\n\n    // if extends is set, we make sure it is initialized properly and save that in the parent\n    } else if (this.typeDef.extends) {\n      // deal with string case - only valid for simple base types - `extends: 'number'`\n      if (_.isString(this.typeDef.extends)) {\n        if (!DmnoBaseTypes[this.typeDef.extends]) {\n          throw new Error(`found invalid parent (string) in extends chain - \"${this.typeDef.extends}\"`);\n        } else {\n          this.parentType = DmnoBaseTypes[this.typeDef.extends](typeInstanceOptions as any);\n        }\n      // deal with uninitialized case - `extends: DmnoBaseTypes.number`\n      } else if (_.isFunction(this.typeDef.extends)) {\n        const initializedDataType = this.typeDef.extends(typeInstanceOptions as any);\n        if (initializedDataType instanceof DmnoDataType) {\n          this.parentType = initializedDataType;\n        } else {\n          console.log(initializedDataType);\n          throw new Error('found invalid parent (as result of fn) in extends chain');\n        }\n      // normal case - `extends: DmnoBaseTypes.number({ ... })`\n      } else if (this.typeDef.extends instanceof DmnoDataType) {\n        this.parentType = this.typeDef.extends;\n      // anything else is considered an error\n      } else if (this.typeDef.extends) {\n        throw new Error(`found invalid parent in extends chain: ${this.typeDef.extends}`);\n      }\n\n    // if no parent type is set, we can try to infer it from a default value, and otherwise default to string\n    } else {\n      let inferredType;\n      if (this.typeDef.value !== undefined) {\n        if (_.isBoolean(this.typeDef.value)) inferredType = BooleanDataType();\n        else if (_.isNumber(this.typeDef.value)) inferredType = NumberDataType();\n      }\n      // TODO: can probably attempt to infer type from certain kinds of resolver (like a switch)\n\n      this.parentType = inferredType || StringDataType({});\n    }\n\n    // value resolvers have shorthands that can be passed in (static value, functions)\n    // so we'll make sure those are initialized properly as well\n    if (this.typeDef.value !== undefined) {\n      this._valueResolver = processInlineResolverDef(this.typeDef.value);\n    }\n\n    // if we are dealing with one of our schema inline-defined types (instead of via a reusable data type)\n    // we must adjust validate/coerce functions because they do not accept any settings\n    if (this.isInlineDefinedType) {\n      if (this.typeDef.validate) {\n        const originalValidate = this.typeDef.validate;\n        this.typeDef.validate = (val, _settings, ctx) => (originalValidate as any)(val, ctx as any);\n      }\n      if (this.typeDef.asyncValidate) {\n        const originalAsyncValidate = this.typeDef.asyncValidate;\n        this.typeDef.asyncValidate = (val, _settings, ctx) => (originalAsyncValidate as any)(val, ctx as any);\n      }\n      if (this.typeDef.coerce) {\n        const originalCoerce = this.typeDef.coerce;\n        this.typeDef.coerce = (val, _settings, ctx) => (originalCoerce as any)(val, ctx as any);\n      }\n    }\n  }\n\n  get valueResolver(): ConfigValueResolver | undefined {\n    return this._valueResolver ?? this.parentType?.valueResolver;\n  }\n\n\n  validate(val: any, ctx?: ResolverContext): true | Array<ValidationError> {\n    // first we'll deal with empty values, and we'll check al\n    // we'll check all the way up the chain for required setting and deal with that first\n    if (val === undefined || val === null) {\n      if (this.getDefItem('required')) {\n        // we pass through the value so we know which \"empty\" it is\n        return [new EmptyRequiredValueError(val)];\n      } else {\n        // maybe want to return something else than true?\n        return true;\n      }\n    }\n\n    // call parent validation (which will go all the way up the chain)\n    // this can be disabled or moved to after but the `runParentValidate` setting\n    if (\n      this.parentType\n      && (this.typeDef.runParentValidate === 'before' || this.typeDef.runParentValidate === undefined)\n    ) {\n      const parentValidationResult = this.parentType?.validate(val);\n      if (_.isArray(parentValidationResult) && parentValidationResult.length > 0) {\n        return parentValidationResult;\n      }\n    }\n\n    if (this.typeDef.validate !== undefined) {\n      try {\n        // we can identify the schema-defined types by not having a typeFactoryFn set\n        // and the validation/coercion logic set there expects a resolver context, not a settings object\n        // TODO: see if theres a better way to deal with TS for this?\n        const validationResult = this.typeDef.validate(val, this.typeInstanceOptions, ctx);\n\n        // TODO: think through validation fn shape - how to return status and errors...\n        if (\n          validationResult === undefined\n          || validationResult === true\n          || (_.isArray(validationResult) && validationResult.length === 0)\n        ) {\n          // do nothing\n        } else if (validationResult instanceof ValidationError) {\n          return [validationResult];\n        } else if (validationResult instanceof Error) {\n          return [new ValidationError(validationResult)];\n        } else if (_.isArray(validationResult) && validationResult[0] instanceof Error) {\n          return _.map(validationResult, (e) => {\n            if (e instanceof ValidationError) return e;\n            if (e instanceof Error) return new ValidationError(e);\n            return new ValidationError(new Error(`Threw invalid error: ${e}`));\n          });\n        } else {\n          return [new ValidationError(new Error(`Validation returned invalid result: ${validationResult}`))];\n        }\n      } catch (err) {\n        if (err instanceof ValidationError) {\n          return [err];\n        } else if (err instanceof Error) {\n          return [new ValidationError(err)];\n        } else if (_.isArray(err) && err[0] instanceof Error) {\n          return _.map(err, (e) => {\n            if (e instanceof ValidationError) return e;\n            if (e instanceof Error) return new ValidationError(e);\n            return new ValidationError(new Error(`Threw invalid error: ${e}`));\n          });\n        } else {\n          return [new ValidationError(new Error(`Validation threw a non-error: ${err}`))];\n        }\n      }\n    }\n\n    // handle parent validation in \"after\" mode\n    if (\n      this.parentType\n      && (this.typeDef.runParentValidate === 'after')\n    ) {\n      const parentValidationResult = this.parentType?.validate(val);\n      if (_.isArray(parentValidationResult) && parentValidationResult.length > 0) {\n        return parentValidationResult;\n      }\n    }\n\n    return true;\n  }\n\n\n  // TODO: DRY this up - its (almost) exactly the same as the validate method but calling asyncValidate instead\n  async asyncValidate(val: any, ctx?: ResolverContext): Promise<true | Array<Error>> {\n    // we'll first check if the value is \"valid\" - which will also deal with required but empty values\n    const isValid = this.validate(val, ctx);\n    if (!isValid) return [new Error('Cannot run async validation check on an invalid value')];\n\n\n    // TODO: not sure if we want to run the async validation if the value is empty?\n    // maybe want to return something else than true?\n    if (val === undefined || val === null) {\n      return true;\n    }\n\n    if (\n      this.parentType\n      && (this.typeDef.runParentAsyncValidate === 'before' || this.typeDef.runParentAsyncValidate === undefined)\n    ) {\n      const parentValidationResult = await this.parentType?.asyncValidate(val);\n      if (_.isArray(parentValidationResult) && parentValidationResult.length > 0) {\n        return parentValidationResult;\n      }\n    }\n\n    if (this.typeDef.asyncValidate !== undefined) {\n      try {\n        // we can identify the schema-defined types by not having a typeFactoryFn set\n        // and the validation/coercion logic set there expects a resolver context, not a settings object\n        // TODO: see if theres a better way to deal with TS for this?\n        const validationResult = await this.typeDef.asyncValidate(val, this.typeInstanceOptions, ctx);\n\n        // TODO: think through validation fn shape - how to return status and errors...\n        if (\n          validationResult === undefined\n          || validationResult === true\n          || (_.isArray(validationResult) && validationResult.length === 0)\n        ) {\n          // do nothing\n        } else if (validationResult instanceof Error) {\n          return [validationResult];\n        } else if (_.isArray(validationResult) && validationResult[0] instanceof Error) {\n          // TODO: might want to verify all array items are errors...?\n          return validationResult;\n        } else {\n          return [new Error(`Validation returned invalid result: ${validationResult}`)];\n        }\n      } catch (err) {\n        if (err instanceof Error) {\n          return [err];\n        } else if (_.isArray(err)) {\n          // TODO: should probably check that its an array of errors?\n          return err as Array<Error>;\n        } else {\n          return [new Error(`Validation threw a non-error: ${err}`)];\n        }\n      }\n    }\n\n    // handle parent validation in \"after\" mode\n    if (\n      this.parentType\n      && (this.typeDef.runParentAsyncValidate === 'after')\n    ) {\n      const parentValidationResult = await this.parentType?.asyncValidate(val);\n      if (_.isArray(parentValidationResult) && parentValidationResult.length > 0) {\n        return parentValidationResult;\n      }\n    }\n\n    return true;\n  }\n\n  coerce(val: any, ctx?: ResolverContext): any | CoercionError {\n    let coercedVal = val;\n\n    if (\n      this.parentType\n      && (this.typeDef.runParentCoerce === 'before' || this.typeDef.runParentCoerce === undefined)\n    ) {\n      coercedVal = this.parentType.coerce(coercedVal, ctx);\n    }\n\n    if (this.typeDef.coerce !== undefined) {\n      // see note about ctx and any in `validate` above\n      try {\n        coercedVal = this.typeDef.coerce(coercedVal, this.typeInstanceOptions, ctx);\n      } catch (err) {\n        if (err instanceof CoercionError) {\n          return err;\n        } else if (err instanceof Error) {\n          return new CoercionError(err);\n        } else {\n          return new CoercionError(new Error(`Coerce threw a non-error: ${err}`));\n        }\n      }\n    }\n\n    if (\n      this.parentType\n      && (this.typeDef.runParentCoerce === 'after')\n    ) {\n      coercedVal = this.parentType.coerce(coercedVal, ctx);\n    }\n\n    return coercedVal;\n  }\n\n\n  /** helper to unroll config schema using the type chain of parent \"extends\"  */\n  getDefItem<T extends keyof DmnoDataTypeOptions>(key: T): DmnoDataTypeOptions[T] {\n    // first check if the item definition itself has a value\n    if (this.typeDef[key] !== undefined) {\n      return this.typeDef[key];\n    // otherwise run up the ancestor heirarchy\n    } else {\n      return this.parentType?.getDefItem(key);\n    }\n  }\n\n  /** checks if this data type is directly an instance of the data type (not via inheritance) */\n  isType(factoryFn: DmnoDataTypeFactoryFn<any>): boolean {\n    // we jump straight to the parent if we are dealing with an inline defined type\n    return this.typeFactoryFn === factoryFn;\n  }\n\n  /** getter to retrieve the last type in the chain */\n  get typeFactoryFn(): DmnoDataTypeFactoryFn<any> {\n    if (this._typeFactoryFn) return this._typeFactoryFn;\n\n    // if this was created inline, we have no type factory fn so we return the parent instead\n    if (!this.parentType) throw new Error('inline defined types must have a parent');\n    // if (this.parentType.typeFactoryFn) throw new Error('inline defined type parent must have a typeFactoryFn set');\n    return this.parentType.typeFactoryFn;\n  }\n\n  /** checks if this data type is an instance of the data type, whether directly or via inheritance */\n  extendsType(factoryFn: DmnoDataTypeFactoryFn<any>): boolean {\n    // follows up the chain checking for the type we passed in\n    return this.isType(factoryFn) || this.parentType?.extendsType(factoryFn) || false;\n  }\n\n  /** helper to determine if the type was defined inline in a schema */\n  get isInlineDefinedType() {\n    // these get initialized without passing in a typeFactoryFn\n    return !this._typeFactoryFn;\n  }\n\n  // TODO: these names need to be thought through...\n  get primitiveType(): DmnoDataType {\n    if (!this.parentType) {\n      if (this.typeDef.extends === PrimitiveBaseType) return this;\n      throw new Error('Only primitive types should have no parent type');\n    }\n    return this.parentType?.primitiveType;\n  }\n  get primitiveTypeFactory(): DmnoDataTypeFactoryFn<any> {\n    return this.primitiveType.typeFactoryFn!;\n  }\n\n\n  toJSON(): SerializedDmnoDataType {\n    return {\n      summary: this.getDefItem('summary'),\n      description: this.getDefItem('description'),\n      typeDescription: this.getDefItem('typeDescription'),\n      expose: this.getDefItem('expose'),\n      sensitive: this.getDefItem('sensitive'),\n      externalDocs: this.getDefItem('externalDocs'),\n      ui: this.getDefItem('ui'),\n      required: this.getDefItem('required'),\n      useAt: this.getDefItem('useAt'),\n      dynamic: this.getDefItem('dynamic'),\n    };\n  }\n}\n\n\n// TODO: figure this out\n// when using a type, ideally we could omit usage options only when the schema has been mareked as `undefined | {}...`\n// alternatively, we can force the user to write it a certain way, but it's nice to be flexible\n// note that we have allowed the bare (non-function call, ie `extends: DmnoBaseTypes.string`) which\n// is also unaware if the settings schema is able to be undefined or not\n// (we're talking about allowing `DmnoBaseTypes.string()` vs only `DmnoBaseTypes.string({})`)\nexport function createDmnoDataType<T>(opts: DmnoDataTypeOptions<T>): DmnoDataTypeFactoryFn<T> {\n  // we are going to return a function which takes an _instance_ of the type settings schema for example `{ minLength: 2 }`\n  // and returns something which is able to use the DmnoDataType which knows how to combine the data type defintition and that isntance\n  // of the options together\n\n  // by storing a reference to this factory function we'll be able to compare a usage of the data type to the \"type\" itself\n  // for example `myCustomStringType.isType(DmnoBaseTypes.string)`\n  const typeFactoryFn = (usageOpts?: T) => new DmnoDataType<T>(opts, usageOpts ?? {} as T, typeFactoryFn);\n  return typeFactoryFn;\n}\n\n\n// we'll use this to mark our primitive types in a way that end users can't do by accident\nconst PrimitiveBaseType = createDmnoDataType({});\n\n/**\n * String base type settings\n * @category BaseTypes\n */\nexport type StringDataTypeSettings = {\n  /** The minimum length of the string. */\n  minLength?: number;\n  /** The maximum length of the string. */\n  maxLength?: number;\n  /** The exact length of the string. */\n  isLength?: number;\n  /** The required starting substring of the string. */\n  startsWith?: string;\n  /** The required ending substring of the string. */\n  endsWith?: string;\n\n  /** The regular expression or string pattern that the string must match. */\n  matches?: RegExp | string;\n  // isUpperCase?: boolean;\n  // isLowerCase?: boolean;\n  // isAlphaNumeric?: boolean;\n\n  // allow/deny character list\n  // more stuff?\n  /** converts to upper case */\n  toUpperCase?: boolean;\n  /** converts to lower case */\n  toLowerCase?: boolean;\n\n  /** allow empty string as a valid string (default is to NOT allow it) */\n  allowEmpty?: boolean;\n};\n\n/**\n * Represents a generic string data type.\n * @category Base Types\n */\nconst StringDataType = createDmnoDataType({\n  typeLabel: 'dmno/string',\n  extends: PrimitiveBaseType,\n\n  // summary: 'generic string data type',\n  settingsSchema: Object as undefined | StringDataTypeSettings,\n\n  coerce(rawVal, settings) {\n    if (_.isNil(rawVal)) return undefined;\n    let val = _.isString(rawVal) ? rawVal : rawVal.toString();\n\n    if (settings?.toUpperCase) val = val.toUpperCase();\n    if (settings?.toLowerCase) val = val.toLowerCase();\n\n    return val;\n  },\n\n  validate(val: string, settings) {\n    // we support returning multiple errors and our base types use this pattern\n    // but many user defined types should just throw the first error they encounter\n    const errors = [] as Array<ValidationError>;\n\n    // special handling to not allow empty strings (unless explicitly allowed)\n    if (val === '' && !settings.allowEmpty) {\n      return [new ValidationError('If set, string must not be empty')];\n    }\n\n    if (settings.minLength !== undefined && val.length < settings.minLength) {\n      errors.push(new ValidationError(`Length must be more than ${settings.minLength}`));\n    }\n    if (settings.maxLength !== undefined && val.length > settings.maxLength) {\n      errors.push(new ValidationError(`Length must be less than ${settings.maxLength}`));\n    }\n    if (settings.isLength !== undefined && val.length !== settings.isLength) {\n      errors.push(new ValidationError(`Length must be exactly ${settings.isLength}`));\n    }\n\n    if (settings.startsWith && !val.startsWith(settings.startsWith)) {\n      errors.push(new ValidationError(`Value must start with \"${settings.startsWith}\"`));\n    }\n    if (settings.endsWith && !val.endsWith(settings.endsWith)) {\n      errors.push(new ValidationError(`Value must start with \"${settings.endsWith}\"`));\n    }\n\n    if (settings.matches) {\n      const regex = _.isString(settings.matches) ? new RegExp(settings.matches) : settings.matches;\n      const matches = val.match(regex);\n      if (!matches) {\n        errors.push(new ValidationError(`Value must match regex \"${settings.matches}\"`));\n      }\n    }\n    return errors.length ? errors : true;\n  },\n});\n\n/**\n * Represents the settings for the NumberDataType.\n * @category BaseTypes\n */\nexport type NumberDataTypeSettings = {\n  /**\n   * The minimum value allowed for the number.\n   */\n  min?: number;\n  /**\n   * The maximum value allowed for the number.\n   */\n  max?: number;\n  /**\n   * Determines whether the number should be coerced to the minimum or maximum value if it is outside the range.\n   */\n  coerceToMinMaxRange?: boolean;\n  /**\n   * The number that the value must be divisible by.\n   */\n  isDivisibleBy?: number;\n  /**\n   * Determines whether the number should be an integer.\n   */\n  /** checks if it's an integer */\n  isInt?: boolean;\n  /** The number of decimal places allowed (for non-integers) */\n  precision?: number\n};\n// TOOD ACTUALLY USE THIS TYPE\n\n/**\n * Represents a generic number data type.\n * @category Base Types\n */\nconst NumberDataType = createDmnoDataType({\n  typeLabel: 'dmno/number',\n  extends: PrimitiveBaseType,\n  settingsSchema: Object as undefined | {\n\n    min?: number;\n    max?: number;\n    coerceToMinMaxRange?: boolean;\n    isDivisibleBy?: number;\n  } & ({ isInt: true; } | {\n    isInt?: never;\n    precision?: number\n  }),\n  validate(val, settings = {}) {\n    const errors = [] as Array<ValidationError>;\n    if (settings.min !== undefined && val < settings.min) {\n      errors.push(new ValidationError(`Min value is ${settings.min}`));\n    }\n    if (settings.max !== undefined && val > settings.max) {\n      errors.push(new ValidationError(`Max value is ${settings.max}`));\n    }\n    if (settings.isDivisibleBy !== undefined && val % settings.isDivisibleBy !== 0) {\n      errors.push(new ValidationError(`Value must be divisible by ${settings.isDivisibleBy}`));\n    }\n    return errors.length ? errors : true;\n  },\n  coerce(val, settings = {}) {\n    let numVal!: number;\n    if (_.isString(val)) {\n      const parsed = parseFloat(val);\n      if (_.isNaN(parsed)) throw new CoercionError('Unable to coerce string to number');\n      numVal = parsed;\n    } else if (_.isFinite(val)) {\n      numVal = val;\n    } else {\n      throw new CoercionError(`Cannot convert ${val} to number`);\n    }\n\n    if (settings.coerceToMinMaxRange) {\n      if (settings.min !== undefined) numVal = Math.max(settings.min, numVal);\n      if (settings.max !== undefined) numVal = Math.min(settings.max, numVal);\n    }\n\n    // not sure if we want to coerce to integer by default, versus just checking\n    if (settings.isInt === true || settings.precision === 0) {\n      numVal = Math.round(numVal);\n    } else if (settings.precision) {\n      const p = 10 ** settings.precision;\n      numVal = Math.round(numVal * p) / p;\n    }\n    return numVal;\n  },\n});\n\n\nconst BooleanDataType = createDmnoDataType({\n  typeLabel: 'dmno/boolean',\n  extends: PrimitiveBaseType,\n  // TODO: add settings to be more strict, or to allow other values to coerce to true/false\n  validate(val) {\n    if (_.isBoolean(val)) return true;\n    return new ValidationError('Value must be `true` or `false`');\n  },\n  coerce(val) {\n    if (_.isBoolean(val)) {\n      return val;\n    } else if (_.isString(val)) {\n      const cleanVal = val.toLowerCase().trim();\n      if (['t', 'true', 'yes', 'on', '1'].includes(cleanVal)) return true;\n      if (['f', 'false', 'no', 'off', '0'].includes(cleanVal)) return false;\n      throw new CoercionError('Unable to coerce string value to boolean');\n    } else if (_.isFinite(val)) {\n      if (val === 0) return false;\n      if (val === 1) return true;\n      throw new CoercionError('Unable to coerce number value to boolean (only 0 or 1 is valid)');\n    } else {\n      throw new CoercionError('Unable to coerce value to boolean');\n    }\n  },\n});\n\n\n// Common utility types ///////////////////////////////////////////////////////////////\n\nconst URL_REGEX = /(?:^|\\s)((https?:\\/\\/)?(?:localhost|[\\w-]+(?:\\.[\\w-]+)+)(:\\d+)?(\\/\\S*)?)/;\n// swapped to above to allow localhost\n// /^https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/;\nconst UrlDataType = createDmnoDataType({\n  typeLabel: 'dmno/url',\n  extends: (settings) => StringDataType({\n    ...settings.normalize && { toLowerCase: true },\n  }),\n  typeDescription: 'standard URL',\n  settingsSchema: Object as undefined | {\n    prependProtocol?: boolean\n    normalize?: boolean,\n    allowedDomains?: Array<string>\n  },\n\n  coerce(rawVal, settings) {\n    if (settings?.prependProtocol && !rawVal.startsWith('https://')) {\n      return `https://${rawVal}`;\n    }\n    return rawVal;\n  },\n\n  validate(val, settings) {\n    // TODO: this is testing assuming its a normal web/http URL\n    // we'll want some options to enable/disable specific protocols and things like that...\n    // at the very least, need to consider allowing localhost, which should likely be an option\n    const result = URL_REGEX.test(val);\n    if (!result) return new ValidationError('URL doesnt match url regex check');\n    if (settings?.allowedDomains) {\n      const [protocol, , domain] = val.split('/');\n      if (!settings.allowedDomains.includes(domain.toLowerCase())) {\n        return new ValidationError(`Domain (${domain}) is not in allowed list: ${settings.allowedDomains.join(',')}`);\n      }\n    }\n    return true;\n  },\n});\n\n\nconst SimpleObjectDataType = createDmnoDataType({\n  typeLabel: 'dmno/simple-object',\n  extends: PrimitiveBaseType,\n  validate(val) {\n    if (_.isPlainObject(val)) return true;\n    return new ValidationError('Value must be an object');\n  },\n  coerce(val) {\n    if (_.isPlainObject(val)) return val;\n    // if value is a string, we'll try to JSON.parse and see if that is an objce\n    if (_.isString(val)) {\n      try {\n        const parsedObj = JSON.parse(val);\n        if (_.isPlainObject(parsedObj)) return parsedObj;\n        return new CoercionError('Unable to coerce JSON parsed string to object');\n      } catch (err) {\n        return new CoercionError('Error parsing JSON string while coercing string to object');\n      }\n    }\n    return new CoercionError('Cannot coerce value to object');\n  },\n});\n\n\n\n// Complex \"container\" types //////////////////////////////////////////////////////////\n\nconst ObjectDataType = createDmnoDataType({\n  typeLabel: 'dmno/object',\n  extends: PrimitiveBaseType,\n  settingsSchema: Object as any as Record<string, ConfigItemDefinition>,\n});\n\n/**\n * Represents the settings for the ArrayDataType.\n * @category BaseTypes\n */\nexport type ArrayDataTypeSettings = {\n  /**\n   * The schema definition for each item in the array.\n   */\n  itemSchema?: ConfigItemDefinition;\n\n  /**\n   * The minimum length of the array.\n   */\n  minLength?: number;\n\n  /**\n   * The maximum length of the array.\n   */\n  maxLength?: number;\n\n  /**\n   * The exact length of the array.\n   */\n  isLength?: number;\n};\nconst ArrayDataType = createDmnoDataType({\n  typeLabel: 'dmno/array',\n  extends: PrimitiveBaseType,\n  settingsSchema: Array as ArrayDataTypeSettings,\n  // TODO: validate checks if it's an array\n  // helper to coerce csv string into array of strings\n});\n\n\n/**\n * Represents the settings for the DictionaryDataType.\n * @category BaseTypes\n */\nexport type DictionaryDataTypeSettings = {\n  /**\n   * The schema definition for each item in the dictionary.\n   */\n  itemSchema?: ConfigItemDefinition;\n\n  /**\n   * The minimum number of items in the dictionary.\n   */\n  minItems?: number;\n\n  /**\n   * The maximum number of items in the dictionary.\n   */\n  maxItems?: number;\n\n  /**\n   * A function to validate the keys of the dictionary.\n   */\n  validateKeys?: (key: string) => boolean;\n\n  /**\n   * A function to asynchronously validate the keys of the dictionary.\n   */\n  asyncValidateKeys?: (key: string) => Promise<boolean>;\n\n  /**\n   * A description of the keys of the dictionary.\n   */\n  keyDescription?: string;\n};\nconst DictionaryDataType = createDmnoDataType({\n  typeLabel: 'dmno/dictionary',\n  extends: PrimitiveBaseType,\n  settingsSchema: Object as DictionaryDataTypeSettings,\n  // TODO: validate checks if it's an object\n\n});\n\ntype PossibleEnumValues = string | number | boolean; // do we need explicitly allow null/undefined?\ntype ExtendedEnumDescription = {\n  value: PossibleEnumValues,\n  description?: string,\n  // icon, color, docs url, etc...\n};\n\n\n\nconst EnumDataType = createDmnoDataType({\n  typeLabel: 'dmno/enum',\n  extends: PrimitiveBaseType,\n  settingsSchema: Object as any as\n    (\n      // simple list of values\n      Array<PossibleEnumValues>\n      // array or values with extra metadata\n      | Array<ExtendedEnumDescription>\n      // object where object keys are the possible enum values and object values are additional metadata (works for strings only)\n      | Record<string, Omit<ExtendedEnumDescription, 'value'>>\n    ),\n});\n\nconst EMAIL_REGEX = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\nconst emailDataType = createDmnoDataType({\n  typeLabel: 'dmno/email',\n  extends: (settings) => StringDataType({\n    ...settings.normalize && { toLowerCase: true },\n  }),\n  typeDescription: 'standard email address',\n  settingsSchema: Object as undefined | {\n    // customDomainValidationFn: () => boolean,\n    normalize?: boolean,\n\n  },\n  validate(val) {\n    // check if it's a valid email\n    const result = EMAIL_REGEX.test(val);\n    if (result) return true;\n    return new ValidationError('Value must be a valid email address');\n  },\n});\n\nconst IP_V4_ADDRESS_REGEX = /^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$/;\nconst IP_V6_ADDRESS_REGEX = /^(?:(?:[a-fA-F\\d]{1,4}:){7}(?:[a-fA-F\\d]{1,4}|:)|(?:[a-fA-F\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-fA-F\\d]{1,4}|:)|(?:[a-fA-F\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,2}|:)|(?:[a-fA-F\\d]{1,4}:){4}(?:(?::[a-fA-F\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,3}|:)|(?:[a-fA-F\\d]{1,4}:){3}(?:(?::[a-fA-F\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,4}|:)|(?:[a-fA-F\\d]{1,4}:){2}(?:(?::[a-fA-F\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,5}|:)|(?:[a-fA-F\\d]{1,4}:){1}(?:(?::[a-fA-F\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,6}|:)|(?::(?:(?::[a-fA-F\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,7}|:)))(?:%[0-9a-zA-Z]{1,})?$/;\nconst ipAddressDataType = createDmnoDataType({\n  typeLabel: 'dmno/ipAddress',\n  extends: (settings) => StringDataType({\n    ...settings.normalize && { toLowerCase: true },\n  }),\n  typeDescription: 'ip v4 or v6 address',\n  settingsSchema: Object as undefined | {\n    version?: 4 | 6,\n    normalize?: boolean,\n  },\n  validate(val, settings) {\n    // default to v4\n    const regex = settings.version === 6 ? IP_V6_ADDRESS_REGEX : IP_V4_ADDRESS_REGEX;\n    const result = regex.test(val);\n    if (result) return true;\n    return new ValidationError('Value must be a valid IP address');\n  },\n});\n\nconst PortDataType = createDmnoDataType({\n  typeLabel: 'dmno/port',\n  extends: NumberDataType({\n    min: 0,\n    max: 65535,\n  }),\n  typeDescription: 'valid port number between 0 and 65535',\n  validate(val) {\n    if (val >= 0 && val <= 65535) return true;\n    return new ValidationError('Value must be a valid port number (0-65535)');\n  },\n});\n\nconst SEMVER_REGEX = /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$/;\nconst SemverDataType = createDmnoDataType({\n  typeLabel: 'dmno/semver',\n  extends: (settings) => StringDataType({\n    ...settings.normalize && { toLowerCase: true },\n  }),\n  typeDescription: 'semantic version string',\n  settingsSchema: Object as undefined | {\n    normalize?: boolean,\n    // range?: string, // ex.\n  },\n  validate(val) {\n    const result = SEMVER_REGEX.test(val);\n    if (result) return true;\n    return new ValidationError('Value must be a valid semantic version string');\n  },\n});\n\n// https://rgxdb.com/r/526K7G5W\nconst ISO_DATE_REGEX = /^(?:[+-]?\\d{4}(?!\\d{2}\\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\\1(?:[12]\\d|0[1-9]|3[01]))?|W(?:[0-4]\\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\\d|[12]\\d{2}|3(?:[0-5]\\d|6[1-6])))(?:[T\\s](?:(?:(?:[01]\\d|2[0-3])(?:(:?)[0-5]\\d)?|24:?00)(?:[.,]\\d+(?!:))?)?(?:\\2[0-5]\\d(?:[.,]\\d+)?)?(?:[zZ]|(?:[+-])(?:[01]\\d|2[0-3]):?(?:[0-5]\\d)?)?)?)?$/;\nconst IsoDateDataType = createDmnoDataType({\n  typeLabel: 'dmno/isoDate',\n  extends: StringDataType,\n  typeDescription: 'ISO 8601 date string with optional time and milliseconds',\n  validate(val) {\n    const result = ISO_DATE_REGEX.test(val);\n    if (result) return true;\n    return new ValidationError('Value must be a valid ISO 8601 date string');\n  },\n});\n\n\nconst UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-5][0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\nconst UuidDataType = createDmnoDataType({\n  typeLabel: 'dmno/uuid',\n  extends: StringDataType,\n  typeDescription: 'UUID string V1-V5 per RFC4122, including NIL',\n  validate(val) {\n    const result = UUID_REGEX.test(val);\n    if (result) return true;\n    return new ValidationError('Value must be a valid UUID string');\n  },\n});\n\nconst MD5_REGEX = /^[a-f0-9]{32}$/;\nconst Md5DataType = createDmnoDataType({\n  typeLabel: 'dmno/md5',\n  extends: StringDataType,\n  typeDescription: 'MD5 hash string',\n  validate(val) {\n    const result = MD5_REGEX.test(val);\n    if (result) return true;\n    return new ValidationError('Value must be a valid MD5 hash string');\n  },\n});\n\n\n// TODO consider splitting into base and utility types\nexport const DmnoBaseTypes = {\n  string: StringDataType,\n  number: NumberDataType,\n  boolean: BooleanDataType,\n  simpleObject: SimpleObjectDataType,\n\n  enum: EnumDataType,\n  email: emailDataType,\n  url: UrlDataType,\n  ipAddress: ipAddressDataType,\n  port: PortDataType,\n  semver: SemverDataType,\n  isoDate: IsoDateDataType,\n  uuid: UuidDataType,\n  md5: Md5DataType,\n\n  // TODO\n  // locale\n  // iso 3166\n\n  // \"compound\" types /////////////////\n  object: ObjectDataType,\n  array: ArrayDataType,\n  dictionary: DictionaryDataType, // TODO: could be called record? something else?\n};\n\n// cannot use `keyof typeof DmnoBaseTypes` as it creates a circular reference...\n// so we'll list the basic types that don't need any options\nexport type DmnoSimpleBaseTypeNames = 'string' | 'number' | 'url' | 'boolean' | 'simpleObject';\n\n\n\n// example of defining common type using our base types\nexport const NodeEnvType = createDmnoDataType({\n  // TODO: might want to split the base types from these? (both in \"dmno/\" for now)\n  typeLabel: 'dmno/nodeEnv',\n\n  typeDescription: 'standard environment flag for Node.js',\n  extends: DmnoBaseTypes.enum({\n    development: { description: 'true during local development' },\n    test: { description: 'true while running tests' },\n    production: { description: 'true for production' },\n  }),\n  // we'll set the default value, and assume it will be passed in via the environment to override\n  value: 'development',\n});\n","import _ from 'lodash-es';\n\n/**\n * parse env vars into an object, using a special separator to denote nesting.\n * This idea comes from https://www.npmjs.com/package/nconf\n *\n * for example PARENT_ITEM__CHILD_ITEM=foo would result in\n * { PARENT_ITEM: { CHILD_ITEM: \"foo\" } }\n */\nexport function getConfigFromEnvVars(\n  /** separator to interpret as nesting, defaults to \"__\" */\n  separator = '__',\n) {\n  const config = {} as Record<string, any>;\n  _.each(process.env, (val, key) => {\n    const path = key.replaceAll(separator, '.');\n    // _.set deals with initializing objects when necessary\n    _.set(config, path, val);\n  });\n  return config;\n}\n","\n\n\nexport function stringifyJsonWithCommentBanner(obj: Record<string, any>, banner?: string) {\n  const jsonStringWithoutBanner = JSON.stringify(obj, null, 2);\n\n  const jsonStringWithBanner = [\n    '// 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑',\n    '// 🛑 DO NOT COMMIT THIS FILE TO SOURCE CONTROL',\n    '// 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑 🛑',\n    '',\n    jsonStringWithoutBanner,\n  ].join('\\n');\n\n  return jsonStringWithBanner;\n}\n","import fs from 'node:fs';\nimport path from 'node:path';\nimport _ from 'lodash-es';\n\n\n// original from dotenv\n// const DOTENV_LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(#.*)?(?:$|$)/mg;\n\nimport { fdir } from 'fdir';\nimport { asyncMap } from 'modern-async';\nimport { checkIsFileGitIgnored } from './git-utils';\n\n// altered slightly from dotenv to capture trailing comments and handle newlines differently\nconst DOTENV_LINE = /(?:^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?[^\\S\\r\\n]*(#.*)?(?:$)/mg;\n\n\n\nexport type DotEnvSchemaItem = {\n  key: string,\n  value: string,\n  preComment?: string,\n  postComment?: string,\n};\n\nexport function parseDotEnvContents(dotEnvStr: string) {\n  // Convert line breaks to same format\n  dotEnvStr = dotEnvStr.replace(/\\r\\n?/mg, '\\n');\n\n  // let match = DOTENV_LINE.exec(dotEnvStr);\n  // let inMultiLineValue = false;\n  let preComments: Array<string> = [];\n\n  const dotenvItems: Array<DotEnvSchemaItem> = [];\n\n  while (dotEnvStr) {\n    let nextEndLineLoc = dotEnvStr.indexOf('\\n');\n    if (nextEndLineLoc === -1) nextEndLineLoc = dotEnvStr.length;\n\n    // if line is blank, we reset any accumulating comments\n    if (!dotEnvStr.substring(0, nextEndLineLoc).trim()) {\n      preComments = [];\n      dotEnvStr = dotEnvStr.substring(nextEndLineLoc + 1);\n      continue;\n    }\n\n    if (dotEnvStr.startsWith('#')) {\n      const commentLineContent = dotEnvStr.substring(1, nextEndLineLoc);\n\n      // if it looks like a commented out item rather than an actual comment, we'll just ignore the line\n      if (commentLineContent.match(DOTENV_LINE)) {\n        preComments = [];\n      } else {\n        preComments.push(commentLineContent);\n      }\n      dotEnvStr = dotEnvStr.substring(nextEndLineLoc + 1);\n      continue;\n    }\n\n    const match = DOTENV_LINE.exec(dotEnvStr);\n    if (!match) break;\n\n    // trim down the string and reset the regex\n    dotEnvStr = dotEnvStr.substring(match.index + match[0].length);\n    DOTENV_LINE.lastIndex = 0;\n\n    const key = match[1];\n\n    // Default undefined or null to empty string\n    let value = (match[2] || '');\n    // Remove whitespace\n    value = value.trim();\n    // Check if double quoted\n    const maybeQuote = value[0];\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2');\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n');\n      value = value.replace(/\\\\r/g, '\\r');\n    }\n\n    const postComment = match[3]?.substring(1);\n\n    dotenvItems.push({\n      key,\n      value,\n      preComment: preComments.join('\\n')?.trim() || undefined,\n      postComment: postComment?.trim(),\n    });\n    preComments = [];\n  }\n  return dotenvItems;\n}\n\nexport function loadDotEnvIntoObject(dotEnvStr: string) {\n  const dotenvItems = parseDotEnvContents(dotEnvStr);\n  const obj: Record<string, string> = {};\n  for (const i of dotenvItems) {\n    obj[i.key] = i.value;\n  }\n  return obj;\n}\n\n\n\n\n\nasync function loadDotEnvFile(basePath: string, relativePath: string) {\n  const fileName = relativePath.split('/').pop();\n  const filePath = path.resolve(basePath, relativePath);\n  if (!fileName) throw new Error(`Invalid filePath - ${filePath}`);\n  if (!fileName.startsWith('.env')) throw new Error('file name must start with \".env\"');\n\n  // chop off leading \".\" and split by \".\"\n  const fileNameParts = fileName.substring(1).split('.');\n\n  const isOverridesFile = ['local', 'override'].includes(fileNameParts[fileNameParts.length - 1]);\n  if (isOverridesFile) fileNameParts.pop();\n\n  const isSampleFile = ['sample', 'example'].includes(fileNameParts[fileNameParts.length - 1]);\n  if (isSampleFile) fileNameParts.pop();\n\n  if (fileNameParts.length > 2) throw Error(`Unsure how to interpret filename - ${fileName}`);\n\n  let applyForEnv = fileNameParts[1];\n  // docker compose gives examples of `.env.dev` and `.env.prod` so we standardize those to normal NODE_ENV values just in case\n  if (applyForEnv === 'dev') applyForEnv = 'development';\n  if (applyForEnv === 'prod') applyForEnv = 'production';\n\n  const isGitIgnored = await checkIsFileGitIgnored(filePath);\n\n  const rawContents = await fs.promises.readFile(filePath, 'utf8');\n  const parsedContents = parseDotEnvContents(rawContents);\n\n  const envObj: Record<string, string> = {};\n  for (const i of parsedContents) {\n    envObj[i.key] = i.value;\n  }\n  return {\n    path: filePath,\n    relativePath,\n    fileName,\n    isGitIgnored,\n    isOverridesFile,\n    isSampleFile,\n    applyForEnv,\n    rawContents,\n    parsedContents,\n    envObj,\n    items: _.keyBy(parsedContents, (i) => i.key) as Record<string, DotEnvSchemaItem>,\n  };\n}\nexport type LoadedDotEnvFile = Awaited<ReturnType<typeof loadDotEnvFile>>;\n\nexport async function loadServiceDotEnvFiles(\n  servicePath: string,\n  opts?: {\n    onlyLoadDmnoFolder?: boolean,\n    excludeDirs?: Array<string>,\n  },\n): Promise<Array<LoadedDotEnvFile>> {\n  let globs = ['**/.env', '**/.env.*', '**/.env.*.local'];\n  if (opts?.onlyLoadDmnoFolder) globs = globs.map((p) => p.replace('**/', './.dmno/'));\n  const dotEnvFilePaths = await new fdir() // eslint-disable-line new-cap\n    .withRelativePaths()\n    .glob(...globs)\n    .exclude((excludeDirName, exdlueDirPath) => {\n      // skip .XXX folders (other than .dmno)\n      if (excludeDirName !== '.dmno' && excludeDirName.startsWith('.')) return true;\n      // skip node_modules\n      if (excludeDirName === 'node_modules') return true;\n      // exclude directories - note as passed in, they do not have trailing slashes)\n      // but the dirPath does, so we must trailing slash\n      if (opts?.excludeDirs?.includes(exdlueDirPath.replace(/\\/$/, ''))) return true;\n      return false;\n    })\n    .crawl(servicePath)\n    .withPromise();\n\n  const dotEnvFiles = await asyncMap(dotEnvFilePaths, async (relativePath) => {\n    return await loadDotEnvFile(servicePath, relativePath);\n  });\n\n  const sortedDotEnvFiles = _.sortBy(dotEnvFiles, (d) => {\n    if (d.isSampleFile) return 0;\n    // .env\n    if (!d.isOverridesFile && !d.applyForEnv) return 1;\n    // .env.{ENV}\n    if (d.applyForEnv && !d.isOverridesFile) return 2;\n    // .env.local\n    if (!d.applyForEnv && d.isOverridesFile) return 3;\n    // .env.{ENV}.local\n    if (d.applyForEnv && d.isOverridesFile) return 4;\n    throw new Error('unknown type of env file');\n  });\n  return sortedDotEnvFiles;\n}\n","import { exec } from 'node:child_process';\nimport { promisify } from 'node:util';\n\nexport const asyncExec = promisify(exec);\n","import { asyncExec } from './exec-utils';\n\nexport async function checkIsFileGitIgnored(path: string, warnIfNotGitRepo = false) {\n  try {\n    await asyncExec(`git check-ignore ${path} -q`);\n    return true;\n  } catch (err) {\n    // `git check-ignore -q` exits with code 1 but no other error if is not ignored\n    if ((err as any).stderr === '') return false;\n    if ((err as any).stderr.includes('not a git repository')) {\n      if (warnIfNotGitRepo) {\n        // eslint-disable-next-line no-console\n        console.log('🔶 Your code is not currently in a git repository - run `git init` to initialize a new repo.');\n      }\n      return false;\n    }\n    // otherwise we'll let it throw since something else is happening\n    throw err;\n  }\n}\n","import { asyncForEach, asyncMap, Queue } from 'modern-async';\nimport { toPairs, fromPairs } from 'lodash-es';\n\ntype RecordKey = string | number | symbol;\n\nexport async function asyncMapKeys<OK extends RecordKey, OV, MK extends RecordKey>(\n  iterableObj: Record<OK, OV>,\n  iteratee: (value: OV, key: OK) => Promise<MK> | MK,\n  queueOrConcurrency?: Queue | number,\n): Promise<Record<MK, OV>> {\n  const objAsPairs: Array<[OK, OV]> = toPairs(iterableObj) as any;\n  const mappedPairs = await asyncMap(objAsPairs, async ([key, value]) => {\n    return [await iteratee(value, key), value] as [MK, OV];\n  }, queueOrConcurrency);\n  return fromPairs(mappedPairs) as Record<MK, OV>;\n}\n\nexport async function asyncMapValues<OK extends RecordKey, OV, MV>(\n  iterableObj: Record<OK, OV>,\n  iteratee: (value: OV, key: OK) => Promise<MV> | MV,\n  queueOrConcurrency?: Queue | number,\n): Promise<Record<OK, MV>> {\n  const objAsPairs: Array<[OK, OV]> = toPairs(iterableObj) as any;\n  const mappedPairs = await asyncMap(objAsPairs, async ([key, value]) => {\n    return [key, await iteratee(value, key)] as [OK, MV];\n  }, queueOrConcurrency);\n  return fromPairs(mappedPairs) as Record<OK, MV>;\n}\n\nexport async function asyncEachSeries<V>(\n  iterable: Iterable<V> | AsyncIterable<V>,\n  iteratee: (value: V, index: number, iterable: Iterable<V> | AsyncIterable<V>) => Promise<void> | void,\n): Promise<void> {\n  return asyncForEach(iterable, iteratee, 1);\n}\n\nexport async function asyncEachLimit<V>(\n  iterable: Iterable<V> | AsyncIterable<V>,\n  iteratee: (value: V, index: number, iterable: Iterable<V> | AsyncIterable<V>) => Promise<void> | void,\n  concurrency: number,\n): Promise<void> {\n  return asyncForEach(iterable, iteratee, concurrency);\n}\n\nexport async function asyncEachParallel<V>(\n  iterable: Iterable<V> | AsyncIterable<V>,\n  iteratee: (value: V, index: number, iterable: Iterable<V> | AsyncIterable<V>) => Promise<void> | void,\n): Promise<void> {\n  return asyncForEach(iterable, iteratee, Infinity);\n}\n","import _ from 'lodash-es';\nimport Debug from 'debug';\nimport {\n  ConfigPath, DmnoConfigItemBase, DmnoService, DmnoWorkspace, TypeExtendsDefinition,\n} from './config-engine';\nimport { DmnoDataType } from './base-types';\nimport { ConfigValue, ConfigValueResolver, createResolver } from './resolvers/resolvers';\nimport { CoercionError, SchemaError, ValidationError } from './errors';\nimport { SerializedDmnoPlugin, SerializedDmnoPluginInput } from '../config-loader/serialization-types';\n\nconst debug = Debug('dmno:plugins');\n\n\nexport type ClassOf<T> = new (...args: Array<any>) => T;\n\ntype MarkKeysRequired<R extends Record<any, any>, RequiredKeys extends keyof R> =\n  Partial<R>\n  & Required<Pick<R, RequiredKeys>>;\n\n// describes a \"schema\" object where an optional \"required\" prop can be set to true\ntype SchemaWithRequiredProp = { [k: string]: any, required?: boolean };\n// extracts keys that have `required: true` set on them\ntype RequiredKeys<\n  // note that the Readonly is important here as otherwise true is always treated as a boolean\n  S extends Readonly<Record<string, SchemaWithRequiredProp>>,\n> = { [K in keyof S]: S[K]['required'] extends true ? K : never }[keyof S];\n\n/** special symbol used to set an plugin input to be filled via type-based injection */\nexport const InjectPluginInputByType = Symbol('InjectPluginInputByType');\n\ntype PluginSchemaItemDefinition = {\n  /** is this input required */\n  required?: boolean;\n  /** description of the input */\n  description?: string,\n  /** data type of this input */\n  extends?: TypeExtendsDefinition,\n\n  // TODO: what other item schema properties do we want?\n};\n\nexport type DmnoPluginInputSchema = Record<string, PluginSchemaItemDefinition>;\n\ntype PluginInputMappingValue<StaticValueType = ConfigValue> =\n  ConfigPath |\n  typeof InjectPluginInputByType |\n  StaticValueType;\n\nexport type DmnoPluginClass<ChildClass extends DmnoPlugin = DmnoPlugin> =\n  { new (): ChildClass } & typeof DmnoPlugin<ChildClass>;\n\nexport const _PluginInputTypesSymbol: unique symbol = Symbol('plugin-input-types');\n\nexport type DmnoPluginInputMap<S extends DmnoPluginInputSchema> =\nMarkKeysRequired<\nRecord<keyof S, PluginInputMappingValue | undefined>,\nRequiredKeys<S>\n>;\n\n\nexport type GetPluginInputTypes<P extends DmnoPlugin> = P[typeof _PluginInputTypesSymbol];\n\nexport class DmnoPluginInputItem<ValueType = any> {\n  readonly dataType: DmnoDataType;\n\n  schemaError?: SchemaError;\n\n  /** error encountered during coercion step */\n  coercionError?: CoercionError;\n  /** more details about the validation failure if applicable */\n  validationErrors?: Array<ValidationError>;\n\n  /** resolved value _before_ coercion logic applied */\n  resolvedRawValue?: ConfigValue;\n  resolvedValue?: ValueType;\n\n  isResolved = false;\n  resolvingConfigItems?: Array<DmnoConfigItemBase>;\n\n  get resolutionMethod() {\n    if (this.typeInjectionEnabled) return 'type';\n    if (this.configPath) return 'path';\n    if (this.resolvedRawValue) return 'static';\n  }\n\n  /** flag to enable type-based injection */\n  typeInjectionEnabled = false;\n  /** config path to use in order to fill this input */\n  configPath?: ConfigPath;\n\n\n  constructor(readonly key: string, readonly itemSchema: PluginSchemaItemDefinition) {\n    // currently the itemSchema is all data-typey stuff... but we may need to pick certain keys out\n    // in order to make it compatible with DmnoDataType\n    this.dataType = new DmnoDataType(itemSchema, undefined, undefined);\n    // not sure if we want to support the same kind of shorthands we do in the shcemea\n  }\n\n  /** used to set a static value to resolve this input */\n  setStaticValue(val: ValueType) {\n    this.typeInjectionEnabled = false;\n    this.configPath = undefined;\n    this.setValue(val);\n  }\n  /** used to enable type-based injection to resolve this input */\n  enableTypeInjection() {\n    this.configPath = undefined;\n    this.typeInjectionEnabled = true;\n  }\n  /** used to set a specific config path to resolve this input */\n  setPathInjection(configPath: ConfigPath) {\n    this.typeInjectionEnabled = false;\n    this.configPath = configPath;\n  }\n\n  /** set the value after being resolved  */\n  private setValue(val: ValueType) {\n    this.resolvedRawValue = val as any; // TODO\n\n    // run coercion\n    const coerceResult = this.dataType.coerce(_.cloneDeep(this.resolvedRawValue));\n    if (coerceResult instanceof CoercionError) {\n      this.coercionError = coerceResult;\n    } else {\n      this.resolvedValue = coerceResult;\n    }\n    this.isResolved = true;\n\n    // run validation\n    const validationResult = this.dataType?.validate(this.resolvedValue);\n    this.validationErrors = validationResult === true ? [] : validationResult;\n  }\n\n  attemptResolutionUsingConfigItem(item: DmnoConfigItemBase) {\n    // if we were waiting for this item by path, it is now resolved\n    if (this.configPath?.path === item.getPath()) {\n      debug(`PLUGIN input \"${this.key}\" resolved by path`, this.configPath.path);\n      this.resolvingConfigItems = [item];\n      this.setValue(item.resolvedValue as any);\n    } else if (this.resolutionMethod === 'type') {\n      if (item.type.extendsType(this.dataType.typeFactoryFn)) {\n        // TODO: also want to not enable this if type is too primitive\n        // or maybe even allow disabling injection?\n\n        debug(`PLUGIN input \"${this.key}\" resolved by type`, item.type.typeDef.typeLabel);\n        if (this.resolvingConfigItems?.length) {\n          this.resolvingConfigItems.push(item);\n          // TODO - might want to add a details field on our errors to put additional info?\n          const paths = _.map(this.resolvingConfigItems, (i) => i.getPath());\n          this.schemaError = new SchemaError(`Received multiple values during type-based injection - ${paths.join(', ')}`);\n        } else {\n          this.resolvingConfigItems = [item];\n          this.setValue(item.resolvedValue as any);\n        }\n      }\n    }\n  }\n\n  // meant to be called after all possible resolutions could have occurred\n  // worst case this can be when the service is done, but ideally would be earlier?\n  checkResolutionStatus() {\n    // TODO: figure out what does \"isResolved\" mean\n\n    if (this.configPath && !this.isResolved) {\n      this.schemaError = new SchemaError(`Input resolution via path \"${this.configPath.path}\" failed`);\n    } else if (this.resolutionMethod === 'type' && !this.isResolved) {\n      this.schemaError = new SchemaError('Input resolution by type-based injection failed');\n    }\n\n\n    if (this.itemSchema.required) {\n      if (!this.isResolved) {\n        this.schemaError = new SchemaError('Item is required but was not resolved');\n      }\n      // the input item should already be throwing a validation error for being empty\n    }\n  }\n\n  get isValid() {\n    if (this.schemaError) return false;\n    if (this.coercionError) return false;\n    if (this.validationErrors?.length) return false;\n    return true;\n  }\n\n  toJSON(): SerializedDmnoPluginInput {\n    return {\n      key: this.key,\n      resolutionMethod: this.resolutionMethod,\n      isValid: this.isValid,\n      isResolved: this.isResolved,\n      // TODO: in the future we may have an array case so we may want to make this an array\n      // but it will likely be a single 90+% of the time...\n      mappedToItemPath: this.resolvingConfigItems?.[0]?.getFullPath(),\n      resolvedValue: this.resolvedValue,\n      coercionError: this.coercionError?.toJSON(),\n      schemaError: this.schemaError?.toJSON(),\n      validationErrors:\n        this.validationErrors?.length\n          ? _.map(this.validationErrors, (err) => err.toJSON())\n          : undefined,\n    };\n  }\n}\n\nexport abstract class DmnoPlugin<\n  ChildPlugin extends DmnoPlugin = NoopPlugin,\n> {\n  constructor(readonly instanceName: string) {\n    // see below, we are registering the plugin in a singleton object\n    if (allPlugins[instanceName]) {\n      throw new SchemaError(`Plugin instance names must be unique! Duplicate name: ${instanceName}`);\n    }\n    allPlugins[instanceName] = this;\n\n    initializedPluginInstanceNames.push(instanceName);\n\n    // const callStack = new Error('').stack!.split('\\n');\n    // const pluginDefinitionPath = callStack[2]\n    //   .replace(/.*\\(/, '')\n    //   .replace(/:.*\\)/, '');\n    // // special case for local dev when we have the plugins symlinked by pnpm\n    // if (pluginDefinitionPath.includes('/core/packages/plugins/')) {\n    //   const pluginPackageName\n    // } else {\n\n    // }\n    // console.log(pluginDefinitionPath);\n  }\n\n  /** name of the plugin itself - which is the name of the class */\n  pluginType = this.constructor.name;\n  /** iconify icon name */\n  icon?: string;\n\n  static cliPath?: string;\n  get cliPath() {\n    const PluginClass = this.constructor as typeof DmnoPlugin;\n    return PluginClass.cliPath;\n  }\n\n  /**\n   * reference back to the service this plugin was initialized in\n   * NOTE - when using injection, it will still be the original initializing service\n   * */\n  initByService?: DmnoService;\n  injectedByServices?: Array<DmnoService>;\n\n  /** schema for the inputs this plugin needs - stored on the class */\n  protected static readonly inputSchema: DmnoPluginInputSchema;\n  /** helper to get the inputSchema from within a instance of the class */\n  get inputSchema() {\n    const PluginClass = this.constructor as typeof DmnoPlugin;\n    return PluginClass.inputSchema;\n  }\n\n  /**\n   * tracks the status of each input\n   * how it will be resolved, status of that resolution, and the resolvedValue\n   * */\n  readonly inputItems: {\n    [K in keyof GetPluginInputTypes<ChildPlugin>]-?:\n    // PluginInputStateItem<PluginInputTypes<ChildPlugin>[K]>\n    DmnoPluginInputItem<GetPluginInputTypes<ChildPlugin>[K]>\n  } = _.mapValues(this.inputSchema, (itemSchema, itemKey) => new DmnoPluginInputItem(itemKey, itemSchema)) as any; // TODO: would be nice to remove this any\n\n\n  getInputItem<K extends keyof GetPluginInputTypes<ChildPlugin>>(\n    key: K,\n    // TS wasn't quite happy unless I explicitly added this return type\n  ) {\n    return this.inputItems[key];\n  }\n\n  private _inputsAllResolved = false;\n  get inputsAllResolved() { return this._inputsAllResolved; }\n\n  protected setInputMap(\n    inputMapping: DmnoPluginInputMap<DmnoPluginClass<ChildPlugin>['inputSchema']\n    >,\n  ) {\n    for (const itemKey in this.inputSchema) {\n      // const itemSchema = this.inputSchema[itemKey];\n      const val = inputMapping[itemKey];\n\n      if (val instanceof ConfigPath) {\n        this.inputItems[itemKey].setPathInjection(val);\n      } else if (val === InjectPluginInputByType) {\n        this.inputItems[itemKey].enableTypeInjection();\n      } else if (val !== undefined && val !== null) {\n        // TODO: remove this any\n        this.inputItems[itemKey].setStaticValue(val as any);\n      }\n    }\n  }\n\n\n  /**\n   * map of input keys to their generated types\n   * this will be filled in via our type auto-generation process\n   * and overridden via module augmentation\n   * */\n  // we use a symbol here so it doesn't show up in autocomplete (it doesn't actually exist)\n  // it is just used to type many other things in the class\n  [_PluginInputTypesSymbol]: Record<string, any> = {};\n\n  inputValues = new Proxy<GetPluginInputTypes<ChildPlugin>>({}, {\n    get: (target, inputKey) => {\n      if (_.isSymbol(inputKey)) return;\n      return this.inputItems[inputKey]?.resolvedValue;\n    },\n    // set(target, name, value) {\n    //   return true;\n    // },\n  });\n\n\n  // TODO: add some kind of hooks system so plugin author can run some logic\n  // when each (or all?) inputs are resolved. This would let us for example\n  // make an api request to validate that all the settings together are valid?\n\n  attemptInputResolutionsUsingConfigItem(item: DmnoConfigItemBase) {\n    for (const inputKey in this.inputItems) {\n      this.inputItems[inputKey].attemptResolutionUsingConfigItem(item);\n    }\n  }\n\n  checkItemsResolutions() {\n    for (const inputKey in this.inputItems) {\n      this.inputItems[inputKey].checkResolutionStatus();\n    }\n  }\n\n  get isValid() {\n    return _.every(_.values(this.inputItems), (i) => i.isValid);\n  }\n\n\n  resolvers: Array<ConfigValueResolver> = [];\n  createResolver(def: Parameters<typeof createResolver>[0]): ReturnType<typeof createResolver> {\n    const r = createResolver({\n      createdByPlugin: this,\n      ...def,\n    });\n    this.resolvers.push(r);\n    return r;\n  }\n\n  // private hooks?: {\n  //   onInitComplete?: () => Promise<void>;\n  // };\n\n  toJSON(): SerializedDmnoPlugin {\n    return {\n      pluginType: this.pluginType,\n      cliPath: (this.constructor as any).cliPath,\n      instanceName: this.instanceName,\n      isValid: this.isValid,\n      initializedInService: this.initByService?.serviceName || '',\n      injectedIntoServices: _.map(this.injectedByServices, (s) => s.serviceName),\n      inputs: _.mapValues(this.inputItems, (i) => i.toJSON()),\n      usedByConfigItemResolverPaths: _.map(this.resolvers, (r) => r.getFullPath()),\n    };\n  }\n\n\n  static injectInstance<T extends DmnoPlugin>(\n    this: new (...args: Array<any>) => T,\n    instanceName: string,\n  ) {\n    const pluginToInject = allPlugins[instanceName];\n    if (!pluginToInject) {\n      throw new SchemaError(`Plugin injection failed - no plugin named \"${instanceName}\" exists`);\n    }\n    if (!pluginToInject.initByService || pluginToInject.initByService.serviceName !== 'root') {\n      throw new SchemaError(`Plugin injection failed for \"${instanceName}\" - you can only inject plugins from the root`);\n    }\n\n    if (!(pluginToInject instanceof this)) {\n      throw new SchemaError(`Type of plugin being injected does not match. Requested = ${this.name}, Injected = ${(pluginToInject as any).constructor.name}`);\n    }\n    injectedPluginInstanceNames.push(instanceName);\n    return pluginToInject as T;\n  }\n}\n\n// TODO: this is a pretty naive approach to capturing the plugins while loading config\n// probably should move to something like AsnycLocalStorage to make it more flexible\n\nlet allPlugins: Record<string, DmnoPlugin> = {};\nlet initializedPluginInstanceNames: Array<string> = [];\nlet injectedPluginInstanceNames: Array<string> = [];\n\nexport function beginWorkspaceLoadPlugins(workspace: DmnoWorkspace) {\n  allPlugins = workspace.plugins;\n}\n\nexport function beginServiceLoadPlugins() {\n  initializedPluginInstanceNames = [];\n  injectedPluginInstanceNames = [];\n}\nexport function finishServiceLoadPlugins(service: DmnoService) {\n  service.injectedPlugins = _.values(_.pick(allPlugins, injectedPluginInstanceNames));\n  service.ownedPlugins = _.values(_.pick(allPlugins, initializedPluginInstanceNames));\n\n  _.each(injectedPluginInstanceNames, (pName) => {\n    allPlugins[pName].injectedByServices ||= [];\n    allPlugins[pName].injectedByServices?.push(service);\n  });\n  _.each(initializedPluginInstanceNames, (pName) => {\n    allPlugins[pName].initByService = service;\n  });\n}\n\nclass NoopPlugin extends DmnoPlugin {}\n","import os from 'os';\n\nclass Defaults{\n\n    constructor(){\n\n    }\n\n\n    appspace='app.';\n    socketRoot='/tmp/';\n    id=os.hostname();\n\n    encoding='utf8';\n    rawBuffer=false;\n    sync=false;\n    unlink=true;\n\n    delimiter='\\f';\n\n    silent=false;\n    logDepth=5;\n    logInColor=true;\n    logger=console.log.bind(console);\n\n    maxConnections=100;\n    retry=500;\n    maxRetries=Infinity;\n    stopRetrying=false;\n\n    IPType=getIPType();\n    tls=false;\n    networkHost = (this.IPType == 'IPv6') ? '::1' : '127.0.0.1';\n    networkPort = 8000;\n\n    readableAll = false;\n    writableAll = false;\n\n    interface={\n        localAddress:false,\n        localPort:false,\n        family:false,\n        hints:false,\n        lookup:false\n    }\n    \n}\n\nfunction getIPType() {\n    const networkInterfaces = os.networkInterfaces();\n    let IPType = '';\n    if (networkInterfaces\n        && Array.isArray(networkInterfaces)\n        && networkInterfaces.length > 0) {\n        // getting the family of first network interface available\n        IPType = networkInterfaces [\n            Object.keys( networkInterfaces )[0]\n        ][0].family;\n    }\n    return IPType;\n}\n\nexport {\n    Defaults as default,\n    Defaults\n}\n","import net from 'net';\nimport tls from 'tls';\nimport EventParser from '../entities/EventParser.js';\nimport Message from 'js-message';\nimport fs from 'fs';\nimport Queue from '@node-ipc/js-queue';\nimport Events from '@achrinza/event-pubsub';\n\nlet eventParser = new EventParser();\n\nclass Client extends Events{\n    constructor(config,log){\n        super();\n        this.config=config;\n        this.log=log;\n        this.publish=super.emit;\n        \n        (config.maxRetries)? this.retriesRemaining=config.maxRetries:0;\n\n        eventParser=new EventParser(this.config);\n    }\n\n    Client=Client;\n    queue =new Queue;\n    socket=false;\n    connect=connect;\n    emit=emit;\n    retriesRemaining=0;\n    explicitlyDisconnected=false;\n}\n\nfunction emit(type,data){\n    this.log('dispatching event to ', this.id, this.path, ' : ', type, ',', data);\n\n    let message=new Message;\n    message.type=type;\n    message.data=data;\n\n    if(this.config.rawBuffer){\n        message=Buffer.from(type,this.config.encoding);\n    }else{\n        message=eventParser.format(message);\n    }\n\n    //volitile emit\n    if(!this.config.sync){\n        this.socket.write(message);\n        return;\n    }\n\n    //sync, non-volitile, ack emit\n    this.queue.add(\n        syncEmit.bind(this,message)\n    );\n}\n\nfunction syncEmit(message){\n    this.log('dispatching event to ', this.id, this.path, ' : ', message);\n    this.socket.write(message);\n}\n\nfunction connect(){\n    //init client object for scope persistance especially inside of socket events.\n    let client=this;\n\n    client.log('requested connection to ', client.id, client.path);\n    if(!this.path){\n        client.log('\\n\\n######\\nerror: ', client.id ,' client has not specified socket path it wishes to connect to.');\n        return;\n    }\n\n    const options={};\n\n    if(!client.port){\n        client.log('Connecting client on Unix Socket :', client.path);\n\n        options.path=client.path;\n\n        if (process.platform ==='win32' && !client.path.startsWith('\\\\\\\\.\\\\pipe\\\\')){\n            options.path = options.path.replace(/^\\//, '');\n            options.path = options.path.replace(/\\//g, '-');\n            options.path= `\\\\\\\\.\\\\pipe\\\\${options.path}`;\n        }\n\n        client.socket = net.connect(options);\n    }else{\n        options.host=client.path;\n        options.port=client.port;\n\n        if(client.config.interface.localAddress){\n          options.localAddress=client.config.interface.localAddress;\n        }\n\n        if(client.config.interface.localPort){\n          options.localPort=client.config.interface.localPort;\n        }\n\n        if(client.config.interface.family){\n          options.family=client.config.interface.family;\n        }\n\n        if(client.config.interface.hints){\n          options.hints=client.config.interface.hints;\n        }\n\n        if(client.config.interface.lookup){\n          options.lookup=client.config.interface.lookup;\n        }\n\n        if(!client.config.tls){\n            client.log('Connecting client via TCP to', options);\n            client.socket = net.connect(options);\n        }else{\n            client.log('Connecting client via TLS to', client.path ,client.port,client.config.tls);\n            if(client.config.tls.private){\n                client.config.tls.key=fs.readFileSync(client.config.tls.private);\n            }\n            if(client.config.tls.public){\n                client.config.tls.cert=fs.readFileSync(client.config.tls.public);\n            }\n            if(client.config.tls.trustedConnections){\n                if(typeof client.config.tls.trustedConnections === 'string'){\n                    client.config.tls.trustedConnections=[client.config.tls.trustedConnections];\n                }\n                client.config.tls.ca=[];\n                for(let i=0; i<client.config.tls.trustedConnections.length; i++){\n                    client.config.tls.ca.push(\n                        fs.readFileSync(client.config.tls.trustedConnections[i])\n                    );\n                }\n            }\n\n            Object.assign(client.config.tls,options);\n\n            client.socket = tls.connect(\n                client.config.tls\n            );\n        }\n    }\n\n    client.socket.setEncoding(this.config.encoding);\n\n    client.socket.on(\n        'error',\n        function(err){\n            client.log('\\n\\n######\\nerror: ', err);\n            client.publish('error', err);\n\n        }\n    );\n\n    client.socket.on(\n        'connect',\n        function connectionMade(){\n            client.publish('connect');\n            client.retriesRemaining=client.config.maxRetries;\n            client.log('retrying reset');\n        }\n    );\n\n    client.socket.on(\n        'close',\n        function connectionClosed(){\n            client.log('connection closed' ,client.id , client.path,\n            client.retriesRemaining, 'tries remaining of', client.config.maxRetries\n        );\n\n            if(\n                client.config.stopRetrying ||\n                client.retriesRemaining<1 ||\n                client.explicitlyDisconnected\n\n            ){\n                client.publish('disconnect');\n                client.log(\n                    (client.config.id),\n                    'exceeded connection rety amount of',\n                    ' or stopRetrying flag set.'\n                );\n\n                client.socket.destroy();\n                client.publish('destroy');\n                client=undefined;\n\n                return;\n            }\n\n            setTimeout(\n                function retryTimeout(){\n                    if (client.explicitlyDisconnected) {\n                        return;\n                    }\n                    client.retriesRemaining--;\n                    client.connect();\n                }.bind(null,client),\n                client.config.retry\n            );\n\n            client.publish('disconnect');\n        }\n    );\n\n    client.socket.on(\n        'data',\n        function(data) {\n            client.log('## received events ##');\n            if(client.config.rawBuffer){\n                client.publish(\n                   'data',\n                   Buffer.from(data,client.config.encoding)\n                );\n                if(!client.config.sync){\n                    return;\n                }\n\n                client.queue.next();\n                return;\n            }\n\n            if(!this.ipcBuffer){\n                this.ipcBuffer='';\n            }\n\n            data=(this.ipcBuffer+=data);\n\n            if(data.slice(-1)!=eventParser.delimiter || data.indexOf(eventParser.delimiter) == -1){\n                client.log('Messages are large, You may want to consider smaller messages.');\n                return;\n            }\n\n            this.ipcBuffer='';\n\n            const events = eventParser.parse(data);\n            const eCount = events.length;\n            for(let i=0; i<eCount; i++){\n                let message=new Message;\n                message.load(events[i]);\n\n                client.log('detected event', message.type, message.data);\n                client.publish(\n                   message.type,\n                   message.data\n                );\n            }\n\n            if(!client.config.sync){\n                return;\n            }\n\n            client.queue.next();\n        }\n    );\n}\n\nexport {\n    Client as default,\n    Client\n};\n","\nimport Defaults from './Defaults.js';\n\nclass Parser{\n  constructor(config){\n    if(!config){\n      config=new Defaults;\n    }\n    this.delimiter=config.delimiter;\n  }\n\n  format(message){\n    if(!message.data && message.data!==false && message.data!==0){\n        message.data={};\n    }\n    if(message.data['_maxListeners']){\n        message.data={};\n    }\n\n    message=message.JSON+this.delimiter;\n    return message;\n  }\n\n  parse(data){\n    let events=data.split(this.delimiter);\n    events.pop();\n    return events;\n  }\n}\n\nexport {\n  Parser as default,\n  Parser\n};\n","class Fake{\n    //fake class as fallback\n}\n\nclass FakeCore{\n    //fake class as fallback\n}\n\nclass Is{\n    constructor(strict=true){\n        this.strict=strict;\n    }\n\n    //core\n    throw(valueType,expectedType){\n        let err=new TypeError;\n        err.message=`expected type of ${valueType} to be ${expectedType}`;\n        if(!this.strict){\n            return false;\n        }\n        throw err;\n    }\n\n    typeCheck(value,type){\n        if(typeof value === type){\n            return true;\n        }\n        return this.throw(typeof value,type);\n    }\n\n    instanceCheck(value=new Fake, constructor=FakeCore){\n        //console.log(value,constructor);\n        if(value instanceof constructor){\n            return true;\n        }\n        return this.throw(typeof value,constructor.name);\n    }\n\n    symbolStringCheck(value,type){\n        if(Object.prototype.toString.call(value) == `[object ${type}]`){\n            return true;\n        }\n        return this.throw(Object.prototype.toString.call(value),`[object ${type}]`);\n    }\n\n    compare(value,targetValue,typeName){\n        if(value==targetValue){\n            return true;\n        }\n        return this.throw(typeof value, typeName);\n    }\n\n    //unique checks\n    finite(value){\n        if(isFinite(value)){\n            return true;\n        }\n        return this.throw(typeof value, 'finite');\n    }\n\n    NaN(value){\n        if(!this.number(value)){\n            return this.number(value);\n        }\n\n        if(isNaN(value)){\n            return true;\n        }\n\n        return this.throw(typeof value, 'NaN');\n    }\n\n    null(value){\n        return this.compare(value,null,'null');\n    }\n\n    //common sugar\n    array(value){\n        return this.instanceCheck(value,Array);\n    }\n\n    boolean(value){\n        return this.typeCheck(value,'boolean');\n    }\n\n    bigint(value){\n        return this.typeCheck(value,'bigint');\n    }\n\n    date(value){\n        return this.instanceCheck(value,Date);\n    }\n    \n    generator(value){\n        return this.symbolStringCheck(value,'Generator');\n    }\n\n    asyncGenerator(value){\n        return this.symbolStringCheck(value,'AsyncGenerator');\n    }\n\n    globalThis(value){\n        return this.compare(value,globalThis,'explicitly globalThis, not window, global nor self');\n    }\n\n    infinity(value){\n        return this.compare(value,Infinity,'Infinity');\n    }\n\n    map(value){\n        return this.instanceCheck(value,Map);\n    }\n\n    weakMap(value){\n        return this.instanceCheck(value,WeakMap);\n    }\n\n    number(value){\n        return this.typeCheck(value,'number');\n    }\n\n    object(value){\n        return this.typeCheck(value,'object');\n    }\n\n    promise(value){\n        return this.instanceCheck(value,Promise);\n    }\n\n    regExp(value){\n        return this.instanceCheck(value,RegExp);\n    }\n    \n    undefined(value){\n        return this.typeCheck(value,'undefined');\n    }\n\n    set(value){\n        return this.instanceCheck(value,Set);\n    }\n\n    weakSet(value){\n        return this.instanceCheck(value,WeakSet);\n    }\n    \n    string(value){\n        return this.typeCheck(value,'string');\n    }\n\n    symbol(value){\n        return this.typeCheck(value,'symbol');\n    }\n\n    //functions\n    function(value){\n        return this.typeCheck(value,'function');\n    }\n\n    asyncFunction(value){\n        return this.symbolStringCheck(value,'AsyncFunction');\n    }\n\n    generatorFunction(value){\n        return this.symbolStringCheck(value,'GeneratorFunction');\n    }\n\n    asyncGeneratorFunction(value){\n        return this.symbolStringCheck(value,'AsyncGeneratorFunction');\n    }\n\n    //error sugar\n    error(value){\n        return this.instanceCheck(value,Error);\n    }\n\n    evalError(value){\n        return this.instanceCheck(value,EvalError);\n    }\n\n    rangeError(value){\n        return this.instanceCheck(value,RangeError);\n    }\n\n    referenceError(value){\n        return this.instanceCheck(value,ReferenceError);\n    }\n\n    syntaxError(value){\n        return this.instanceCheck(value,SyntaxError);\n    }\n\n    typeError(value){\n        return this.instanceCheck(value,TypeError);\n    }\n\n    URIError(value){\n        return this.instanceCheck(value,URIError);\n    }    \n\n    //typed array sugar\n    bigInt64Array(value){\n        return this.instanceCheck(value,BigInt64Array);\n    }\n\n    bigUint64Array(value){\n        return this.instanceCheck(value,BigUint64Array);\n    }\n\n    float32Array(value){\n        return this.instanceCheck(value,Float32Array);\n    }\n\n    float64Array(value){\n        return this.instanceCheck(value,Float64Array);\n    }\n\n    int8Array(value){\n        return this.instanceCheck(value,Int8Array);\n    }\n\n    int16Array(value){\n        return this.instanceCheck(value,Int16Array);\n    }\n\n    int32Array(value){\n        return this.instanceCheck(value,Int32Array);\n    }\n\n    uint8Array(value){\n        return this.instanceCheck(value,Uint8Array);\n    }\n\n    uint8ClampedArray(value){\n        return this.instanceCheck(value,Uint8ClampedArray);\n    }\n    \n    uint16Array(value){\n        return this.instanceCheck(value,Uint16Array);\n    }\n\n    uint32Array(value){\n        return this.instanceCheck(value,Uint32Array);\n    }\n\n    //buffers\n    arrayBuffer(value){\n        return this.instanceCheck(value,ArrayBuffer);\n    }\n\n    dataView(value){\n        return this.instanceCheck(value,DataView);\n    }\n\n    sharedArrayBuffer(value){\n        return this.instanceCheck(value,(function(){try{return SharedArrayBuffer}catch{ return Fake}})());\n    }\n\n    //Intl (browser internationalization)\n    intlDateTimeFormat(value){\n        return this.instanceCheck(value,Intl.DateTimeFormat);\n    }\n\n    intlCollator(value){\n        return this.instanceCheck(value,Intl.Collator);\n    }\n\n    intlDisplayNames(value){\n        return this.instanceCheck(value,Intl.DisplayNames);\n    }\n\n    intlListFormat(value){\n        return this.instanceCheck(value,Intl.ListFormat);\n    }\n\n    intlLocale(value){\n        return this.instanceCheck(value,Intl.Locale);\n    }\n\n    intlNumberFormat(value){\n        return this.instanceCheck(value,Intl.NumberFormat);\n    }\n\n    intlPluralRules(value){\n        return this.instanceCheck(value,Intl.PluralRules);\n    }\n\n    intlRelativeTimeFormat(value){\n        return this.instanceCheck(value,Intl.RelativeTimeFormat);\n    }\n\n    intlRelativeTimeFormat(value){\n        return this.instanceCheck(value,Intl.RelativeTimeFormat);\n    }\n\n\n\n    //garbage collection\n    finalizationRegistry(value){\n        return this.instanceCheck(value,FinalizationRegistry);\n    }\n\n    weakRef(value){\n        return this.instanceCheck(value,WeakRef);\n    }\n}\n\nexport {Is as default, Is};","//shim toallow node and native browser module path support with the same code\nimport Is from '../../@achrinza/strong-type/index.js';\n\nconst is=new Is;\n\nclass EventPubSub {\n    constructor() {\n        \n    }\n\n    on(type, handler, once=false) {\n        is.string(type);\n        is.function(handler);\n        is.boolean(once);\n        \n        if(type=='*'){\n            type=this.#all;\n        }\n\n        if (!this.#events[type]) {\n            this.#events[type] = [];\n        }\n\n        handler[this.#once] = once;\n\n        this.#events[type].push(handler);\n        \n        return this;\n    }\n\n    once(type, handler) {\n        //sugar for this.on with once set to true \n        //so let that do the validation\n        return this.on(type,handler,true);\n    }\n\n    off(type='*', handler='*') {\n        is.string(type);\n        \n        if(type==this.#all.toString()||type=='*'){\n            type=this.#all;\n        }\n        \n        if (!this.#events[type]) {\n            return this;\n        }\n\n        if (handler=='*') {\n            delete this.#events[type];\n            return this;\n        }\n\n        //If we are not removing all the handlers,\n        //we need to know which one we are removing.\n        is.function(handler);\n\n        const handlers = this.#events[type];\n\n        while (handlers.includes(handler)) {\n            handlers.splice(\n                handlers.indexOf( handler ),\n                1\n            );\n        }\n\n        if (handlers.length < 1) {\n            delete this.#events[type];\n        }\n\n        return this;\n    }\n\n    emit(type, ...args) {\n        is.string(type);\n        \n        const globalHandlers=this.#events[this.#all]||[];\n        \n        this.#handleOnce(this.#all.toString(), globalHandlers, type, ...args);\n        \n        if (!this.#events[type]) {\n            return this;\n        }\n\n        const handlers = this.#events[type];        \n\n        this.#handleOnce(type, handlers, ...args);\n\n        return this;\n    }\n\n    reset(){\n        this.off(this.#all.toString());\n        for(let type in this.#events){\n            this.off(type);\n        }\n\n        return this\n    }\n\n    get list(){\n        return Object.assign({},this.#events);\n    }\n\n    #handleOnce=(type, handlers, ...args)=>{\n        is.string(type);\n        is.array(handlers);\n        \n        const deleteOnceHandled=[];\n\n        for (let handler of handlers) {\n            handler(...args);\n            if(handler[this.#once]){\n                deleteOnceHandled.push(handler);\n            }\n        }\n\n        for(let handler of deleteOnceHandled){\n          this.off(type,handler);\n        }\n    }\n\n    #all =Symbol.for('event-pubsub-all')\n    #once=Symbol.for('event-pubsub-once')\n\n    #events={}\n}\n\nexport {EventPubSub as default, EventPubSub};","\nimport net from 'net';\nimport tls from 'tls';\nimport fs from 'fs';\nimport dgram from 'dgram';\nimport EventParser from '../entities/EventParser.js';\nimport Message from 'js-message';\nimport Events from '@achrinza/event-pubsub';\n\nlet eventParser = new EventParser();\n\nclass Server extends Events{\n    constructor(path,config,log,port){\n        super();\n        this.config = config;\n        this.path = path;\n        this.port = port;\n        this.log  = log;\n\n        this.publish=super.emit;\n\n        eventParser=new EventParser(this.config);\n\n        this.on(\n            'close',\n            serverClosed.bind(this)\n        );\n    }\n\n    udp4=false;\n    udp6=false;\n    server=false;\n    sockets=[];\n    emit=emit;\n    broadcast=broadcast;\n\n    onStart(socket){\n        this.publish(\n            'start',\n            socket\n        );\n    }\n\n    stop(){\n        this.server.close();\n    }\n\n    start(){\n        if(!this.path){\n            this.log('Socket Server Path not specified, refusing to start');\n            return;\n        }\n\n        if(this.config.unlink){\n            fs.unlink(\n                this.path,\n                startServer.bind(this)\n            );\n        }else{\n            startServer.bind(this)();\n        }\n    }\n}\n\nfunction emit(socket, type, data){\n    this.log('dispatching event to socket', ' : ', type, data);\n\n    let message=new Message;\n    message.type=type;\n    message.data=data;\n\n    if(this.config.rawBuffer){\n        this.log(this.config.encoding)\n        message=Buffer.from(type,this.config.encoding);\n    }else{\n        message=eventParser.format(message);\n    }\n\n    if(this.udp4 || this.udp6){\n\n        if(!socket.address || !socket.port){\n            this.log('Attempting to emit to a single UDP socket without supplying socket address or port. Redispatching event as broadcast to all connected sockets');\n            this.broadcast(type,data);\n            return;\n        }\n\n        this.server.write(\n            message,\n            socket\n        );\n        return;\n    }\n    \n    socket.write(message);\n}\n\nfunction broadcast(type,data){\n    this.log('broadcasting event to all known sockets listening to ', this.path,' : ', ((this.port)?this.port:''), type, data);\n    let message=new Message;\n    message.type=type;\n    message.data=data;\n\n    if(this.config.rawBuffer){\n        message=Buffer.from(type,this.config.encoding);\n    }else{\n        message=eventParser.format(message);\n    }\n\n    if(this.udp4 || this.udp6){\n        for(let i=1, count=this.sockets.length; i<count; i++){\n            this.server.write(message,this.sockets[i]);\n        }\n    }else{\n        for(let i=0, count=this.sockets.length; i<count; i++){\n            this.sockets[i].write(message);\n        }\n    }\n}\n\nfunction serverClosed(){\n    for(let i=0, count=this.sockets.length; i<count; i++){\n        let socket=this.sockets[i];\n        let destroyedSocketId=false;\n\n        if(socket){\n            if(socket.readable){\n                continue;\n            }\n        }\n\n        if(socket.id){\n            destroyedSocketId=socket.id;\n        }\n\n        this.log('socket disconnected',destroyedSocketId.toString());\n\n        if(socket && socket.destroy){\n            socket.destroy();\n        }\n\n        this.sockets.splice(i,1);\n\n        this.publish('socket.disconnected', socket, destroyedSocketId);\n\n        return;\n    }\n}\n\nfunction gotData(socket,data,UDPSocket){\n    let sock=((this.udp4 || this.udp6)? UDPSocket : socket);\n    if(this.config.rawBuffer){\n        data=Buffer.from(data,this.config.encoding);\n        this.publish(\n            'data',\n            data,\n            sock\n        );\n        return;\n    }\n\n    if(!sock.ipcBuffer){\n        sock.ipcBuffer='';\n    }\n\n    data=(sock.ipcBuffer+=data);\n\n    if(data.slice(-1)!=eventParser.delimiter || data.indexOf(eventParser.delimiter) == -1){\n        this.log('Messages are large, You may want to consider smaller messages.');\n        return;\n    }\n\n    sock.ipcBuffer='';\n\n    data=eventParser.parse(data);\n\n    while(data.length>0){\n        let message=new Message;\n        message.load(data.shift());\n\n        // Only set the sock id if it is specified.\n        if (message.data && message.data.id){\n            sock.id=message.data.id;\n        }\n\n        this.log('received event of : ',message.type,message.data);\n\n        this.publish(\n            message.type,\n            message.data,\n            sock\n        );\n    }\n}\n\nfunction socketClosed(socket){\n    this.publish(\n        'close',\n        socket\n    );\n}\n\nfunction serverCreated(socket) {\n    this.sockets.push(socket);\n\n    if(socket.setEncoding){\n        socket.setEncoding(this.config.encoding);\n    }\n\n    this.log('## socket connection to server detected ##');\n    socket.on(\n        'close',\n        socketClosed.bind(this)\n    );\n\n    socket.on(\n        'error',\n        function(err){\n            this.log('server socket error',err);\n\n            this.publish('error',err);\n        }.bind(this)\n    );\n\n    socket.on(\n        'data',\n        gotData.bind(this,socket)\n    );\n\n    socket.on(\n        'message',\n        function(msg,rinfo) {\n            if (!rinfo){\n                return;\n            }\n\n            this.log('Received UDP message from ', rinfo.address, rinfo.port);\n            let data;\n\n            if(this.config.rawSocket){\n                data=Buffer.from(msg,this.config.encoding);\n            }else{\n                data=msg.toString();\n            }\n            socket.emit('data',data,rinfo);\n        }.bind(this)\n    );\n\n    this.publish(\n        'connect',\n        socket\n    );\n\n    if(this.config.rawBuffer){\n        return;\n    }\n}\n\nfunction startServer() {\n    this.log(\n        'starting server on ',this.path,\n        ((this.port)?`:${this.port}`:'')\n    );\n\n    if(!this.udp4 && !this.udp6){\n        this.log('starting TLS server',this.config.tls);\n        if(!this.config.tls){\n            this.server=net.createServer(\n                serverCreated.bind(this)\n            );\n        }else{\n            startTLSServer.bind(this)();\n        }\n    }else{\n        this.server=dgram.createSocket(\n            ((this.udp4)? 'udp4':'udp6')\n        );\n        this.server.write=UDPWrite.bind(this);\n        this.server.on(\n            'listening',\n            function UDPServerStarted() {\n                serverCreated.bind(this)(this.server);\n            }.bind(this)\n        );\n    }\n\n    this.server.on(\n        'error',\n        function(err){\n            this.log('server error',err);\n\n            this.publish(\n                'error',\n                err\n            );\n        }.bind(this)\n    );\n\n    this.server.maxConnections=this.config.maxConnections;\n\n    if(!this.port){\n        this.log('starting server as', 'Unix || Windows Socket');\n        if (process.platform ==='win32'){\n            this.path = this.path.replace(/^\\//, '');\n            this.path = this.path.replace(/\\//g, '-');\n            this.path= `\\\\\\\\.\\\\pipe\\\\${this.path}`;\n        }\n\n        this.server.listen({\n            path: this.path,\n            readableAll: this.config.readableAll,\n            writableAll: this.config.writableAll\n        }, this.onStart.bind(this));\n\n        return;\n    }\n\n    if(!this.udp4 && !this.udp6){\n        this.log('starting server as', (this.config.tls?'TLS':'TCP'));\n        this.server.listen(\n            this.port,\n            this.path,\n            this.onStart.bind(this)\n        );\n        return;\n    }\n\n    this.log('starting server as',((this.udp4)? 'udp4':'udp6'));\n\n    this.server.bind(\n        this.port,\n        this.path\n    );\n\n    this.onStart(\n        {\n            address : this.path,\n            port    : this.port\n        }\n    );\n}\n\nfunction startTLSServer(){\n    this.log('starting TLS server',this.config.tls);\n    if(this.config.tls.private){\n        this.config.tls.key=fs.readFileSync(this.config.tls.private);\n    }else{\n        this.config.tls.key=fs.readFileSync(`${__dirname}/../local-node-ipc-certs/private/server.key`);\n    }\n    if(this.config.tls.public){\n        this.config.tls.cert=fs.readFileSync(this.config.tls.public);\n    }else{\n        this.config.tls.cert=fs.readFileSync(`${__dirname}/../local-node-ipc-certs/server.pub`);\n    }\n    if(this.config.tls.dhparam){\n        this.config.tls.dhparam=fs.readFileSync(this.config.tls.dhparam);\n    }\n    if(this.config.tls.trustedConnections){\n        if(typeof this.config.tls.trustedConnections === 'string'){\n            this.config.tls.trustedConnections=[this.config.tls.trustedConnections];\n        }\n        this.config.tls.ca=[];\n        for(let i=0; i<this.config.tls.trustedConnections.length; i++){\n            this.config.tls.ca.push(\n                fs.readFileSync(this.config.tls.trustedConnections[i])\n            );\n        }\n    }\n    this.server=tls.createServer(\n        this.config.tls,\n        serverCreated.bind(this)\n    );\n}\n\nfunction UDPWrite(message,socket){\n    let data=Buffer.from(message, this.config.encoding);\n    this.server.send(\n        data,\n        0,\n        data.length,\n        socket.port,\n        socket.address,\n        function(err, bytes) {\n            if(err){\n                this.log('error writing data to socket',err);\n                this.publish(\n                    'error',\n                    function(err){\n                        this.publish('error',err);\n                    }\n                );\n            }\n        }\n    );\n}\n\nexport {\n    Server as default,\n    Server\n};\n","\nimport Defaults from '../entities/Defaults.js';\nimport Client from '../dao/client.js';\nimport Server from '../dao/socketServer.js';\nimport util from 'util';\n\nclass IPC{\n    constructor(){\n\n    }\n    \n    //public members\n    config=new Defaults;\n    of={};\n    server=false;\n\n    //protected methods\n    get connectTo(){\n        return connect;\n    }\n    get connectToNet(){\n        return connectNet;\n    }\n    get disconnect(){\n        return disconnect\n    }\n    get serve(){\n        return serve;\n    }\n    get serveNet(){\n        return serveNet;\n    }\n    get log(){\n        return log;\n    }\n\n    set connectTo(value){\n        return connect;\n    }\n    set connectToNet(value){\n        return connectNet;\n    }\n    set disconnect(value){\n        return disconnect\n    }\n    set serve(value){\n        return serve;\n    }\n    set serveNet(value){\n        return serveNet;\n    }\n    set log(value){\n        return log;\n    }\n}\n\n    \n\nfunction log(...args){\n    if(this.config.silent){\n        return;\n    }\n\n    for(let i=0, count=args.length; i<count; i++){\n        if(typeof args[i] != 'object'){\n            continue;\n        }\n\n        args[i]=util.inspect(\n            args[i],\n            {\n                depth:this.config.logDepth,\n                colors:this.config.logInColor\n            }\n        );\n    }\n\n    this.config.logger(\n        args.join(' ')\n    );\n}\n\nfunction disconnect(id){\n    if(!this.of[id]){\n        return;\n    }\n\n    this.of[id].explicitlyDisconnected=true;\n\n    this.of[id].off('*','*');\n    if(this.of[id].socket){\n        if(this.of[id].socket.destroy){\n            this.of[id].socket.destroy();\n        }\n    }\n\n    delete this.of[id];\n}\n\nfunction serve(path,callback){\n    if(typeof path=='function'){\n        callback=path;\n        path=false;\n    }\n    if(!path){\n        this.log(\n            'Server path not specified, so defaulting to',\n            'ipc.config.socketRoot + ipc.config.appspace + ipc.config.id',\n            this.config.socketRoot+this.config.appspace+this.config.id\n        );\n        path=this.config.socketRoot+this.config.appspace+this.config.id;\n    }\n\n    if(!callback){\n        callback=emptyCallback;\n    }\n\n    this.server=new Server(\n        path,\n        this.config,\n        log\n    );\n\n    this.server.on(\n        'start',\n        callback\n    );\n}\n\nfunction emptyCallback(){\n    //Do Nothing\n}\n\nfunction serveNet(host,port,UDPType,callback){\n    if(typeof host=='number'){\n        callback=UDPType;\n        UDPType=port;\n        port=host;\n        host=false;\n    }\n    if(typeof host=='function'){\n        callback=host;\n        UDPType=false;\n        host=false;\n        port=false;\n    }\n    if(!host){\n        this.log(\n            'Server host not specified, so defaulting to',\n            'ipc.config.networkHost',\n            this.config.networkHost\n        );\n        host=this.config.networkHost;\n    }\n    if(host.toLowerCase()=='udp4' || host.toLowerCase()=='udp6'){\n        callback=port;\n        UDPType=host.toLowerCase();\n        port=false;\n        host=this.config.networkHost;\n    }\n\n    if(typeof port=='string'){\n        callback=UDPType;\n        UDPType=port;\n        port=false;\n    }\n    if(typeof port=='function'){\n        callback=port;\n        UDPType=false;\n        port=false;\n    }\n    if(!port){\n        this.log(\n            'Server port not specified, so defaulting to',\n            'ipc.config.networkPort',\n            this.config.networkPort\n        );\n        port=this.config.networkPort;\n    }\n\n    if(typeof UDPType=='function'){\n        callback=UDPType;\n        UDPType=false;\n    }\n\n    if(!callback){\n        callback=emptyCallback;\n    }\n\n    this.server=new Server(\n        host,\n        this.config,\n        log,\n        port\n    );\n\n    if(UDPType){\n        this.server[UDPType]=true;\n        if(UDPType === \"udp4\" && host === \"::1\") {\n            // bind udp4 socket to an ipv4 address\n            this.server.path = \"127.0.0.1\";\n        }\n    }\n\n    this.server.on(\n        'start',\n        callback\n    );\n}\n\nfunction connect(id,path,callback){\n    if(typeof path == 'function'){\n        callback=path;\n        path=false;\n    }\n\n    if(!callback){\n        callback=emptyCallback;\n    }\n\n    if(!id){\n        this.log(\n            'Service id required',\n            'Requested service connection without specifying service id. Aborting connection attempt'\n        );\n        return;\n    }\n\n    if(!path){\n        this.log(\n            'Service path not specified, so defaulting to',\n            'ipc.config.socketRoot + ipc.config.appspace + id',\n            (this.config.socketRoot+this.config.appspace+id).data\n        );\n        path=this.config.socketRoot+this.config.appspace+id;\n    }\n\n    if(this.of[id]){\n        if(!this.of[id].socket.destroyed){\n            this.log(\n                'Already Connected to',\n                id,\n                '- So executing success without connection'\n            );\n            callback();\n            return;\n        }\n        this.of[id].socket.destroy();\n    }\n\n    this.of[id] = new Client(this.config,this.log);\n    this.of[id].id = id;\n    (this.of[id].socket)? (this.of[id].socket.id=id):null;\n    this.of[id].path = path;\n\n    this.of[id].connect();\n\n    callback(this);\n}\n\nfunction connectNet(id,host,port,callback){\n    if(!id){\n        this.log(\n            'Service id required',\n            'Requested service connection without specifying service id. Aborting connection attempt'\n        );\n        return;\n    }\n    if(typeof host=='number'){\n        callback=port;\n        port=host;\n        host=false;\n    }\n    if(typeof host=='function'){\n        callback=host;\n        host=false;\n        port=false;\n    }\n    if(!host){\n        this.log(\n            'Server host not specified, so defaulting to',\n            'ipc.config.networkHost',\n            this.config.networkHost\n        );\n        host=this.config.networkHost;\n    }\n\n    if(typeof port=='function'){\n        callback=port;\n        port=false;\n    }\n    if(!port){\n        this.log(\n            'Server port not specified, so defaulting to',\n            'ipc.config.networkPort',\n            this.config.networkPort\n        );\n        port=this.config.networkPort;\n    }\n\n    if(typeof callback == 'string'){\n        UDPType=callback;\n        callback=false;\n    }\n    if(!callback){\n        callback=emptyCallback;\n    }\n\n    if(this.of[id]){\n        if(!this.of[id].socket.destroyed){\n\n            this.log(\n                'Already Connected to',\n                id,\n                '- So executing success without connection'\n            );\n            callback();\n            return;\n        }\n        this.of[id].socket.destroy();\n    }\n\n    this.of[id] = new Client(this.config,this.log);\n    this.of[id].id = id;\n    (this.of[id].socket)? (this.of[id].socket.id=id):null;\n    this.of[id].path = host;\n    this.of[id].port = port;\n\n    this.of[id].connect();\n\n    callback(this);\n}\n\nexport {\n    IPC as default,\n    IPC\n};\n","import IPC from './services/IPC.js';\n\nclass IPCModule extends IPC{\n    constructor(){\n        super();\n\n    }\n\n    IPC=IPC;\n}\n\nconst singleton=new IPCModule;\n\nexport {\n    singleton as default,\n    IPCModule\n}\n","import Debug from 'debug';\n\n\n\n\nexport function createDebugTimer(debugScope = 'debug') {\n  let lastTimerAt: number | undefined;\n  const debug = Debug(debugScope);\n\n  return (label: string) => {\n    if (!lastTimerAt) {\n      lastTimerAt = +new Date();\n      debug(`⏱️ ${label} - start`);\n    } else {\n      const now = +new Date();\n      const duration = now - lastTimerAt;\n      debug(`⏱️ ${label} - ${duration}ms`);\n      lastTimerAt = now;\n    }\n  };\n}\n","import kleur from 'kleur';\nimport _ from 'lodash-es';\nimport { outdent } from 'outdent';\nimport { SerializedConfigItem, SerializedDmnoError } from '../../config-loader/serialization-types';\nimport { DmnoError } from '../../config-engine/errors';\nimport { DmnoConfigItemBase } from '../../config-engine/config-engine';\n\ntype ColorMod = Exclude<keyof typeof kleur, 'enabled'>;\ntype ColorMods = ColorMod | Array<ColorMod>;\n\nfunction applyMods(str: string, mods?: ColorMods) {\n  if (!mods) return str;\n  if (_.isArray(mods)) {\n    let modStr = str;\n    _.each(mods, (mod) => {\n      modStr = kleur[mod](modStr);\n    });\n    return modStr;\n  }\n  return kleur[mods](str);\n}\n\nexport function formattedValue(val: any, showType = false) {\n  let strVal: string = '';\n  let strType: string = '';\n  let mods: ColorMods | undefined;\n  if (_.isBoolean(val)) {\n    strVal = val.toString();\n    mods = ['yellow', 'italic'];\n    strType = 'boolean';\n  } else if (_.isNumber(val)) {\n    strVal = val.toString();\n    mods = 'yellow';\n    strType = 'number';\n  } else if (_.isString(val)) {\n    strVal = `\"${val}\"`;\n    strType = 'string';\n  } else if (_.isPlainObject(val)) {\n    // TODO: can definitely make this better...\n    strVal = JSON.stringify(val);\n    strType = 'object';\n  } else if (val === null) {\n    strVal = 'null';\n    mods = 'gray';\n  } else if (val === undefined) {\n    strVal = 'undefined';\n    mods = 'gray';\n  }\n  return [\n    applyMods(strVal, mods),\n    showType && strType ? kleur.gray(` (${strType})`) : '',\n  ].join('');\n}\n\n\nexport function formatError(err: SerializedDmnoError) {\n  let whenStr = '';\n  if (err.type === 'SchemaError') {\n    whenStr += 'during schema initialization';\n  }\n  if (err.type === 'ValidationError') {\n    whenStr += 'during validation';\n  }\n  if (err.type === 'CoercionError') {\n    whenStr += 'during coercion';\n  }\n  if (err.type === 'ResolutionError') {\n    whenStr += 'during resolution';\n  }\n\n  let errStr = `${err.icon} ${err.message}`;\n  if (err.isUnexpected) {\n    errStr += kleur.gray().italic(`\\n   (unexpected error${whenStr ? ` ${whenStr}` : ''})`);\n    if ('stack' in err) errStr += err.stack;\n  }\n  return errStr;\n}\n\nexport function joinAndCompact(strings: Array<string | number | boolean | undefined | null | false>, joinChar = ' ') {\n  return strings.filter((s) => !!s).join(joinChar);\n}\n\nexport function getItemSummary(item: SerializedConfigItem) {\n  const summary: Array<string> = [];\n  const icon = item.coercionError?.icon || item.resolutionError?.icon || item?.validationErrors?.[0]?.icon || '✅';\n  // item.resolvedValue === undefined ? '✅' : '✅';\n  const isSensitive = item.dataType?.sensitive;\n  const isRequired = item.dataType?.required;\n  summary.push(joinAndCompact([\n    icon,\n    kleur[item.isValid ? 'cyan' : 'red'](item.key) + (isRequired ? kleur.magenta('*') : ''),\n\n    // kleur.gray(`[type = ${item.type.getDefItem('typeLabel')}]`),\n    isSensitive && ` 🔐${kleur.italic().gray('sensitive')}`,\n  ]));\n\n  summary.push(joinAndCompact([\n    kleur.gray('   └'),\n    isSensitive && item.resolvedValue\n      // TODO: this logic should probably not live here...\n      ? `\"${item.resolvedValue.toString().substring(0, 2)}${kleur.bold('▒'.repeat(10))}\"` // ░▒▓\n      : formattedValue(item.resolvedValue, false),\n    // item.resolvedRawValue !== item.resolvedValue && kleur.gray().italic('(coerced)'),\n\n    // TODO: redact rawValue if sensitive?\n    !_.isEqual(item.resolvedRawValue, item.resolvedValue)\n      && (kleur.gray().italic('< coerced from ') + formattedValue(item.resolvedRawValue, false)),\n  ]));\n  // if (item.resolvedRawValue !== item.resolvedValue) {\n  //   summary.push(kleur.gray().italic('   > coerced from ') + formattedValue(item.resolvedRawValue, false));\n  // }\n\n  const errors = _.compact([item.coercionError, item.resolutionError, ...item.validationErrors || []]);\n  errors?.forEach((err) => {\n    summary.push(kleur.red(`   - ${err.message}`));\n  });\n  return summary.join('\\n');\n}\n","import fs from 'fs';\nimport path from 'path';\nimport kleur from 'kleur';\nimport { asyncMapValues } from './async-utils';\n\nexport type PackageManager = 'npm' | 'yarn' | 'pnpm' | 'bun' | 'moon';\n\n\nexport async function pathExists(p: string) {\n  try {\n    await fs.promises.access(p);\n    return true;\n  } catch {\n    return false;\n  }\n}\nfunction pathExistsSync(p:string) {\n  try {\n    fs.accessSync(p);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n// TODO: nx and lerna support? (lerna.json has packages array)\n// TODO: deno?\nconst PACKAGE_MANAGER_RELEVANT_FILES = {\n  packageJson: 'package.json',\n  yarnLock: 'yarn.lock',\n  npmLock: 'package-lock.json',\n  pnpmLock: 'pnpm-lock.yaml',\n  pnpmWorkspace: 'pnpm-workspace.yaml',\n  bunLock: 'bun.lockb',\n  moonWorkspace: '.moon/workspace.yml',\n};\n\n// SEE SYNC VERSION BELOW - UPDATE BOTH IF ANY CHANGES ARE MADE!\nexport async function detectPackageManager() {\n  let cwd = process.cwd();\n\n  const cwdParts = cwd.split('/');\n\n  let packageManager: PackageManager | undefined;\n  let possibleRootPackage: string | undefined;\n\n  while (!packageManager) {\n    // we could also try to detect the current package manager via env vars (ex: process.env.PNPM_PACKAGE_NAME)\n    // and then not check for all of the lockfiles...?\n\n\n    const filesFound = await asyncMapValues(\n      PACKAGE_MANAGER_RELEVANT_FILES,\n      // eslint-disable-next-line @typescript-eslint/no-loop-func\n      async (filePath) => pathExists(path.resolve(cwd, filePath)),\n    );\n\n    if (filesFound.packageJson) possibleRootPackage = cwd;\n\n    if (filesFound.pnpmLock || filesFound.pnpmWorkspace) packageManager = 'pnpm';\n    else if (filesFound.npmLock) packageManager = 'npm';\n    else if (filesFound.yarnLock) packageManager = 'yarn';\n    else if (filesFound.bunLock) packageManager = 'bun';\n    else if (filesFound.moonWorkspace) packageManager = 'moon';\n\n    if (!packageManager) {\n      cwdParts.pop();\n      cwd = cwdParts.join('/');\n    }\n    // show some hopefully useful error messaging if we hit the root folder without finding anything\n    if (cwd === '') {\n      console.log(kleur.red('Unable to find detect your package manager and workspace root!'));\n      if (possibleRootPackage) {\n        console.log(`But it looks like your workspace root might be ${kleur.green().italic(possibleRootPackage)}`);\n      }\n      console.log('We look for lock files (ex: package-lock.json) so you may just need to run a dependency install (ie `npm install`)');\n      process.exit(1);\n    }\n  }\n\n  return {\n    packageManager,\n    rootWorkspacePath: cwd,\n  };\n}\n\n\n// sync version of above fn, probably dont want this... but fine for now\nexport function detectPackageManagerSync() {\n  let cwd = process.cwd();\n\n  const cwdParts = cwd.split('/');\n\n  let packageManager: PackageManager | undefined;\n  let possibleRootPackage: string | undefined;\n\n  while (!packageManager) {\n    // we could also try to detect the current package manager via env vars (ex: process.env.PNPM_PACKAGE_NAME)\n    // and then not check for all of the lockfiles...?\n\n    const filesFound: Partial<Record<keyof typeof PACKAGE_MANAGER_RELEVANT_FILES, boolean>> = {};\n    for (const fileKey of Object.keys(PACKAGE_MANAGER_RELEVANT_FILES)) {\n      const key = fileKey as keyof typeof PACKAGE_MANAGER_RELEVANT_FILES;\n      const filePath = path.resolve(cwd, PACKAGE_MANAGER_RELEVANT_FILES[key]);\n      filesFound[key] = pathExistsSync(filePath);\n    }\n\n    if (filesFound.packageJson) possibleRootPackage = cwd;\n\n    if (filesFound.pnpmLock || filesFound.pnpmWorkspace) packageManager = 'pnpm';\n    else if (filesFound.npmLock) packageManager = 'npm';\n    else if (filesFound.yarnLock) packageManager = 'yarn';\n    else if (filesFound.bunLock) packageManager = 'bun';\n    else if (filesFound.moonWorkspace) packageManager = 'moon';\n\n    if (!packageManager) {\n      cwdParts.pop();\n      cwd = cwdParts.join('/');\n    }\n    // show some hopefully useful error messaging if we hit the root folder without finding anything\n    if (cwd === '') {\n      console.log(kleur.red('Unable to find detect your package manager and workspace root!'));\n      if (possibleRootPackage) {\n        console.log(`But it looks like your workspace root might be ${kleur.green().italic(possibleRootPackage)}`);\n      }\n      console.log('We look for lock files (ex: package-lock.json) so you may just need to run a dependency install (ie `npm install`)');\n      process.exit(1);\n    }\n  }\n\n  return {\n    packageManager,\n    rootWorkspacePath: cwd,\n  };\n}\n\n\n\n"]}